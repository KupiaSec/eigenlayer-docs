{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Eigen Layer Docs","text":"<p>Don't wait until it's too late. Secure your protocol today.</p> <p>Request an Audit</p>"},{"location":"code/core/AVSDirectory/","title":"AVSDirectory","text":""},{"location":"code/core/AVSDirectory/#contract-overview","title":"Contract Overview","text":"<p>The <code>AVSDirectory</code> contract serves as a central registry for Active Validator Services (AVS) in the EigenLayer protocol. Its primary purpose is to manage the relationships between AVS providers and operators, enabling operators to register with specific AVS systems and allowing AVS providers to maintain a list of their authorized operators.</p> <p>Within the broader EigenLayer architecture, this contract sits as a critical coordination layer between staking operators and the specialized validation services (AVS) that need their resources. It essentially facilitates the \"matching\" between those who provide staking services and the applications that need validators.</p> <p>The contract implements several important design patterns: - Upgradeable Pattern: Using OpenZeppelin's upgradeable contracts framework to allow future improvements - Guardian Pattern: Through the Pausable mixin to enable emergency stops - Ownership Pattern: Restricting certain functions to authorized entities - Signature Verification: Using off-chain signatures to confirm operator consent</p>"},{"location":"code/core/AVSDirectory/#contract-interface","title":"Contract Interface","text":""},{"location":"code/core/AVSDirectory/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li>initialize(address initialOwner, uint256 initialPausedStatus): Sets up the contract with an initial owner and pause state.</li> <li>updateAVSMetadataURI(string calldata metadataURI): Allows an AVS to update its metadata URI, which contains information about the service.</li> <li>cancelSalt(bytes32 salt): Enables an operator to invalidate a specific salt they used in signatures, preventing replay attacks.</li> <li>registerOperatorToAVS(address operator, SignatureWithSaltAndExpiry memory operatorSignature): Enables an AVS to register an operator who has cryptographically consented to the registration.</li> <li>deregisterOperatorFromAVS(address operator): Allows an AVS to remove an operator from its registry.</li> <li>calculateOperatorAVSRegistrationDigestHash(address operator, address avs, bytes32 salt, uint256 expiry): Calculates the message digest for operator registration signatures.</li> </ul>"},{"location":"code/core/AVSDirectory/#key-events","title":"Key Events","text":"<ul> <li>AVSMetadataURIUpdated: Emitted when an AVS updates its metadata URI.</li> <li>OperatorAVSRegistrationStatusUpdated: Emitted when an operator's registration status with an AVS changes.</li> </ul>"},{"location":"code/core/AVSDirectory/#important-state-variables","title":"Important State Variables","text":"<ul> <li>avsOperatorStatus: Maps AVS addresses and operator addresses to their registration status.</li> <li>operatorSaltIsSpent: Tracks which signature salts have been used by operators to prevent replay attacks.</li> <li>delegation: A reference to the DelegationManager contract that tracks operator status in the broader EigenLayer system.</li> </ul>"},{"location":"code/core/AVSDirectory/#logic-flow","title":"Logic Flow","text":""},{"location":"code/core/AVSDirectory/#operator-registration-to-avs","title":"Operator Registration to AVS","text":"<ol> <li>An operator decides to offer their services to a specific AVS.</li> <li>The operator creates and signs a message containing their intent to register with the AVS, including a unique salt and expiry time.</li> <li>The AVS calls <code>registerOperatorToAVS</code> with the operator's address and signature.</li> <li>The contract verifies:</li> <li>The operator is not already registered to this AVS</li> <li>The signature salt has not been used before</li> <li>The operator is registered in the core EigenLayer protocol</li> <li>The signature is valid and not expired</li> <li>Upon successful verification, the contract:</li> <li>Marks the salt as spent</li> <li>Updates the operator's status to REGISTERED</li> <li>Emits an OperatorAVSRegistrationStatusUpdated event</li> </ol>"},{"location":"code/core/AVSDirectory/#operator-deregistration","title":"Operator Deregistration","text":"<ol> <li>When an AVS wants to remove an operator, they call <code>deregisterOperatorFromAVS</code> with the operator's address.</li> <li>The contract verifies the operator is currently registered with the AVS.</li> <li>The operator's status is changed to UNREGISTERED.</li> <li>An OperatorAVSRegistrationStatusUpdated event is emitted.</li> </ol>"},{"location":"code/core/AVSDirectory/#security-mechanisms","title":"Security Mechanisms","text":"<ul> <li>Reentrancy Guard: Prevents malicious reentrant calls that could manipulate state.</li> <li>Pausability: Allows emergency freezing of operator registration/deregistration.</li> <li>Salt Invalidation: Operators can cancel any salt to prevent unauthorized registrations.</li> <li>Signature Expiry: All signatures have a time-bound validity period.</li> <li>Ownership Controls: Only authorized actors can perform sensitive operations.</li> </ul>"},{"location":"code/core/AVSDirectory/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Operator] --&gt;|Signs registration intent| B[Signed Message]\n    B --&gt;|Sent off-chain| C[AVS Provider]\n    C --&gt;|Calls registerOperatorToAVS with signature| D[AVSDirectory Contract]\n    D --&gt;|Verifies signature is valid| E{Validations}\n    E --&gt;|Pass| F[Register Operator]\n    E --&gt;|Fail| G[Revert Transaction]\n    F --&gt;|Emit Event| H[OperatorAVSRegistrationStatusUpdated]\n\n    C --&gt;|Calls deregisterOperatorFromAVS| I[AVSDirectory Contract]\n    I --&gt;|Checks if registered| J{Is Registered?}\n    J --&gt;|Yes| K[Deregister Operator]\n    J --&gt;|No| L[Revert Transaction]\n    K --&gt;|Emit Event| M[OperatorAVSRegistrationStatusUpdated]</code></pre>"},{"location":"code/core/AVSDirectory/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The AVSDirectory contract has several important dependencies:</p> <ul> <li>DelegationManager: Referenced through the <code>delegation</code> variable, this contract is used to verify if an address is registered as an operator in the EigenLayer protocol.</li> <li>PauserRegistry: Provides the infrastructure for emergency pausing capabilities.</li> <li>AVSDirectoryStorage: Inherited contract that defines the storage layout for AVSDirectory.</li> <li>SignatureUtilsMixin: Provides utilities for validating cryptographic signatures.</li> </ul> <p>The contract is designed to be a supporting infrastructure component for the broader EigenLayer ecosystem. AVS providers interact with this contract to manage their operator relationships, while operators interact with it indirectly through signature-based consent mechanisms. This design enables a secure, consent-based system for delegating operator resources to various validation services.</p> <p>It's worth noting that the contract includes functions marked for deprecation in a future release, indicating that the registration process is evolving, likely toward a more robust slashing-aware implementation as mentioned in the comments.</p>"},{"location":"code/core/AVSDirectoryStorage/","title":"AVSDirectoryStorage","text":""},{"location":"code/core/AVSDirectoryStorage/#contract-overview","title":"Contract Overview","text":"<p>The <code>AVSDirectoryStorage</code> contract serves as a foundational storage layer for managing the relationship between operators and AVS (Actively Validated Services) in the EigenLayer protocol. As an abstract contract, it defines the essential storage variables, constants, and immutable values that will be used by implementing contracts.</p> <p>This contract plays a crucial role in the EigenLayer ecosystem by providing the data structures necessary to track which operators are registered with which AVS services and manage the registration lifecycle. EigenLayer is a restaking protocol that allows Ethereum validators to reuse their staked ETH as security for other services, and this contract helps facilitate these connections.</p> <p>The key design pattern used is the storage contract pattern, where storage variables are separated from logic to create a cleaner inheritance chain and reduce the risk of storage collisions during upgrades. The contract also implements EIP-712 for typed structured data hashing and signing, enabling secure off-chain authorization of on-chain actions.</p>"},{"location":"code/core/AVSDirectoryStorage/#contract-interface","title":"Contract Interface","text":""},{"location":"code/core/AVSDirectoryStorage/#key-state-variables","title":"Key State Variables","text":"<ol> <li> <p><code>avsOperatorStatus</code>: A double mapping that tracks the registration status of operators for each AVS. This relationship is central to the contract's purpose.</p> </li> <li> <p><code>operatorSaltIsSpent</code>: A mapping to prevent replay attacks by tracking which signed messages (identified by their salt) have already been processed.</p> </li> <li> <p><code>delegation</code>: An immutable reference to the EigenLayer's <code>DelegationManager</code> contract, which this contract needs to interact with.</p> </li> </ol>"},{"location":"code/core/AVSDirectoryStorage/#constants","title":"Constants","text":"<ol> <li>Type Hash Constants: </li> <li><code>OPERATOR_AVS_REGISTRATION_TYPEHASH</code></li> <li><code>OPERATOR_SET_REGISTRATION_TYPEHASH</code></li> <li><code>OPERATOR_SET_FORCE_DEREGISTRATION_TYPEHASH</code></li> </ol> <p>These constants define the structure of various signed messages for EIP-712 typed data signing, enabling secure off-chain approvals.</p> <ol> <li>Pause Flags:</li> <li><code>PAUSED_OPERATOR_REGISTER_DEREGISTER_TO_AVS</code></li> <li><code>PAUSED_OPERATOR_SET_REGISTRATION_AND_DEREGISTRATION</code></li> </ol> <p>These flags control the ability to pause specific registration/deregistration functionalities in the system.</p>"},{"location":"code/core/AVSDirectoryStorage/#public-functions","title":"Public Functions","text":"<p>As an abstract storage contract, this contract does not implement business logic functions directly, but it does expose:</p> <ul> <li><code>avsOperatorStatus(address avs, address operator)</code>: Returns the registration status of an operator for a specific AVS.</li> <li><code>operatorSaltIsSpent(address operator, bytes32 salt)</code>: Shows whether a particular salt has been used for a given operator.</li> </ul>"},{"location":"code/core/AVSDirectoryStorage/#logic-flow","title":"Logic Flow","text":"<p>As a pure storage contract, the logic flow is minimal:</p> <ol> <li>The contract is initialized with a reference to the <code>DelegationManager</code> contract, which is stored immutably.</li> <li>The contract establishes storage locations for tracking operator-AVS relationships.</li> <li>It defines typehashes for EIP-712 structured data signing, enabling secure off-chain authorizations for various operations.</li> </ol> <p>The actual implementation of registration, deregistration, and other business logic will be provided by inheriting contracts.</p>"},{"location":"code/core/AVSDirectoryStorage/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[DelegationManager] --- B[AVSDirectoryStorage]\n    B --- C[Implementing Contract]\n\n    subgraph AVSDirectoryStorage\n        D[Constants: TYPEHASHES]\n        E[Storage: avsOperatorStatus]\n        F[Storage: operatorSaltIsSpent]\n    end\n\n    C --&gt; G[Operator Registration]\n    C --&gt; H[Operator Deregistration]\n    C --&gt; I[Operator Set Management]\n\n    G --&gt; E\n    H --&gt; E\n    I --&gt; E\n\n    J[Off-chain Signed Messages] -.-&gt; G\n    J -.-&gt; H\n    J -.-&gt; I\n\n    G --&gt; K[Check operatorSaltIsSpent]\n    H --&gt; K\n    I --&gt; K</code></pre>"},{"location":"code/core/AVSDirectoryStorage/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>This contract has the following dependencies:</p> <ol> <li> <p>IAVSDirectory Interface: The contract implements this interface, which defines the core functionality required for an AVS Directory.</p> </li> <li> <p>IDelegationManager Interface: The contract interacts with the DelegationManager contract, which is a core component of EigenLayer for managing delegation relationships. The DelegationManager would be consulted when operators register or deregister with AVS services to confirm their eligibility.</p> </li> <li> <p>Inheriting Contracts: As an abstract storage contract, it's designed to be inherited by one or more implementation contracts that will provide the actual business logic for operations like operator registration and deregistration.</p> </li> </ol> <p>The <code>__gap</code> variable at the end of the contract is a storage gap pattern. It reserves storage slots to allow future versions to add new variables without affecting the storage layout, which is critical for upgradeable contracts to prevent storage collisions.</p> <p>It's worth noting that the contract includes a deprecated storage variable (<code>__deprecated_DOMAIN_SEPARATOR</code>), and the <code>avsOperatorStatus</code> mapping is marked for future deprecation, indicating ongoing evolution of the contract design. This suggests the system is being actively maintained and improved over time.</p>"},{"location":"code/core/AllocationManager/","title":"AllocationManager","text":""},{"location":"code/core/AllocationManager/#contract-overview","title":"Contract Overview","text":"<p>The <code>AllocationManager</code> contract is a core component of a Web3 infrastructure system that manages the allocation of stake (position magnitude) by operators to various Actively Validated Services (AVSs). It facilitates the creation, management, and slashing of operator allocations to different operator sets within AVS services.</p> <p>At its heart, this contract serves as the coordination layer between operators who provide stake and AVS platforms that require slashable stake to ensure proper behavior. The contract enables operators to allocate portions of their staked assets to specific AVS services, making this stake \"slashable\" if the operator misbehaves while serving that AVS.</p>"},{"location":"code/core/AllocationManager/#key-functionality","title":"Key Functionality","text":"<ol> <li>Stake Allocation: Operators can allocate their staked assets to specific AVS operator sets</li> <li>Slashing Protection: AVS services can slash operators who violate their protocols</li> <li>Operator Set Management: Creation and management of operator sets within AVSs</li> <li>Registration: Operators can register/deregister from operator sets</li> <li>Delayed Modifications: Time-based delays for critical operations like deallocations and configuration changes</li> </ol>"},{"location":"code/core/AllocationManager/#design-patterns","title":"Design Patterns","text":"<p>The contract employs several sophisticated design patterns:</p> <ul> <li>Upgradeable Contract: Uses OpenZeppelin's upgradeable contract framework</li> <li>Security Measures: Implements reentrancy guards and access control systems</li> <li>Role-Based Permissions: Uses a permission controller system for flexible authorization</li> <li>Time-Delayed Operations: Critical operations have built-in time delays for security</li> <li>Enumerable Collections: Uses sets and queues to efficiently manage collections of data</li> <li>Snapshots: Records historical magnitude data to reference at specific blocks</li> </ul>"},{"location":"code/core/AllocationManager/#contract-interface","title":"Contract Interface","text":""},{"location":"code/core/AllocationManager/#key-state-variables","title":"Key State Variables","text":"<ul> <li><code>allocations</code>: Maps operators, operator sets, and strategies to allocation information</li> <li><code>registeredSets</code>: Tracks which operator sets an operator is registered to</li> <li><code>encumberedMagnitude</code>: Tracks the currently allocated magnitude for each operator-strategy pair</li> <li><code>_maxMagnitudeHistory</code>: Historical record of maximum magnitudes for each operator-strategy pair</li> <li><code>_operatorSets</code>: Tracks all operator sets for a given AVS</li> <li><code>_operatorSetMembers</code>: Tracks members of each operator set</li> <li><code>_operatorSetStrategies</code>: Associates strategies with operator sets</li> </ul>"},{"location":"code/core/AllocationManager/#public-external-functions","title":"Public &amp; External Functions","text":""},{"location":"code/core/AllocationManager/#operator-functions","title":"Operator Functions","text":"<ul> <li><code>modifyAllocations</code>: Allows operators to increase or decrease their allocations to operator sets</li> <li><code>clearDeallocationQueue</code>: Processes pending deallocations that have completed their delay period</li> <li><code>registerForOperatorSets</code>: Registers an operator with specific operator sets</li> <li><code>deregisterFromOperatorSets</code>: Removes an operator from specific operator sets</li> <li><code>setAllocationDelay</code>: Sets the delay between allocation and when the stake becomes slashable</li> </ul>"},{"location":"code/core/AllocationManager/#avs-functions","title":"AVS Functions","text":"<ul> <li><code>slashOperator</code>: Allows an AVS to slash an operator for misbehavior</li> <li><code>setAVSRegistrar</code>: Sets the registrar contract for an AVS</li> <li><code>updateAVSMetadataURI</code>: Updates the metadata URI for an AVS</li> <li><code>createOperatorSets</code>: Creates new operator sets for an AVS</li> <li><code>addStrategiesToOperatorSet</code>: Adds strategies to an operator set</li> <li><code>removeStrategiesFromOperatorSet</code>: Removes strategies from an operator set</li> </ul>"},{"location":"code/core/AllocationManager/#view-functions","title":"View Functions","text":"<ul> <li>Multiple getter functions for retrieving allocations, operator sets, magnitudes, and more</li> </ul>"},{"location":"code/core/AllocationManager/#key-events","title":"Key Events","text":"<ul> <li><code>AllocationUpdated</code>: Emitted when an allocation is modified</li> <li><code>OperatorSlashed</code>: Emitted when an operator is slashed</li> <li><code>OperatorAddedToOperatorSet</code>: Emitted when an operator joins an operator set</li> <li><code>OperatorRemovedFromOperatorSet</code>: Emitted when an operator leaves an operator set</li> <li><code>OperatorSetCreated</code>: Emitted when a new operator set is created</li> <li><code>StrategyAddedToOperatorSet</code>: Emitted when a strategy is added to an operator set</li> <li><code>StrategyRemovedFromOperatorSet</code>: Emitted when a strategy is removed from an operator set</li> </ul>"},{"location":"code/core/AllocationManager/#logic-flow","title":"Logic Flow","text":""},{"location":"code/core/AllocationManager/#allocation-flow","title":"Allocation Flow","text":"<ol> <li>An operator must first set their allocation delay using <code>setAllocationDelay</code></li> <li>The operator then allocates stake to an operator set via <code>modifyAllocations</code></li> <li>The allocation immediately encumbers the operator's magnitude</li> <li>After the allocation delay passes, the allocation becomes slashable</li> <li>The operator can deallocate stake, but it remains slashable during the deallocation delay</li> <li>After the deallocation delay, <code>clearDeallocationQueue</code> can be called to finalize the deallocation</li> </ol>"},{"location":"code/core/AllocationManager/#registration-flow","title":"Registration Flow","text":"<ol> <li>An AVS creates operator sets using <code>createOperatorSets</code></li> <li>An AVS adds strategies to operator sets via <code>addStrategiesToOperatorSet</code></li> <li>Operators allocate stake to operator sets</li> <li>Operators register with the operator sets via <code>registerForOperatorSets</code></li> <li>If an operator misbehaves, the AVS can slash them via <code>slashOperator</code></li> <li>Operators or AVSs can deregister operators via <code>deregisterFromOperatorSets</code></li> </ol>"},{"location":"code/core/AllocationManager/#slashing-flow","title":"Slashing Flow","text":"<ol> <li>An AVS detects operator misbehavior</li> <li>The AVS calls <code>slashOperator</code> with the appropriate parameters</li> <li>The contract checks that the operator is slashable</li> <li>For each strategy, the contract:</li> <li>Calculates the amount to slash based on the provided wad proportion</li> <li>Reduces the operator's current magnitude and the strategy's encumbered magnitude</li> <li>Adjusts any pending deallocations proportionally</li> <li>Updates the max magnitude</li> <li>Calls the DelegationManager to slash the operator's shares</li> <li>The slashing event is recorded</li> </ol>"},{"location":"code/core/AllocationManager/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Operator] --&gt;|Set Allocation Delay| AM[AllocationManager]\n    A --&gt;|Allocate Stake| AM\n    A --&gt;|Register for Operator Sets| AM\n    A --&gt;|Deallocate Stake| AM\n    A --&gt;|Clear Deallocation Queue| AM\n\n    AVS[AVS Service] --&gt;|Create Operator Sets| AM\n    AVS --&gt;|Add Strategies| AM\n    AVS --&gt;|Slash Operator| AM\n\n    AM --&gt;|Slashing Call| DM[DelegationManager]\n\n    AM --&gt;|Register| AVSR[AVSRegistrar]\n\n    subgraph AllocationManager\n        Allocations[Allocations]\n        OperatorSets[Operator Sets]\n        Strategies[Strategies]\n        DelayQueues[Deallocation Queues]\n        MagnitudeHistory[Magnitude History]\n    end\n\n    AM -.-&gt; Allocations\n    AM -.-&gt; OperatorSets\n    AM -.-&gt; Strategies\n    AM -.-&gt; DelayQueues\n    AM -.-&gt; MagnitudeHistory</code></pre>"},{"location":"code/core/AllocationManager/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The <code>AllocationManager</code> interacts with several other contracts in the system:</p> <ol> <li>DelegationManager: Handles delegation of stake to operators and slashing of operator shares</li> <li>Referenced in <code>slashOperator</code> to reduce an operator's shares when slashed</li> <li> <p>Used to verify operator status and retrieve operator shares</p> </li> <li> <p>AVSRegistrar: Manages the registration of operators with AVS services</p> </li> <li>Called during operator registration/deregistration with operator sets</li> <li> <p>Each AVS can have its own registrar implementation</p> </li> <li> <p>PermissionController: Manages permissions for various actions</p> </li> <li> <p>Used to verify that callers are authorized for functions like <code>slashOperator</code> or <code>createOperatorSets</code></p> </li> <li> <p>Strategy Contracts: Represent the underlying stake positions</p> </li> <li>The contract doesn't directly interact with these but references them for allocation and slashing</li> </ol>"},{"location":"code/core/AllocationManager/#security-considerations","title":"Security Considerations","text":"<p>The contract employs several security mechanisms:</p> <ol> <li>Time-Delayed Operations: </li> <li>Deallocations have a delay (DEALLOCATION_DELAY) before they take effect</li> <li>Allocation configuration has a delay (ALLOCATION_CONFIGURATION_DELAY) before changes take effect</li> <li> <p>Allocations have operator-specific delays before becoming slashable</p> </li> <li> <p>Access Control:</p> </li> <li>Functions are protected by permission checks via the <code>checkCanCall</code> modifier</li> <li> <p>Functions are pausable via the <code>onlyWhenNotPaused</code> modifier</p> </li> <li> <p>Slashable Window:</p> </li> <li>When operators deregister, they remain slashable for a period defined by DEALLOCATION_DELAY</li> <li> <p>Ensures operators cannot avoid slashing by deregistering</p> </li> <li> <p>Reentrancy Protection:</p> </li> <li> <p>The contract inherits from ReentrancyGuardUpgradeable to prevent reentrancy attacks</p> </li> <li> <p>Upgradeable Design:</p> </li> <li>The contract is designed to be upgradeable to fix bugs or add features</li> </ol> <p>The delayed operations and careful state management ensure that operators cannot manipulate the system to avoid slashing, providing security guarantees to AVS services that rely on the slashing mechanism.</p>"},{"location":"code/core/AllocationManagerStorage/","title":"AllocationManagerStorage","text":""},{"location":"code/core/AllocationManagerStorage/#contract-overview","title":"Contract Overview","text":"<p>The <code>AllocationManagerStorage</code> contract is a foundational storage component in a broader system that manages allocations of stake across different operators and strategies in a Web3 delegated staking architecture. It serves as an abstract base contract that defines the storage variables, constants, and immutable values used throughout the allocation management system.</p> <p>This contract is designed to support Active Validator Services (AVS) within the EigenLayer ecosystem, allowing operators to register for different operator sets and allocate/deallocate staked assets across them. It functions as a critical component in the system architecture, providing the storage layer for what is likely a more complex allocation management implementation.</p> <p>The contract implements several design patterns: - Storage pattern: Separating storage concerns from logic implementation - Enumerable sets: Using OpenZeppelin's EnumerableSet library for efficient set operations - Double-ended queue: Supporting ordered processing of deallocations - Snapshots: Maintaining historical records of magnitude allocations</p>"},{"location":"code/core/AllocationManagerStorage/#contract-interface","title":"Contract Interface","text":""},{"location":"code/core/AllocationManagerStorage/#key-state-variables","title":"Key State Variables","text":"<ol> <li>Delegation Management</li> <li><code>delegation</code>: Immutable reference to the DelegationManager contract in EigenLayer</li> <li><code>DEALLOCATION_DELAY</code>: Delay period before deallocations can be cleared</li> <li> <p><code>ALLOCATION_CONFIGURATION_DELAY</code>: Delay before allocation configurations take effect</p> </li> <li> <p>AVS and Operator Set Mappings</p> </li> <li><code>_avsRegistrar</code>: Maps AVS addresses to their registrar contracts</li> <li><code>_operatorSets</code>: Tracks operator set IDs created by each AVS</li> <li><code>_operatorSetStrategies</code>: Lists strategies supported by each operator set</li> <li> <p><code>_operatorSetMembers</code>: Records members of each operator set</p> </li> <li> <p>Operator Mappings</p> </li> <li><code>_allocationDelayInfo</code>: Contains allocation delay information for operators</li> <li><code>registeredSets</code>: Operator sets an operator is registered with</li> <li><code>allocatedSets</code>: Operator sets an operator has allocations in</li> <li><code>registrationStatus</code>: Registration status of operators in operator sets</li> <li><code>allocatedStrategies</code>: Strategies an operator has allocations from in an operator set</li> <li> <p><code>allocations</code>: Current and pending allocation data for operators</p> </li> <li> <p>Strategy and Deallocation Mappings</p> </li> <li><code>_maxMagnitudeHistory</code>: Historical records of operators' maximum magnitude</li> <li><code>encumberedMagnitude</code>: Amount of magnitude allocated by operators for strategies</li> <li><code>deallocationQueue</code>: Ordered queue of pending deallocations</li> </ol>"},{"location":"code/core/AllocationManagerStorage/#constants","title":"Constants","text":"<ul> <li><code>PAUSED_MODIFY_ALLOCATIONS</code>: Flag index to pause allocation/deallocation operations</li> <li><code>PAUSED_OPERATOR_SLASHING</code>: Flag index to pause operator slashing</li> <li><code>PAUSED_OPERATOR_SET_REGISTRATION_AND_DEREGISTRATION</code>: Flag index to pause registration/deregistration</li> </ul>"},{"location":"code/core/AllocationManagerStorage/#constructor","title":"Constructor","text":"<p><pre><code>constructor(IDelegationManager _delegation, uint32 _DEALLOCATION_DELAY, uint32 _ALLOCATION_CONFIGURATION_DELAY)\n</code></pre> Initializes the contract with references to the delegation manager and timing parameters for deallocations and configuration changes.</p>"},{"location":"code/core/AllocationManagerStorage/#logic-flow","title":"Logic Flow","text":"<p>The <code>AllocationManagerStorage</code> contract doesn't implement operational logic directly as it's an abstract storage contract. However, we can describe the data structure and flow:</p> <ol> <li>AVS Management</li> <li>AVSs can register metadata and create operator sets</li> <li>Each operator set can support multiple strategies</li> <li> <p>AVSs can designate a separate registrar contract to handle operator registration/deregistration</p> </li> <li> <p>Operator Registration</p> </li> <li>Operators can register for operator sets without necessarily allocating stake</li> <li> <p>Registration status is tracked for each operator and operator set combination</p> </li> <li> <p>Allocation Management</p> </li> <li>Operators allocate stake magnitude from different strategies to operator sets</li> <li>The system tracks maximum available magnitudes, encumbered magnitudes, and allocated magnitudes</li> <li> <p>When deallocations occur, they enter a time-locked queue to ensure they remain slashable</p> </li> <li> <p>Deallocation Process</p> </li> <li>Deallocations are added to a queue and subject to a delay period</li> <li>After the delay period, deallocations can be cleared, releasing the encumbered magnitude</li> <li> <p>Deallocations must be processed in order (FIFO) through the queue</p> </li> <li> <p>Security Controls</p> </li> <li>Pause flags allow for emergency stops of different system functions</li> <li>Delay mechanisms ensure changes to allocation configurations can't be misused</li> </ol>"},{"location":"code/core/AllocationManagerStorage/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    AVS[AVS] --&gt;|Creates| OpSet[Operator Set]\n    OpSet --&gt;|Supports| Strategy[Strategy]\n    Operator --&gt;|Registers with| OpSet\n    Operator --&gt;|Allocates from| Strategy\n    Operator --&gt;|Allocates to| OpSet\n    Operator --&gt;|Deallocates from| OpSet\n\n    subgraph AllocationManagerStorage\n        MaxMagnitude[Max Magnitude History]\n        EncumberedMag[Encumbered Magnitude]\n        AllocatedMag[Allocated Magnitude]\n        DeallocationQueue[Deallocation Queue]\n    end\n\n    Strategy --&gt;|Updates| MaxMagnitude\n    OpSet --&gt;|Updates| AllocatedMag\n    AllocatedMag --&gt;|Increases| EncumberedMag\n    DeallocationQueue --&gt;|After delay, decreases| EncumberedMag</code></pre>"},{"location":"code/core/AllocationManagerStorage/#dependencies-and-interactions","title":"Dependencies and Interactions","text":""},{"location":"code/core/AllocationManagerStorage/#external-dependencies","title":"External Dependencies","text":"<ol> <li>OpenZeppelin Libraries</li> <li><code>@openzeppelin/contracts/utils/structs/EnumerableSet.sol</code>: Used for efficient set membership operations</li> <li> <p><code>@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol</code>: Used for ordered processing of deallocations</p> </li> <li> <p>Custom Libraries and Interfaces</p> </li> <li><code>Snapshots</code>: Library for tracking historical values</li> <li><code>IAllocationManager</code>: Interface that this contract implements</li> <li><code>IDelegationManager</code>: Interface for interacting with the EigenLayer delegation system</li> </ol>"},{"location":"code/core/AllocationManagerStorage/#contract-interactions","title":"Contract Interactions","text":"<ol> <li>DelegationManager Integration</li> <li>Communicates with the EigenLayer delegation system to access delegation information</li> <li> <p>Used to verify delegation relationships and stakes</p> </li> <li> <p>AVS and Registrar Interaction</p> </li> <li>Allows AVSs to configure custom registrar contracts</li> <li> <p>Supports registration and deregistration workflows</p> </li> <li> <p>Storage for Inherited Contracts</p> </li> <li>Provides structured storage for child contracts that implement the actual allocation logic</li> <li>Uses a storage gap to ensure future extensions don't clash with storage layout</li> </ol> <p>The contract has been designed with careful consideration for flexibility, security, and efficient state management. The use of multiple mapping patterns enables complex relationships between operators, strategies, and operator sets while maintaining clear boundaries and efficient lookups.</p>"},{"location":"code/core/DelegationManager/","title":"DelegationManager","text":"<p>The DelegationManager contract is a core component of EigenLayer that manages delegation relationships between stakers and operators. It enables stakers to delegate their assets to operators, who can then use those assets to provide services in the EigenLayer ecosystem.</p>"},{"location":"code/core/DelegationManager/#contract-overview","title":"Contract Overview","text":"<p>This contract serves as the central delegation system in EigenLayer, enabling:</p> <ol> <li>Operators to register and manage their services</li> <li>Stakers to delegate their assets to operators</li> <li>Delegation approval workflows with optional signature verification</li> <li>Withdrawal queuing and completion with slashing protection</li> <li>Accurate accounting of delegated shares across different strategies</li> </ol> <p>The DelegationManager implements several important design patterns, including upgradeability (via OZ's <code>Initializable</code>), access control mechanisms, slashing support, and snapshot-based historical data tracking. It inherits from multiple foundational contracts to create a robust delegation system that integrates with EigenLayer's other core components.</p>"},{"location":"code/core/DelegationManager/#contract-interface","title":"Contract Interface","text":""},{"location":"code/core/DelegationManager/#key-state-variables","title":"Key State Variables","text":"<ul> <li><code>delegatedTo</code>: Maps each staker address to the operator they've delegated to</li> <li><code>operatorShares</code>: Tracks the total delegated shares for each operator per strategy</li> <li><code>_depositScalingFactor</code>: Keeps track of each staker's deposit scaling factors, which adjust for slashing</li> <li><code>_operatorDetails</code>: Stores configuration data for registered operators</li> <li><code>pendingWithdrawals</code>: Tracks withdrawals that have been queued but not completed</li> <li><code>MIN_WITHDRAWAL_DELAY_BLOCKS</code>: Minimum delay period before withdrawals can be completed</li> </ul>"},{"location":"code/core/DelegationManager/#publicexternal-functions","title":"Public/External Functions","text":""},{"location":"code/core/DelegationManager/#operator-management","title":"Operator Management","text":"<ul> <li><code>registerAsOperator</code>: Allows any address to register as an operator</li> <li><code>modifyOperatorDetails</code>: Updates operator configuration parameters</li> <li><code>updateOperatorMetadataURI</code>: Updates operator metadata information</li> </ul>"},{"location":"code/core/DelegationManager/#delegation-management","title":"Delegation Management","text":"<ul> <li><code>delegateTo</code>: Enables a staker to delegate their assets to an operator</li> <li><code>undelegate</code>: Removes delegation and queues withdrawals</li> <li><code>redelegate</code>: Combines undelegate and delegateTo in a single transaction</li> </ul>"},{"location":"code/core/DelegationManager/#withdrawal-management","title":"Withdrawal Management","text":"<ul> <li><code>queueWithdrawals</code>: Places withdrawals in the queue with appropriate slashing protection</li> <li><code>completeQueuedWithdrawal</code>/<code>completeQueuedWithdrawals</code>: Completes queued withdrawals after delay period</li> </ul>"},{"location":"code/core/DelegationManager/#share-management","title":"Share Management","text":"<ul> <li><code>increaseDelegatedShares</code>: Updates share accounting when a staker deposits more assets</li> <li><code>decreaseDelegatedShares</code>: Updates share accounting when a staker's assets are reduced</li> <li><code>slashOperatorShares</code>: Called by AllocationManager to apply slashing to an operator's shares</li> </ul>"},{"location":"code/core/DelegationManager/#important-events","title":"Important Events","text":"<ul> <li><code>OperatorRegistered</code>: Emitted when a new operator registers</li> <li><code>StakerDelegated</code>/<code>StakerUndelegated</code>: Emitted when delegation status changes</li> <li><code>OperatorSharesIncreased</code>/<code>OperatorSharesDecreased</code>: Tracks changes in operator's delegated shares</li> <li><code>SlashingWithdrawalQueued</code>/<code>SlashingWithdrawalCompleted</code>: Emitted during withdrawal lifecycle</li> <li><code>DepositScalingFactorUpdated</code>: Tracks changes in a staker's scaling factor</li> </ul>"},{"location":"code/core/DelegationManager/#logic-flow","title":"Logic Flow","text":""},{"location":"code/core/DelegationManager/#operator-registration-flow","title":"Operator Registration Flow","text":"<ol> <li>A potential operator calls <code>registerAsOperator</code></li> <li>The contract verifies the caller is not already delegated</li> <li>Initial operator configuration is set (delegation approver, allocation delay)</li> <li>The operator is \"delegated to themselves\" (self-delegation marks them as an operator)</li> <li>Events are emitted to track the registration and metadata</li> </ol>"},{"location":"code/core/DelegationManager/#delegation-flow","title":"Delegation Flow","text":"<ol> <li>A staker calls <code>delegateTo</code> with their chosen operator</li> <li>The contract verifies the staker isn't already delegated and the operator is registered</li> <li>If the operator has a delegationApprover, the signature is verified</li> <li>The staker's deposits are calculated and delegated to the operator via <code>_delegate</code></li> <li>For each strategy the staker has deposits in:</li> <li>A scaling factor is calculated based on any operator slashing</li> <li>The operator's shares are increased by the staker's withdrawable shares</li> <li>Events are emitted to record the delegation</li> </ol>"},{"location":"code/core/DelegationManager/#withdrawal-flow","title":"Withdrawal Flow","text":"<p>The withdrawal process consists of two main phases:</p> <ol> <li>Queuing a withdrawal:</li> <li>Initiated by <code>queueWithdrawals</code> or <code>undelegate</code></li> <li>The staker specifies which strategies and how many shares to withdraw</li> <li>The contract creates a withdrawal record with scaled shares</li> <li>The withdrawal is stored by its root hash and must wait a delay period</li> <li> <p>During the delay period, the shares remain slashable</p> </li> <li> <p>Completing a withdrawal:</p> </li> <li>After the delay period, <code>completeQueuedWithdrawal</code> can be called</li> <li>The contract verifies the withdrawal exists and the delay has passed</li> <li>The withdrawal's shares are calculated based on current slashing factors</li> <li>If <code>receiveAsTokens</code> is true, shares are withdrawn as tokens</li> <li>If <code>receiveAsTokens</code> is false, shares are redeposited to the staker's current delegation</li> </ol>"},{"location":"code/core/DelegationManager/#slashing-mechanism","title":"Slashing Mechanism","text":"<p>The contract implements a sophisticated slashing mechanism:</p> <ol> <li>Operators have a \"magnitude\" (tracked by AllocationManager) that represents their slashing status</li> <li>When a staker delegates, their \"deposit scaling factor\" is set relative to the operator's magnitude</li> <li>When slashing occurs, the operator's magnitude is reduced, which affects:</li> <li>The withdrawable shares of all delegated stakers</li> <li>The shares that can be withdrawn from queued withdrawals</li> <li>Shares in the withdrawal queue remain slashable during the withdrawal delay period</li> <li>Slashing applies to both active shares and shares in the withdrawal queue</li> </ol>"},{"location":"code/core/DelegationManager/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    Staker[Staker] --&gt; |depositAssets| StrategyManager\n    Staker --&gt; |delegateTo| DelegationManager\n    Staker --&gt; |undelegate| DelegationManager\n    Staker --&gt; |queueWithdrawals| DelegationManager\n    Staker --&gt; |completeQueuedWithdrawal| DelegationManager\n\n    DelegationManager --&gt; |increaseDelegatedShares| OperatorShares\n    DelegationManager --&gt; |decreaseDelegatedShares| OperatorShares\n\n    AllocationManager --&gt; |slashOperatorShares| DelegationManager\n\n    StrategyManager &lt;--&gt; |stakerDepositShares| DelegationManager\n    EigenPodManager &lt;--&gt; |beaconChainShares| DelegationManager\n\n    subgraph KeyStates\n        OperatorShares[Operator Shares]\n        WithdrawalQueue[Withdrawal Queue]\n        ScalingFactors[Deposit Scaling Factors]\n    end\n\n    DelegationManager --&gt; WithdrawalQueue\n    DelegationManager --&gt; ScalingFactors\n\n    WithdrawalQueue --&gt; |after delay| Completion{Completion}\n    Completion --&gt; |receiveAsTokens=true| TokenWithdrawal[Token Withdrawal]\n    Completion --&gt; |receiveAsTokens=false| Redeposit[Redeposit to Current Delegation]</code></pre>"},{"location":"code/core/DelegationManager/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The DelegationManager interacts with several key contracts:</p> <ol> <li>StrategyManager: </li> <li>Manages staker deposits for liquid assets</li> <li>Provides share accounting for token strategies</li> <li> <p>Called to remove/add shares during withdrawals</p> </li> <li> <p>EigenPodManager: </p> </li> <li>Manages staker deposits for beacon chain ETH</li> <li>Provides beaconChainSlashingFactor for stakers</li> <li> <p>Handles withdrawals for beacon chain ETH</p> </li> <li> <p>AllocationManager: </p> </li> <li>Tracks operator allocation delays</li> <li>Maintains operator magnitude (slashing status)</li> <li> <p>Initiates slashing via <code>slashOperatorShares</code></p> </li> <li> <p>PermissionController: </p> </li> <li>Controls which addresses can call certain functions</li> <li>Enables delegation and operations via proxies</li> </ol> <p>Key libraries supporting the contract include:</p> <ol> <li>SlashingLib: Contains utilities for calculating slashed amounts</li> <li>Snapshots: Provides historical tracking of values over time</li> <li>SignatureUtilsMixin: Handles signature verification for delegation approval</li> </ol> <p>The contract relies on EIP-712 typed signatures for secure delegation approval, allowing operators to implement custom authorization logic via their delegationApprovers.</p> <p>The DelegationManager plays a crucial role in EigenLayer's security model by implementing a withdrawal delay and slashing mechanism. This ensures that malicious operators cannot immediately withdraw assets after misconduct, giving the protocol time to detect and penalize bad behavior. The careful accounting of shares, scaling factors, and slashing protection creates a system that balances flexibility with security.</p>"},{"location":"code/core/DelegationManagerStorage/","title":"DelegationManagerStorage","text":""},{"location":"code/core/DelegationManagerStorage/#contract-overview","title":"Contract Overview","text":"<p>The <code>DelegationManagerStorage</code> contract serves as the foundation for EigenLayer's delegation mechanism, functioning as a central storage contract for the <code>DelegationManager</code> system. Its primary purpose is to maintain all state variables required for managing delegations between stakers and operators within the EigenLayer ecosystem.</p> <p>This contract follows the storage-logic separation pattern, where storage concerns are isolated from logic implementation. This architecture significantly simplifies the upgrade process for the protocol, allowing for updates to business logic without disrupting the underlying data structures.</p> <p>Key design patterns used include: - Storage-Logic Separation: Storage variables are defined separately from logic implementation - Immutable Pattern: Core dependencies are set during construction and cannot be changed - OpenZeppelin Library Integration: Leveraging established libraries for complex data structures - EIP-712 Compliance: For typed signature verification in delegation approvals - Deprecation Handling: Maintaining backward compatibility while evolving the codebase</p>"},{"location":"code/core/DelegationManagerStorage/#contract-interface","title":"Contract Interface","text":""},{"location":"code/core/DelegationManagerStorage/#key-state-variables","title":"Key State Variables","text":"<ol> <li>Delegation Relationships:</li> <li><code>operatorShares</code>: Tracks the amount of shares delegated to each operator by strategy</li> <li><code>delegatedTo</code>: Maps each staker to their chosen operator (or address(0) if not delegated)</li> <li> <p><code>_operatorDetails</code>: Stores configuration details for each operator, primarily delegation approval settings</p> </li> <li> <p>Withdrawal Management:</p> </li> <li><code>pendingWithdrawals</code>: Tracks whether a withdrawal with a specific hash is pending</li> <li><code>_stakerQueuedWithdrawalRoots</code>: Maintains a list of queued withdrawals for each staker</li> <li><code>_queuedWithdrawals</code>: Stores the details of each queued withdrawal</li> <li> <p><code>cumulativeWithdrawalsQueued</code>: Counts total withdrawals queued by each staker</p> </li> <li> <p>Slashing and Scaling:</p> </li> <li><code>_depositScalingFactor</code>: Maintains scaling factors applied to stakers' deposits per strategy</li> <li> <p><code>_cumulativeScaledSharesHistory</code>: Tracks history of cumulative staker withdrawals for slashing calculations</p> </li> <li> <p>Constants and Immutables:</p> </li> <li><code>beaconChainETHStrategy</code>: Virtual strategy representing staked ETH on the beacon chain</li> <li><code>strategyManager</code>: Reference to the EigenLayer Strategy Manager contract</li> <li><code>eigenPodManager</code>: Reference to the EigenLayer EigenPod Manager contract</li> <li><code>allocationManager</code>: Reference to the EigenLayer Allocation Manager contract</li> <li><code>MIN_WITHDRAWAL_DELAY_BLOCKS</code>: Minimum delay before withdrawals can be completed</li> </ol>"},{"location":"code/core/DelegationManagerStorage/#events","title":"Events","text":"<p>The contract inherits from <code>IDelegationManager</code>, which defines events such as: - <code>OperatorRegistered</code>: Emitted when a new operator is registered - <code>StakerDelegated</code>: Emitted when a staker delegates to an operator - <code>WithdrawalQueued</code>: Emitted when a withdrawal is queued - <code>WithdrawalCompleted</code>: Emitted when a withdrawal is completed</p>"},{"location":"code/core/DelegationManagerStorage/#logic-flow","title":"Logic Flow","text":""},{"location":"code/core/DelegationManagerStorage/#delegation-process","title":"Delegation Process","text":"<p>The contract stores the relationship between stakers and operators through the <code>delegatedTo</code> mapping. When a staker delegates their assets:</p> <ol> <li>The relationship is recorded in <code>delegatedTo</code></li> <li>The operator's delegated shares are tracked in <code>operatorShares</code></li> <li>Any scaling factors applied to the staker's deposits are recorded in <code>_depositScalingFactor</code></li> </ol> <p>This design ensures that the contract maintains an accurate record of all delegated assets, which is critical for calculating rewards, handling slashing events, and managing withdrawals.</p>"},{"location":"code/core/DelegationManagerStorage/#withdrawal-workflow","title":"Withdrawal Workflow","text":"<p>Withdrawals follow a queued approach:</p> <ol> <li>A withdrawal is initiated and assigned a unique hash (withdrawal root)</li> <li>The withdrawal is recorded in <code>_queuedWithdrawals</code> and added to the staker's set of withdrawals in <code>_stakerQueuedWithdrawalRoots</code></li> <li>The withdrawal enters a mandatory waiting period of at least <code>MIN_WITHDRAWAL_DELAY_BLOCKS</code></li> <li>Once the waiting period ends, the withdrawal can be completed</li> <li>Upon completion, the withdrawal is removed from the staker's set of queued withdrawals</li> </ol>"},{"location":"code/core/DelegationManagerStorage/#slashing-mechanism","title":"Slashing Mechanism","text":"<p>The contract implements slashing protection through:</p> <ol> <li>Tracking delegate relationships to determine which operators are responsible for stakers</li> <li>Maintaining a history of cumulative scaled shares in <code>_cumulativeScaledSharesHistory</code></li> <li>Working with the <code>AllocationManager</code> to calculate and apply slashing penalties when operators violate protocol rules</li> </ol>"},{"location":"code/core/DelegationManagerStorage/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    Staker[Staker] --&gt;|Delegates to| Operator[Operator]\n    Staker --&gt;|Queues| Withdrawal[Withdrawal]\n\n    Withdrawal --&gt;|Waits MIN_WITHDRAWAL_DELAY_BLOCKS| CompletedWithdrawal[Completed Withdrawal]\n\n    Operator --&gt;|Manages delegated shares| OperatorShares[Operator Shares]\n    Operator --&gt;|Can be slashed by| AllocationManager[Allocation Manager]\n\n    AllocationManager --&gt;|Updates| CumulativeScaledShares[Cumulative Scaled Shares History]\n\n    StrategyManager[Strategy Manager] --&gt;|Updates delegated balances| OperatorShares\n    EigenPodManager[EigenPod Manager] --&gt;|Updates beacon ETH balances| OperatorShares\n\n    subgraph DelegationManagerStorage\n        OperatorShares\n        CumulativeScaledShares\n        Withdrawal\n        CompletedWithdrawal\n    end</code></pre>"},{"location":"code/core/DelegationManagerStorage/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The <code>DelegationManagerStorage</code> contract interacts with multiple core components of the EigenLayer ecosystem:</p> <ol> <li> <p>StrategyManager: This contract is responsible for tracking delegated shares across different strategies. When a staker's position changes, the StrategyManager updates the <code>operatorShares</code> in the DelegationManager.</p> </li> <li> <p>EigenPodManager: Manages staked ETH on the beacon chain. It communicates with the DelegationManager to update the operator shares for the beacon chain ETH strategy when validators' statuses change.</p> </li> <li> <p>AllocationManager: Handles the slashing of operators who violate protocol rules. It interacts with the DelegationManager to update operator shares and cumulative scaled shares history when slashing events occur.</p> </li> <li> <p>OpenZeppelin Libraries: The contract uses OpenZeppelin's EnumerableSet library for managing sets of withdrawal roots, providing efficient addition, removal, and enumeration operations.</p> </li> <li> <p>Snapshots Library: Used for maintaining historical records of cumulative scaled shares, essential for calculating slashing penalties accurately.</p> </li> </ol> <p>The contract serves as a central data repository that coordinates information flow between these components, ensuring that delegation relationships, share accounting, and withdrawal management are handled consistently across the entire protocol.</p>"},{"location":"code/core/RewardsCoordinator/","title":"RewardsCoordinator","text":""},{"location":"code/core/RewardsCoordinator/#contract-overview","title":"Contract Overview","text":"<p>The RewardsCoordinator contract is a critical component of the EigenLayer ecosystem, responsible for managing and distributing rewards to stakers and operators. It serves as a mechanism to incentivize participation in the EigenLayer network while providing a fair and transparent way to distribute ERC20 token rewards.</p> <p>The primary functions of this contract include: - Enabling AVSs (Actively Validated Services) to distribute rewards to their operators and stakers - Facilitating customizable reward distributions based on various strategies and multipliers - Managing operator-staker split configurations for different reward types - Providing a secure, Merkle tree-based reward claiming system to efficiently process claims</p> <p>Within the broader EigenLayer architecture, the RewardsCoordinator interfaces with multiple other contracts, including the DelegationManager, StrategyManager, and AllocationManager, making it a central hub for reward flow throughout the system.</p> <p>The contract implements several design patterns: - Upgradeable contracts (using OpenZeppelin's upgradeable contracts framework) - Role-based access control - Merkle trees for efficient verification of reward claims - Time-delayed execution of configuration changes - Pausable functionality for emergency situations</p>"},{"location":"code/core/RewardsCoordinator/#contract-interface","title":"Contract Interface","text":""},{"location":"code/core/RewardsCoordinator/#key-state-variables","title":"Key State Variables","text":"<ul> <li><code>_distributionRoots</code>: Array of Merkle tree roots that define reward distributions</li> <li><code>rewardsUpdater</code>: Address authorized to submit and disable reward distribution roots</li> <li><code>activationDelay</code>: Time delay before configuration changes take effect</li> <li><code>defaultOperatorSplitBips</code>: Default percentage (in basis points) for operator-staker reward split</li> <li><code>cumulativeClaimed</code>: Mapping tracking the amount of rewards claimed by each earner for each token</li> <li>Various maps tracking reward submission hashes for different reward types</li> </ul>"},{"location":"code/core/RewardsCoordinator/#publicexternal-functions","title":"Public/External Functions","text":"<p>Reward Submission Functions: - <code>createAVSRewardsSubmission(RewardsSubmission[])</code>: Allows AVSs to submit rewards for distribution - <code>createRewardsForAllSubmission(RewardsSubmission[])</code>: Enables designated submitters to create rewards for all stakers - <code>createRewardsForAllEarners(RewardsSubmission[])</code>: Creates rewards for all stakers and operators - <code>createOperatorDirectedAVSRewardsSubmission(address, OperatorDirectedRewardsSubmission[])</code>: Enables directed rewards from AVSs to specific operators - <code>createOperatorDirectedOperatorSetRewardsSubmission(OperatorSet, OperatorDirectedRewardsSubmission[])</code>: Allows rewards to be directed to specific operator sets</p> <p>Claim Management Functions: - <code>processClaim(RewardsMerkleClaim, address)</code>: Processes a single reward claim - <code>processClaims(RewardsMerkleClaim[], address)</code>: Processes multiple reward claims - <code>setClaimerFor(address)</code>: Sets an address permitted to claim rewards on behalf of the sender - <code>setClaimerFor(address, address)</code>: Sets a claimer for a specific earner (only callable by authorized parties)</p> <p>Configuration Functions: - <code>submitRoot(bytes32, uint32)</code>: Submits a new Merkle root for reward distribution - <code>disableRoot(uint32)</code>: Disables a Merkle root before it's activated - <code>setActivationDelay(uint32)</code>: Configures the activation delay for configuration changes - <code>setDefaultOperatorSplit(uint16)</code>: Sets the default split percentage between operators and stakers - <code>setOperatorAVSSplit(address, address, uint16)</code>: Sets custom split for a specific operator-AVS pair - <code>setOperatorPISplit(address, uint16)</code>: Sets custom split for an operator's protocol-incentivized rewards - <code>setOperatorSetSplit(address, OperatorSet, uint16)</code>: Sets custom split for an operator within a specific set</p> <p>View Functions: - <code>getOperatorAVSSplit(address, address)</code>: Returns the split percentage for an operator-AVS pair - <code>getOperatorPISplit(address)</code>: Returns the operator's protocol-incentivized rewards split - <code>getOperatorSetSplit(address, OperatorSet)</code>: Returns the split percentage for an operator in a specific set - <code>getDistributionRootsLength()</code>: Returns the number of distribution roots - <code>getCurrentDistributionRoot()</code>: Returns the most recently submitted root - <code>getCurrentClaimableDistributionRoot()</code>: Returns the latest active and non-disabled root</p>"},{"location":"code/core/RewardsCoordinator/#important-events","title":"Important Events","text":"<ul> <li><code>AVSRewardsSubmissionCreated</code>: Emitted when AVS rewards are submitted</li> <li><code>RewardsSubmissionForAllCreated</code>: Emitted when rewards for all stakers are submitted</li> <li><code>OperatorDirectedAVSRewardsSubmissionCreated</code>: Emitted when operator-directed AVS rewards are submitted</li> <li><code>DistributionRootSubmitted</code>: Emitted when a new distribution root is submitted</li> <li><code>DistributionRootDisabled</code>: Emitted when a distribution root is disabled</li> <li><code>RewardsClaimed</code>: Emitted when rewards are claimed</li> <li><code>ClaimerForSet</code>: Emitted when a claimer is set for an earner</li> <li>Various events for split percentage changes and configuration updates</li> </ul>"},{"location":"code/core/RewardsCoordinator/#logic-flow","title":"Logic Flow","text":""},{"location":"code/core/RewardsCoordinator/#reward-submission-workflow","title":"Reward Submission Workflow","text":"<ol> <li>AVS Reward Submission:</li> <li>An AVS calls <code>createAVSRewardsSubmission</code> with reward parameters</li> <li>The contract validates the submission parameters (timeframes, strategies, amounts)</li> <li>Upon validation, tokens are transferred from the AVS to the contract</li> <li> <p>The submission is recorded and an event is emitted</p> </li> <li> <p>Operator-Directed Rewards:</p> </li> <li>AVS or authorized caller uses <code>createOperatorDirectedAVSRewardsSubmission</code></li> <li>Rewards are explicitly directed to specific operators</li> <li>The contract validates operator list and reward parameters</li> <li> <p>Tokens are transferred to the contract and recorded for future claims</p> </li> <li> <p>Protocol-Incentivized Rewards:</p> </li> <li>Authorized submitters call <code>createRewardsForAllSubmission</code> or <code>createRewardsForAllEarners</code></li> <li>These are system-wide rewards to incentivize participation</li> <li>Validated rewards are stored for inclusion in future Merkle distributions</li> </ol>"},{"location":"code/core/RewardsCoordinator/#merkle-root-generation-off-chain","title":"Merkle Root Generation (Off-chain)","text":"<p>While not directly visible in the contract, the system includes an off-chain component: 1. A rewards calculator aggregates all reward submissions for a period 2. It builds Merkle trees: a top-level tree of earners and nested trees for each earner's tokens 3. It submits the Merkle root via the <code>rewardsUpdater</code> role</p>"},{"location":"code/core/RewardsCoordinator/#claim-processing","title":"Claim Processing","text":"<ol> <li>Root Submission:</li> <li>The <code>rewardsUpdater</code> calls <code>submitRoot</code> with a new Merkle root</li> <li> <p>The root becomes activated after <code>activationDelay</code> time passes</p> </li> <li> <p>Claim Verification and Processing:</p> </li> <li>Users (or their authorized claimers) call <code>processClaim</code> with Merkle proofs</li> <li>The contract verifies the proofs against the active root</li> <li>The contract calculates unclaimed amounts by comparing with previously claimed amounts</li> <li>Tokens are transferred to the recipient</li> <li>Claim records are updated to prevent double claiming</li> </ol>"},{"location":"code/core/RewardsCoordinator/#split-configuration","title":"Split Configuration","text":"<ol> <li>Split Configuration:</li> <li>Operators or AVSs can set custom split percentages for their rewards</li> <li>New configurations have an activation delay before taking effect</li> <li>Split percentages define how rewards are divided between operators and delegators</li> </ol>"},{"location":"code/core/RewardsCoordinator/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    subgraph Reward Submission\n        A[AVS/Authorized Entity] --&gt;|createAVSRewardsSubmission| B[RewardsCoordinator]\n        C[AVS/Authorized Entity] --&gt;|createOperatorDirectedRewardsSubmission| B\n        D[Protocol/Authorized Entity] --&gt;|createRewardsForAllSubmission| B\n    end\n\n    subgraph Off-chain Processing\n        B --&gt;|Records submissions| E[Off-chain Rewards Calculator]\n        E --&gt;|Builds Merkle trees| F[Merkle Root]\n        F --&gt;|submitRoot| B\n    end\n\n    subgraph Claiming\n        G[Earner/Authorized Claimer] --&gt;|processClaim with proofs| B\n        B --&gt;|Verify proofs against root| H{Valid?}\n        H --&gt;|Yes| I[Transfer tokens to recipient]\n        H --&gt;|No| J[Revert transaction]\n    end\n\n    subgraph Configuration\n        K[Owner] --&gt;|setDefaultOperatorSplit| B\n        L[Operator] --&gt;|setOperatorAVSSplit| B\n        M[Operator] --&gt;|setOperatorPISplit| B\n        N[Authorized Entity] --&gt;|setRewardsUpdater| B\n    end</code></pre>"},{"location":"code/core/RewardsCoordinator/#dependencies-and-interactions","title":"Dependencies and Interactions","text":""},{"location":"code/core/RewardsCoordinator/#contract-dependencies","title":"Contract Dependencies","text":"<ul> <li>OpenZeppelin Libraries:</li> <li><code>Initializable</code>: For upgradeable contract pattern</li> <li><code>OwnableUpgradeable</code>: For ownership management</li> <li><code>ReentrancyGuardUpgradeable</code>: To prevent reentrancy attacks</li> <li><code>SafeERC20</code>: For safe ERC20 token transfers</li> </ul>"},{"location":"code/core/RewardsCoordinator/#system-contract-interactions","title":"System Contract Interactions","text":"<ul> <li>DelegationManager: Verifies operator status and manages delegation relationships</li> <li>StrategyManager: Validates strategies used for rewards calculations</li> <li>AllocationManager: Provides information about operator sets and allocations</li> <li>PermissionController: Controls which addresses can call certain functions</li> </ul>"},{"location":"code/core/RewardsCoordinator/#external-dependencies","title":"External Dependencies","text":"<ul> <li>Merkle Library: Used for proof verification in the reward claiming process</li> </ul>"},{"location":"code/core/RewardsCoordinator/#security-considerations","title":"Security Considerations","text":"<ol> <li>Reentrancy Protection: All state-changing functions use <code>nonReentrant</code> to prevent reentrancy attacks</li> <li>Pausable Functionality: Critical functions can be paused in emergency situations</li> <li>Time-Delayed Execution: Configuration changes take effect after a delay, allowing time to detect malicious changes</li> <li>Verification Before Transfer: All claims are verified against Merkle proofs before transfers</li> <li>Access Control: Different roles for different functions (owner, rewardsUpdater, claimers, etc.)</li> </ol> <p>The RewardsCoordinator serves as the central rewards management system for EigenLayer, handling the full lifecycle of rewards from submission to claiming while ensuring security and flexibility. Its design allows for various reward distribution strategies while maintaining a clear separation of concerns between different entities in the system.</p>"},{"location":"code/core/RewardsCoordinatorStorage/","title":"RewardsCoordinatorStorage","text":""},{"location":"code/core/RewardsCoordinatorStorage/#1-contract-overview","title":"1. Contract Overview","text":"<p>RewardsCoordinatorStorage is a foundational storage contract that serves as the data layer for the RewardsCoordinator system in EigenLayer's ecosystem. The contract is designed as an abstract storage layer using the common \"storage and logic separation\" pattern to facilitate smooth upgrades without compromising stored data.</p> <p>This contract centralizes the storage variables required for managing and distributing rewards within EigenLayer. It's responsible for storing information about reward distributions, operator splits, claims, and maintaining various state variables that track the reward ecosystem's status.</p> <p>The primary purpose of this contract is to define the data structures and state variables that enable: - Management of merkle root-based reward distributions - Configuration of reward sharing between operators and delegators - Tracking of reward claims by earners - Governance of reward submission permissions</p> <p>This contract uses several key design patterns: - Separation of storage and logic (for upgradability) - Merkle trees for efficient verification of rewards - Role-based access control for critical functions - Pause mechanisms for emergency control</p>"},{"location":"code/core/RewardsCoordinatorStorage/#2-contract-interface","title":"2. Contract Interface","text":""},{"location":"code/core/RewardsCoordinatorStorage/#key-state-variables","title":"Key State Variables","text":"<ul> <li><code>_distributionRoots</code>: Internal array of merkle roots used for verifying reward claims</li> <li><code>rewardsUpdater</code>: Address authorized to submit new merkle roots for rewards</li> <li><code>activationDelay</code>: Time delay before a newly submitted merkle root becomes claimable</li> <li><code>currRewardsCalculationEndTimestamp</code>: Tracks the latest reward calculation timestamp</li> <li><code>defaultOperatorSplitBips</code>: Default percentage (in basis points) for operator rewards split</li> <li><code>claimerFor</code>: Mapping that defines which addresses can claim on behalf of earners</li> <li><code>cumulativeClaimed</code>: Tracks total rewards claimed by each earner for each token</li> <li><code>submissionNonce</code>: Counter for tracking reward submissions per AVS</li> <li>Various permission mappings: Track valid rewards submission hashes and authorized submitters</li> <li><code>_operatorAVSSplitBips</code>: Custom split configurations for operators across different AVSs</li> <li><code>_operatorPISplitBips</code>: Custom split configurations for operators for Programmatic Incentives</li> <li><code>_operatorSetSplitBips</code>: Custom split configurations for operators in different operator sets</li> </ul>"},{"location":"code/core/RewardsCoordinatorStorage/#constants","title":"Constants","text":"<ul> <li>Pause flags: Constants defining specific functionality that can be paused (indices 0-9)</li> <li>Leaf salts: Constants to differentiate between earner and token leaf types in merkle trees</li> <li><code>MAX_REWARDS_AMOUNT</code>: Upper limit on reward amounts (1e38 - 1)</li> <li><code>ONE_HUNDRED_IN_BIPS</code>: Representation of 100% in basis points (10,000)</li> <li><code>beaconChainETHStrategy</code>: Canonical virtual strategy for beacon chain ETH</li> </ul>"},{"location":"code/core/RewardsCoordinatorStorage/#immutable-variables","title":"Immutable Variables","text":"<ul> <li><code>delegationManager</code>: Interface to EigenLayer's delegation system</li> <li><code>strategyManager</code>: Interface to EigenLayer's strategy management</li> <li><code>allocationManager</code>: Interface to EigenLayer's allocation management</li> <li><code>CALCULATION_INTERVAL_SECONDS</code>: Time interval for reward calculations (configured to 1 day)</li> <li><code>MAX_REWARDS_DURATION</code>: Maximum timespan for a rewards submission</li> <li><code>MAX_RETROACTIVE_LENGTH</code>: Maximum retroactive time for a rewards submission</li> <li><code>MAX_FUTURE_LENGTH</code>: Maximum future start time for a rewards submission</li> <li><code>GENESIS_REWARDS_TIMESTAMP</code>: Earliest possible timestamp for rewards submissions</li> </ul>"},{"location":"code/core/RewardsCoordinatorStorage/#3-logic-flow","title":"3. Logic Flow","text":"<p>Since this is a storage contract, it doesn't contain extensive logic flow. However, it establishes the data structure and relationships that enable the following key workflows:</p> <ol> <li>Reward Distribution Process</li> <li>External systems calculate rewards based on staking and participation</li> <li>Authorized <code>rewardsUpdater</code> submits merkle roots containing reward distributions</li> <li>Roots become active after the <code>activationDelay</code> period</li> <li> <p>Earners (or their designated claimers) can verify and claim their rewards using merkle proofs</p> </li> <li> <p>Operator Split Configuration</p> </li> <li>Operators can customize their reward splits with delegators</li> <li>Splits can be configured at different levels:<ul> <li>Per AVS (AVS-specific splits)</li> <li>For Programmatic Incentives (PI splits)</li> <li>For specific operator sets (set-specific splits)</li> </ul> </li> <li> <p>Default split applies when custom splits are not configured</p> </li> <li> <p>Reward Claiming Mechanism</p> </li> <li>Earners prove their rewards using merkle proofs against active distribution roots</li> <li>System verifies the proof and checks for double-claiming using <code>cumulativeClaimed</code></li> <li>Rewards are distributed according to configured splits between operators and delegators</li> <li> <p>Claims can be processed by the earner or their designated claimer</p> </li> <li> <p>Permission and Validation System</p> </li> <li>Submissions are validated against registered hashes</li> <li>Different types of reward submissions have separate validation mappings</li> <li>Pausing mechanisms allow for emergency control of critical functions</li> </ol>"},{"location":"code/core/RewardsCoordinatorStorage/#4-visual-representation","title":"4. Visual Representation","text":"<pre><code>flowchart TD\n    A[Off-chain Reward Calculation] --&gt;|Generates Merkle Tree| B[rewardsUpdater]\n    B --&gt;|submits| C[DistributionRoot]\n    C --&gt;|stored in| D[_distributionRoots Array]\n    C --&gt;|after activationDelay| E[Claimable Rewards]\n\n    F[Operator] --&gt;|configures| G[Custom Splits]\n    G --&gt;|stored as| H[_operatorAVSSplitBips]\n    G --&gt;|stored as| I[_operatorPISplitBips]\n    G --&gt;|stored as| J[_operatorSetSplitBips]\n\n    K[Earner/Claimer] --&gt;|submits proof against| D\n    D --&gt;|validates| L[Reward Claim]\n    L --&gt;|updates| M[cumulativeClaimed]\n\n    N[AVS] --&gt;|submits| O[Reward Submission Hash]\n    O --&gt;|stored in| P[isAVSRewardsSubmissionHash]\n\n    Q[Pause Controls] --&gt;|can restrict| R[Various Operations]\n    R --&gt;|includes| S[Submissions, Claims, Split Updates]</code></pre>"},{"location":"code/core/RewardsCoordinatorStorage/#5-dependencies-and-interactions","title":"5. Dependencies and Interactions","text":"<p>The contract integrates with several core EigenLayer components:</p> <ol> <li>DelegationManager</li> <li>Interacts with this contract to manage delegations between stakers and operators</li> <li> <p>Used to verify delegation relationships when distributing rewards</p> </li> <li> <p>StrategyManager</p> </li> <li>Communicates with this contract to understand staking strategies</li> <li> <p>Essential for validating claims and correlating reward calculations with staked assets</p> </li> <li> <p>AllocationManager</p> </li> <li>Interacts with this contract for managing service provider allocations</li> <li>Used in determining reward allocations between operators and AVSs</li> </ol> <p>This storage contract itself doesn't directly interact with these dependencies\u2014it simply stores their references for use by the implementation contract. The RewardsCoordinator implementation contract will use these interfaces to validate and process rewards based on delegation relationships, staking amounts, and allocation details.</p> <p>The contract is designed to support multiple AVS (Actively Validated Services) entities, each of which can create and manage their own reward submissions. Different types of reward submissions are supported, including: - AVS-specific rewards - Rewards for all participants - Operator-directed rewards - Operator set performance rewards</p> <p>The storage contract enforces validation of submission hashes to ensure that only legitimate, authorized reward distributions can be processed within the system.</p>"},{"location":"code/core/StrategyManager/","title":"StrategyManager","text":""},{"location":"code/core/StrategyManager/#contract-overview","title":"Contract Overview","text":"<p>The StrategyManager contract is a central component of EigenLayer, serving as the primary interface for managing deposits into and withdrawals from various investment strategies. Its core purpose is to enable users (\"stakers\") to deposit assets into different whitelisted strategies, track their shares, and facilitate the withdrawal process.</p> <p>This contract forms the backbone of EigenLayer's asset management system, acting as the gateway through which users interact with the platform's investment strategies. It sits between users and the actual investment strategies, managing deposit accounting while delegating the actual investment logic to strategy-specific contracts.</p> <p>The StrategyManager implements several key design patterns: - Proxy Pattern: The contract is designed to be upgradeable, using OpenZeppelin's upgradeable contract patterns - Role-Based Access Control: Different functions are restricted to specific roles (owner, strategy whitelister, delegation manager) - Security Guards: Implements ReentrancyGuard to prevent re-entrancy attacks and Pausable to allow halting of sensitive functions during emergencies - Signature Verification: Supports signature-based operations for improved UX and gasless transactions</p>"},{"location":"code/core/StrategyManager/#contract-interface","title":"Contract Interface","text":""},{"location":"code/core/StrategyManager/#publicexternal-functions","title":"Public/External Functions","text":""},{"location":"code/core/StrategyManager/#initialization-configuration","title":"Initialization &amp; Configuration","text":"<ul> <li><code>initialize(address initialOwner, address initialStrategyWhitelister, uint256 initialPausedStatus)</code>: Sets up the initial contract state</li> <li><code>setStrategyWhitelister(address newStrategyWhitelister)</code>: Changes who can whitelist strategies (owner only)</li> <li><code>addStrategiesToDepositWhitelist(IStrategy[] calldata strategiesToWhitelist)</code>: Adds strategies that users can deposit into</li> <li><code>removeStrategiesFromDepositWhitelist(IStrategy[] calldata strategiesToRemoveFromWhitelist)</code>: Removes strategies from the whitelist</li> </ul>"},{"location":"code/core/StrategyManager/#user-deposit-functions","title":"User Deposit Functions","text":"<ul> <li><code>depositIntoStrategy(IStrategy strategy, IERC20 token, uint256 amount)</code>: Allows users to deposit tokens into a strategy</li> <li><code>depositIntoStrategyWithSignature(...)</code>: Enables gasless deposits through signature verification</li> </ul>"},{"location":"code/core/StrategyManager/#share-management-functions","title":"Share Management Functions","text":"<ul> <li><code>removeDepositShares(address staker, IStrategy strategy, uint256 depositSharesToRemove)</code>: Removes shares from a staker</li> <li><code>addShares(address staker, IStrategy strategy, uint256 shares)</code>: Adds shares to a staker's account</li> <li><code>withdrawSharesAsTokens(address staker, IStrategy strategy, IERC20 token, uint256 shares)</code>: Withdraws shares as tokens</li> <li><code>increaseBurnableShares(IStrategy strategy, uint256 addedSharesToBurn)</code>: Increases shares marked for burning</li> <li><code>burnShares(IStrategy strategy)</code>: Burns shares, sending them to a predefined burn address</li> </ul>"},{"location":"code/core/StrategyManager/#view-functions","title":"View Functions","text":"<ul> <li><code>getDeposits(address staker)</code>: Returns a staker's deposits across all strategies</li> <li><code>getStakerStrategyList(address staker)</code>: Returns the list of strategies a staker has deposits in</li> <li><code>stakerStrategyListLength(address staker)</code>: Returns the number of strategies a staker has deposits in</li> <li><code>calculateStrategyDepositDigestHash(...)</code>: Calculates a hash for signature verification</li> <li><code>getBurnableShares(IStrategy strategy)</code>: Returns the burnable shares for a strategy</li> <li><code>getStrategiesWithBurnableShares()</code>: Returns all strategies with burnable shares</li> </ul>"},{"location":"code/core/StrategyManager/#key-events","title":"Key Events","text":"<ul> <li><code>Deposit(address staker, IStrategy strategy, uint256 shares)</code>: Emitted when a user deposits into a strategy</li> <li><code>StrategyAddedToDepositWhitelist(IStrategy strategy)</code>: Emitted when a strategy is whitelisted</li> <li><code>StrategyRemovedFromDepositWhitelist(IStrategy strategy)</code>: Emitted when a strategy is removed from the whitelist</li> <li><code>StrategyWhitelisterChanged(address oldWhitelister, address newWhitelister)</code>: Emitted when the strategy whitelister is changed</li> <li><code>BurnableSharesIncreased(IStrategy strategy, uint256 addedSharesToBurn)</code>: Emitted when burnable shares are increased</li> <li><code>BurnableSharesDecreased(IStrategy strategy, uint256 decreasedSharesToBurn)</code>: Emitted when burnable shares are decreased</li> </ul>"},{"location":"code/core/StrategyManager/#important-state-variables","title":"Important State Variables","text":"<ul> <li><code>strategyWhitelister</code>: Address authorized to manage the strategy whitelist</li> <li><code>strategyIsWhitelistedForDeposit</code>: Mapping that tracks which strategies are approved for deposits</li> <li><code>stakerStrategyList</code>: Maps stakers to their list of strategies</li> <li><code>stakerDepositShares</code>: Double mapping tracking how many shares each staker has in each strategy</li> <li><code>nonces</code>: Tracks nonces for signature-based operations</li> <li><code>burnableShares</code>: EnumerableMap tracking shares marked for burning by strategy</li> <li><code>delegation</code>: The DelegationManager contract that tracks delegation relationships</li> </ul>"},{"location":"code/core/StrategyManager/#logic-flow","title":"Logic Flow","text":""},{"location":"code/core/StrategyManager/#deposit-flow","title":"Deposit Flow","text":"<ol> <li> <p>User Initiates Deposit: A user calls <code>depositIntoStrategy</code> with a whitelisted strategy, token, and amount, or uses <code>depositIntoStrategyWithSignature</code> for a gasless operation.</p> </li> <li> <p>Token Transfer: The contract transfers tokens from the user to the strategy contract.</p> </li> <li> <p>Strategy Deposit: The strategy contract processes the tokens and returns shares representing ownership of the deposited assets.</p> </li> <li> <p>Share Accounting:</p> </li> <li>The contract records the shares to the staker's account using <code>_addShares</code>.</li> <li> <p>If this is the staker's first deposit in this strategy, the strategy is added to their <code>stakerStrategyList</code>.</p> </li> <li> <p>Delegation Update: The DelegationManager is notified to update the delegated shares, connecting the deposit to the staker's chosen operator.</p> </li> </ol>"},{"location":"code/core/StrategyManager/#withdrawal-flow","title":"Withdrawal Flow","text":"<p>The withdrawal process is managed primarily through the DelegationManager, which calls into this contract:</p> <ol> <li> <p>Share Removal: The DelegationManager calls <code>removeDepositShares</code> to reduce a staker's shares.</p> </li> <li> <p>Accounting Update:</p> </li> <li>The shares are deducted from the staker's balance.</li> <li> <p>If all shares in a strategy are withdrawn, the strategy is removed from the staker's list.</p> </li> <li> <p>Token Withdrawal: When appropriate, <code>withdrawSharesAsTokens</code> is called to convert shares back to tokens, which are sent to the staker.</p> </li> </ol>"},{"location":"code/core/StrategyManager/#share-burning-flow","title":"Share Burning Flow","text":"<ol> <li> <p>Marking Shares for Burning: The DelegationManager calls <code>increaseBurnableShares</code> to mark shares for burning (typically used for slashing).</p> </li> <li> <p>Burning Shares: Anyone can call <code>burnShares</code> to execute the burning, which:</p> </li> <li>Removes the burnable shares record</li> <li>Withdraws the shares to the burn address, effectively removing them from circulation</li> </ol>"},{"location":"code/core/StrategyManager/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    User[User/Staker] --&gt;|Deposit Assets| SM[StrategyManager]\n    SM --&gt;|Record Shares| ShareAccounting[Share Accounting]\n    SM --&gt;|Transfer Tokens| Strategy[Strategy Contract]\n    Strategy --&gt;|Issue Shares| SM\n    SM --&gt;|Update Delegated Shares| DM[DelegationManager]\n\n    DM --&gt;|Initiate Withdrawal| SM\n    SM --&gt;|Remove Shares| ShareAccounting\n    SM --&gt;|Request Token Withdrawal| Strategy\n    Strategy --&gt;|Return Tokens| User\n\n    DM --&gt;|Mark Shares for Slashing| SM\n    SM --&gt;|Register Burnable Shares| BurnableShares[Burnable Shares Tracking]\n    AnyUser[Any User] --&gt;|Call burnShares| SM\n    SM --&gt;|Burn Registered Shares| Strategy\n    Strategy --&gt;|Send to Burn Address| BurnAddr[Burn Address]</code></pre>"},{"location":"code/core/StrategyManager/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The StrategyManager interacts primarily with these components:</p> <ol> <li> <p>Strategy Contracts: These implement the <code>IStrategy</code> interface and handle the actual investment logic. The StrategyManager doesn't know the specifics of how strategies invest funds; it only interacts through their standardized interface for deposits, withdrawals, and share accounting.</p> </li> <li> <p>DelegationManager: A critical component that manages the delegation relationships between stakers and operators. The StrategyManager notifies the DelegationManager of deposits to update delegated shares, and the DelegationManager initiates withdrawals through the StrategyManager.</p> </li> <li> <p>OpenZeppelin Libraries: The contract relies heavily on OpenZeppelin's security modules:</p> </li> <li><code>Initializable</code>: For the upgradeable proxy pattern</li> <li><code>OwnableUpgradeable</code>: For ownership and access control</li> <li><code>ReentrancyGuardUpgradeable</code>: To prevent re-entrancy attacks</li> <li> <p><code>SafeERC20</code>: For safe token transfers</p> </li> <li> <p>SignatureUtilsMixin: Provides signature verification for gasless operations, enhancing user experience by allowing meta-transactions.</p> </li> <li> <p>Pausable: Enables emergency pause functionality to halt critical operations if needed.</p> </li> </ol> <p>The StrategyManager uses a whitelist-based approach to control which strategies users can deposit into, providing a security layer that ensures users can only interact with vetted and approved strategies. This whitelist is managed by a dedicated role (the strategyWhitelister), separating these administrative controls from general contract ownership.</p> <p>Overall, this contract embodies EigenLayer's approach to flexible, secure asset management, allowing users to participate in a range of strategies while maintaining proper accounting and delegation relationships.</p>"},{"location":"code/core/StrategyManagerStorage/","title":"StrategyManagerStorage","text":""},{"location":"code/core/StrategyManagerStorage/#contract-overview","title":"Contract Overview","text":"<p>StrategyManagerStorage is a foundational abstract contract in the EigenLayer ecosystem that defines storage variables for the StrategyManager contract. EigenLayer is a restaking protocol that allows ETH and other tokens to be used as security for various services in the Web3 ecosystem. </p> <p>This contract serves as the storage layer for StrategyManager, which handles asset deposits, withdrawals, and strategy management within EigenLayer. By separating storage from logic, the contract follows the proxy upgrade pattern, making the system more maintainable and upgradeable without complex storage migration issues.</p> <p>The contract primarily stores information about: - Which strategies are whitelisted for deposits - User deposits across various strategies - Permissions for strategy whitelisting - Relationships between stakers and strategies - Shares that need to be burned after slashing events</p> <p>The design pattern here is the separation of concerns between storage and logic, which is a common pattern in upgradeable contract systems.</p>"},{"location":"code/core/StrategyManagerStorage/#contract-interface","title":"Contract Interface","text":""},{"location":"code/core/StrategyManagerStorage/#key-state-variables","title":"Key State Variables","text":"<ul> <li><code>delegation</code>: Immutable reference to the DelegationManager contract, which handles delegation of restaked assets.</li> <li><code>nonces</code>: Mapping to track signature nonces for each signer, used for replay protection.</li> <li><code>strategyWhitelister</code>: Address authorized to whitelist strategies.</li> <li><code>stakerDepositShares</code>: Double mapping that tracks the amount of shares a staker has in each strategy.</li> <li><code>stakerStrategyList</code>: Mapping that stores the list of strategies a staker is participating in.</li> <li><code>strategyIsWhitelistedForDeposit</code>: Mapping to track whether a strategy is whitelisted for deposits.</li> <li><code>burnableShares</code>: EnumerableMap that tracks shares that have been slashed but not yet burned.</li> </ul>"},{"location":"code/core/StrategyManagerStorage/#constants","title":"Constants","text":"<ul> <li><code>DEPOSIT_TYPEHASH</code>: EIP-712 typehash used for deposit signature verification.</li> <li><code>MAX_STAKER_STRATEGY_LIST_LENGTH</code>: Limits the number of strategies a staker can participate in to 32.</li> <li><code>PAUSED_DEPOSITS</code>: Flag index used to pause deposits.</li> <li><code>DEFAULT_BURN_ADDRESS</code>: Default address for burning slashed shares (0x00000000000000000000000000000000000E16E4).</li> </ul>"},{"location":"code/core/StrategyManagerStorage/#events","title":"Events","text":"<p>While the contract itself doesn't emit events (as it's an abstract storage contract), the IStrategyManager interface it implements would define events for significant state changes like deposits, withdrawals, and strategy whitelisting.</p>"},{"location":"code/core/StrategyManagerStorage/#logic-flow","title":"Logic Flow","text":"<p>Since this is primarily a storage contract, it doesn't implement complex logic flows itself. However, it sets up the data structures that enable the following workflows in the implementation contract:</p> <ol> <li>Strategy Management:</li> <li>The strategyWhitelister can add or remove strategies from the whitelist.</li> <li> <p>Strategies must be whitelisted before they can accept deposits.</p> </li> <li> <p>Deposit Flow:</p> </li> <li>When a user deposits assets, the implementation contract updates stakerDepositShares.</li> <li>The strategy is added to stakerStrategyList if not already present.</li> <li> <p>The list is capped at MAX_STAKER_STRATEGY_LIST_LENGTH for gas efficiency and security.</p> </li> <li> <p>Signature Verification:</p> </li> <li>The contract includes structures for EIP-712 signature verification.</li> <li> <p>Nonces prevent signature replay attacks.</p> </li> <li> <p>Slashing Mechanism:</p> </li> <li>When operators are slashed, shares are recorded in burnableShares.</li> <li>These shares will eventually be burned by transferring to the DEFAULT_BURN_ADDRESS.</li> </ol>"},{"location":"code/core/StrategyManagerStorage/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    User[User/Staker] --&gt;|Deposits tokens| SM[StrategyManager]\n    SM --&gt;|Uses| SMS[StrategyManagerStorage]\n    SMS --&gt;|Stores| SD[Staker Deposit Data]\n    SMS --&gt;|Tracks| SL[Strategy Whitelist]\n    SMS --&gt;|Maintains| SStrat[Staker Strategy List]\n\n    Whitelister[Strategy Whitelister] --&gt;|Manages| SL\n\n    SM --&gt;|Interacts with| DM[DelegationManager]\n\n    SL --&gt;|Determines valid| Strategies[Strategies]\n    User --&gt;|Delegates to| Operators[Operators]\n\n    SM --&gt;|Records| Slashing[Slashed Shares]\n    Slashing --&gt;|Stored in| BurnShares[Burnable Shares]\n    BurnShares --&gt;|Sent to| BurnAddr[Burn Address]\n\n    subgraph StrategyManagerStorage\n        SD\n        SL\n        SStrat\n        BurnShares\n    end</code></pre>"},{"location":"code/core/StrategyManagerStorage/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<ol> <li>OpenZeppelin EnumerableMap:</li> <li>Used for efficient management of the burnableShares collection.</li> <li> <p>Provides O(1) lookups and iteration capabilities.</p> </li> <li> <p>DelegationManager:</p> </li> <li>The StrategyManagerStorage holds a reference to the DelegationManager contract.</li> <li> <p>DelegationManager handles the delegation of restaked assets to operators.</p> </li> <li> <p>Strategy Contracts:</p> </li> <li>The contract interacts with multiple strategy contracts (implementing IStrategy).</li> <li> <p>Strategies are the investment vehicles for restaked assets.</p> </li> <li> <p>AVS Directory &amp; EigenPod System:</p> </li> <li>While not directly used in this storage contract, the imports suggest interaction with the broader EigenLayer ecosystem.</li> <li>AVSDirectory would manage the registration and details of AVS (Actively Validated Services).</li> <li>EigenPodManager would handle ETH staking on the beacon chain.</li> </ol> <p>The contract contains multiple deprecated storage variables (noted with <code>__deprecated_</code> prefix), indicating the evolution of the protocol over time. These variables are kept to maintain storage layout compatibility during upgrades. The contract also includes a storage gap of 36 slots to allow for future additions without disrupting the storage layout.</p> <p>The careful organization of this storage contract demonstrates the team's focus on upgradeability and security, which are critical factors in a protocol managing significant value through restaking.</p>"},{"location":"code/interfaces/IAVSDirectory/","title":"IAVSDirectory","text":""},{"location":"code/interfaces/IAVSDirectory/#contract-overview","title":"Contract Overview","text":"<p>The <code>IAVSDirectory</code> interface defines a critical component in an EigenLayer-based system that manages the relationship between operators and Active Validator Services (AVSs). It serves as a registry that tracks the registration status of operators with different AVSs in the ecosystem.</p> <p>This contract acts as a directory service that enables: 1. Operators to register with specific AVSs 2. AVSs to manage their operator sets 3. Both parties to maintain verifiable registration records on-chain</p> <p>The contract implements several key design patterns: - Registry Pattern: Maintains a centralized directory of operator-AVS relationships - Signature Verification: Uses EIP-712 signatures for secure registration processes - Salt-Based Replay Protection: Prevents replay attacks through single-use salts - Pausable: Contains functionality to pause critical operations during emergencies - Ownable: Includes initialization with an initial owner, suggesting administrative controls</p>"},{"location":"code/interfaces/IAVSDirectory/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/IAVSDirectory/#key-functions","title":"Key Functions","text":""},{"location":"code/interfaces/IAVSDirectory/#initialization-and-administration","title":"Initialization and Administration","text":"<ul> <li><code>initialize(address initialOwner, uint256 initialPausedStatus)</code>: Sets up the contract with an initial owner and paused status.</li> </ul>"},{"location":"code/interfaces/IAVSDirectory/#registration-management","title":"Registration Management","text":"<ul> <li><code>registerOperatorToAVS(address operator, SignatureWithSaltAndExpiry memory operatorSignature)</code>: Allows an AVS to register an operator using the operator's signed consent.</li> <li><code>deregisterOperatorFromAVS(address operator)</code>: Enables an AVS to remove an operator from its registry.</li> <li><code>cancelSalt(bytes32 salt)</code>: Gives operators the ability to invalidate a previously used salt, preventing future use of a signature.</li> </ul>"},{"location":"code/interfaces/IAVSDirectory/#metadata-management","title":"Metadata Management","text":"<ul> <li><code>updateAVSMetadataURI(string calldata metadataURI)</code>: Allows AVSs to update their metadata URI, which is emitted in an event but not stored on-chain.</li> </ul>"},{"location":"code/interfaces/IAVSDirectory/#view-functions","title":"View Functions","text":"<ul> <li><code>operatorSaltIsSpent(address operator, bytes32 salt)</code>: Checks if a particular salt has been used by an operator.</li> <li><code>calculateOperatorAVSRegistrationDigestHash(address operator, address avs, bytes32 salt, uint256 expiry)</code>: Generates the digest hash that operators must sign to register with an AVS.</li> <li><code>OPERATOR_AVS_REGISTRATION_TYPEHASH()</code> and <code>OPERATOR_SET_REGISTRATION_TYPEHASH()</code>: Return the EIP-712 typehashes used for signature verification.</li> </ul>"},{"location":"code/interfaces/IAVSDirectory/#important-events","title":"Important Events","text":"<ul> <li><code>OperatorAVSRegistrationStatusUpdated(address indexed operator, address indexed avs, OperatorAVSRegistrationStatus status)</code>: Emitted when an operator's registration status with an AVS changes.</li> <li><code>AVSMetadataURIUpdated(address indexed avs, string metadataURI)</code>: Emitted when an AVS updates its metadata URI.</li> </ul>"},{"location":"code/interfaces/IAVSDirectory/#key-state-variables","title":"Key State Variables","text":"<p>While the interface doesn't explicitly define state variables, it implies the presence of: - A mapping of operator addresses to their AVS registration statuses - A mapping to track spent salts for signature replay protection - A registry of operator set registration information</p>"},{"location":"code/interfaces/IAVSDirectory/#logic-flow","title":"Logic Flow","text":""},{"location":"code/interfaces/IAVSDirectory/#operator-registration-flow","title":"Operator Registration Flow","text":"<ol> <li>Preparation:</li> <li>The operator decides to register with a specific AVS</li> <li> <p>The operator generates a unique salt and calculates an expiry time</p> </li> <li> <p>Signature Creation:</p> </li> <li>The operator calls <code>calculateOperatorAVSRegistrationDigestHash</code> to obtain the message to sign</li> <li>The operator signs this digest using their private key</li> <li> <p>The signature, along with the salt and expiry, is provided to the AVS</p> </li> <li> <p>Registration:</p> </li> <li>The AVS calls <code>registerOperatorToAVS</code> with the operator's address and signed data</li> <li>The contract verifies:<ul> <li>The signature is valid using EIP-712 signature verification</li> <li>The salt hasn't been used before</li> <li>The signature hasn't expired</li> </ul> </li> <li>If all checks pass, the operator is registered with the AVS</li> <li>The salt is marked as spent</li> <li> <p>An <code>OperatorAVSRegistrationStatusUpdated</code> event is emitted</p> </li> <li> <p>Deregistration:</p> </li> <li>An AVS can deregister an operator by calling <code>deregisterOperatorFromAVS</code></li> <li>The contract updates the operator's registration status</li> <li>An <code>OperatorAVSRegistrationStatusUpdated</code> event is emitted</li> </ol>"},{"location":"code/interfaces/IAVSDirectory/#salt-management-flow","title":"Salt Management Flow","text":"<ol> <li>The operator can cancel a previously used salt by calling <code>cancelSalt</code></li> <li>This marks the salt as spent, preventing any signatures using this salt from being processed</li> <li>This serves as a security mechanism to invalidate signatures that may have been compromised</li> </ol>"},{"location":"code/interfaces/IAVSDirectory/#metadata-update-flow","title":"Metadata Update Flow","text":"<ol> <li>An AVS can update its metadata by calling <code>updateAVSMetadataURI</code></li> <li>The contract emits an <code>AVSMetadataURIUpdated</code> event with the new URI</li> <li>External systems can monitor these events to keep track of the latest AVS metadata</li> </ol>"},{"location":"code/interfaces/IAVSDirectory/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Operator] -- \"1. Signs registration message\" --&gt; B{IAVSDirectory}\n    C[AVS] -- \"2. Calls registerOperatorToAVS()\" --&gt; B\n    B -- \"3. Verifies signature\" --&gt; B\n    B -- \"4. Marks salt as spent\" --&gt; B\n    B -- \"5. Updates registration status\" --&gt; B\n    B -- \"6. Emits OperatorAVSRegistrationStatusUpdated\" --&gt; D[Event Logs]\n\n    C -- \"7. Can later call deregisterOperatorFromAVS()\" --&gt; B\n    B -- \"8. Updates registration status\" --&gt; B\n    B -- \"9. Emits OperatorAVSRegistrationStatusUpdated\" --&gt; D\n\n    C -- \"10. Can update metadata with updateAVSMetadataURI()\" --&gt; B\n    B -- \"11. Emits AVSMetadataURIUpdated\" --&gt; D\n\n    A -- \"12. Can invalidate a salt with cancelSalt()\" --&gt; B\n    B -- \"13. Marks salt as spent\" --&gt; B\n\n    E[External Systems] -- \"14. Monitor events\" --&gt; D</code></pre>"},{"location":"code/interfaces/IAVSDirectory/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The <code>IAVSDirectory</code> interface extends several other interfaces:</p> <ol> <li> <p>ISignatureUtilsMixin: Provides utilities for signature verification, crucial for secure operator registration. It defines the <code>SignatureWithSaltAndExpiry</code> struct used in registration.</p> </li> <li> <p>IPauserRegistry: Not directly referenced in the functions but imported, suggesting the contract implements pausable functionality for emergency scenarios.</p> </li> <li> <p>IStrategy: Imported but not directly referenced, potentially related to strategies that operators might execute.</p> </li> </ol> <p>The contract also interacts with:</p> <ul> <li> <p>EigenLayer's DelegationManager: The <code>OperatorNotRegisteredToEigenLayer</code> error suggests that operators must first be registered with EigenLayer before they can register with an AVS.</p> </li> <li> <p>Operator Sets: The code references a transition from legacy M2 AVSs to a new system using \"operator sets.\" The interface provides both legacy functions and indicates future migration to operator sets for more sophisticated operator management.</p> </li> </ul> <p>Additionally, the contract implements EIP-712 for secure typed signature verification, used extensively in the registration process to ensure that operators have given consent to be registered with an AVS.</p> <p>The interface serves as a central connector in the system, linking operators, AVSs, and EigenLayer together in a secure and verifiable manner.</p>"},{"location":"code/interfaces/IAVSRegistrar/","title":"IAVSRegistrar","text":""},{"location":"code/interfaces/IAVSRegistrar/#contract-overview","title":"Contract Overview","text":"<p><code>IAVSRegistrar</code> is an interface contract that defines a standardized way for Active Validator Services (AVS) to handle operator registration and deregistration. In Web3 infrastructure, AVSs are specialized services built on top of blockchain networks that require validators or operators to perform specific tasks. This interface sits as a crucial middleware component between the operators and an allocation management system.</p> <p>The primary purpose of this interface is to provide a consistent API for an allocation management system to register and deregister operators with specific AVS services across different operator sets. It acts as a gateway that authenticates and manages operator participation in various AVS functionalities.</p> <p>The contract follows the interface design pattern, which enforces a consistent structure for all implementing contracts and enables interoperability within the system. This approach allows for multiple different AVS implementations to be integrated with the same allocation management system.</p>"},{"location":"code/interfaces/IAVSRegistrar/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/IAVSRegistrar/#publicexternal-functions","title":"Public/External Functions","text":"<ol> <li><code>registerOperator(address operator, address avs, uint32[] calldata operatorSetIds, bytes calldata data)</code></li> <li>Purpose: Registers an operator to participate in one or more operator sets within an AVS</li> <li>When Called: Called by the AllocationManager when an operator wants to join specific AVS operator sets</li> <li>Behavior: Must revert if registration fails, ensuring atomicity of the registration process</li> <li> <p>Parameters:</p> <ul> <li><code>operator</code>: The address of the operator being registered</li> <li><code>avs</code>: The AVS address the operator is registering with</li> <li><code>operatorSetIds</code>: Array of IDs representing the operator sets the operator wants to join</li> <li><code>data</code>: Arbitrary data for custom registration parameters</li> </ul> </li> <li> <p><code>deregisterOperator(address operator, address avs, uint32[] calldata operatorSetIds)</code></p> </li> <li>Purpose: Removes an operator from one or more operator sets within an AVS</li> <li>When Called: Called by the AllocationManager when an operator wants to leave specific sets</li> <li>Behavior: If this function reverts, the error is ignored, allowing for graceful degradation</li> <li> <p>Parameters: Similar to <code>registerOperator</code> but for the deregistration process</p> </li> <li> <p><code>supportsAVS(address avs)</code></p> </li> <li>Purpose: Verification method to check if a specific AVS is supported by this registrar</li> <li>When Called: Before attempting registration, to validate compatibility</li> <li>Returns: Boolean indicating whether the AVS is supported</li> </ol>"},{"location":"code/interfaces/IAVSRegistrar/#key-state-variables","title":"Key State Variables","text":"<p>While not explicitly defined in the interface (as interfaces don't contain state variables), implementing contracts would likely include:</p> <ul> <li>A reference to the authorized AllocationManager address</li> <li>A mapping of supported AVS addresses</li> <li>Data structures tracking operator membership in different sets</li> </ul>"},{"location":"code/interfaces/IAVSRegistrar/#logic-flow","title":"Logic Flow","text":"<p>The contract defines a standardized flow for operator management:</p> <ol> <li>Validation: Before registration, a client can verify AVS support using <code>supportsAVS()</code></li> <li>Registration Process:</li> <li>The AllocationManager calls <code>registerOperator()</code> with operator details and target operator sets</li> <li>The implementing contract validates the request (proper permissions, valid sets, etc.)</li> <li>If valid, the operator is added to the specified sets; otherwise, the transaction reverts</li> <li>Deregistration Process:</li> <li>The AllocationManager calls <code>deregisterOperator()</code> with sets to remove the operator from</li> <li>The implementing contract attempts to remove the operator from those sets</li> <li>Any errors are ignored to ensure the process completes</li> </ol> <p>The interface design prioritizes security through clear permissions (only the AllocationManager can call registration functions) and ensures atomicity in registration while providing fault tolerance during deregistration.</p>"},{"location":"code/interfaces/IAVSRegistrar/#visual-representation","title":"Visual Representation","text":"<pre><code>sequenceDiagram\n    participant Operator\n    participant AllocationManager\n    participant IAVSRegistrar\n    participant AVS\n\n    Operator-&gt;&gt;AllocationManager: Request to join operator sets\n    AllocationManager-&gt;&gt;IAVSRegistrar: supportsAVS(avsAddress)\n    IAVSRegistrar--&gt;&gt;AllocationManager: returns true/false\n\n    alt AVS is supported\n        AllocationManager-&gt;&gt;IAVSRegistrar: registerOperator(operator, avs, operatorSetIds, data)\n        IAVSRegistrar-&gt;&gt;IAVSRegistrar: Validate request\n        IAVSRegistrar-&gt;&gt;AVS: Update operator sets\n        IAVSRegistrar--&gt;&gt;AllocationManager: Success (or revert on failure)\n        AllocationManager--&gt;&gt;Operator: Registration confirmed\n    else AVS not supported\n        AllocationManager--&gt;&gt;Operator: Registration failed\n    end\n\n    Operator-&gt;&gt;AllocationManager: Request to leave operator sets\n    AllocationManager-&gt;&gt;IAVSRegistrar: deregisterOperator(operator, avs, operatorSetIds)\n    IAVSRegistrar-&gt;&gt;AVS: Remove from operator sets\n    IAVSRegistrar--&gt;&gt;AllocationManager: Acknowledgment (errors ignored)\n    AllocationManager--&gt;&gt;Operator: Deregistration processed</code></pre>"},{"location":"code/interfaces/IAVSRegistrar/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p><code>IAVSRegistrar</code> is designed to interact with several key components in the system:</p> <ol> <li> <p>AllocationManager: This external contract calls the registration and deregistration functions. It appears to be the authorized controller for operator management.</p> </li> <li> <p>AVS Contracts: The interface is designed to connect with various AVS implementations. Each implementing contract would handle the specifics of how operators are managed within that particular AVS.</p> </li> <li> <p>Operators: While operators don't directly interact with this interface, they are the entities being registered and deregistered. They likely interact with the AllocationManager which then interacts with this interface.</p> </li> </ol> <p>The design suggests a modular system where multiple AVS services can be integrated with a single allocation management infrastructure. This interface standardizes how operators join and leave different operational subsets within each AVS, allowing for flexibility in operator assignment while maintaining a consistent management approach across the ecosystem.</p> <p>When implementing this interface, developers would need to define the specific mechanics of: - How operator sets are structured - What validation occurs during registration - How the AVS leverages the registered operators for its services</p> <p>This interface provides substantial flexibility while ensuring a consistent API for the allocation management system to work with.</p>"},{"location":"code/interfaces/IAllocationManager/","title":"IAllocationManager","text":""},{"location":"code/interfaces/IAllocationManager/#contract-overview","title":"Contract Overview","text":"<p>IAllocationManager serves as a core interface for managing token allocations, slashing, and operator registrations in a decentralized staking system. This interface is designed to manage how operators allocate their slashable stake across various AVSs (Actively Validated Services) and their operator sets.</p> <p>The primary purpose of this contract is to create a well-structured mechanism for: 1. Operators to register with AVSs and allocate their staked tokens 2. AVSs to create operator sets and slash operators who misbehave 3. Managing the lifecycle of stake allocations, including pending allocations and deallocations</p> <p>This contract fits within a broader Web3 infrastructure that enables secure delegation, attestation, and slashing mechanics. It uses a modular design that separates different responsibilities across specialized components, allowing operators to participate in multiple services while managing their slashable risk exposure.</p> <p>Key design patterns used include: - Interface segregation (separating errors, events, and types) - Role-based access control (operators, AVSs, and delegation manager) - Time-delayed state transitions (allocation delays, deallocation periods) - Event-driven architecture for off-chain indexing</p>"},{"location":"code/interfaces/IAllocationManager/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/IAllocationManager/#key-types","title":"Key Types","text":"<p>The contract defines several important structs:</p> <ul> <li>Allocation: Represents stake allocation from a strategy to an operator set, tracking current magnitude, pending changes, and when they take effect</li> <li>AllocationDelayInfo: Tracks an operator's configuration for delays between allocation and when stake becomes slashable</li> <li>RegistrationStatus: Indicates whether an operator is registered for a set and how long they remain slashable</li> <li>OperatorSet: Defines a group of operators working together as part of an AVS</li> </ul>"},{"location":"code/interfaces/IAllocationManager/#public-functions","title":"Public Functions","text":""},{"location":"code/interfaces/IAllocationManager/#operator-management","title":"Operator Management","text":"<ul> <li>setAllocationDelay: Sets how long it takes for an operator's allocation to become slashable</li> <li>registerForOperatorSets: Registers an operator for one or more operator sets within an AVS</li> <li>deregisterFromOperatorSets: Removes an operator from operator sets but keeps their stake slashable for a period</li> <li>modifyAllocations: Updates how an operator's stake is allocated across operator sets</li> </ul>"},{"location":"code/interfaces/IAllocationManager/#avs-management","title":"AVS Management","text":"<ul> <li>createOperatorSets: Allows an AVS to create new sets of operators</li> <li>setAVSRegistrar: Sets the contract that handles registration for an AVS</li> <li>updateAVSMetadataURI: Updates AVS metadata (emits event for off-chain indexing)</li> <li>slashOperator: Allows an AVS to slash a misbehaving operator</li> <li>addStrategiesToOperatorSet: Adds new strategies to an existing operator set</li> <li>removeStrategiesFromOperatorSet: Removes strategies from an operator set</li> </ul>"},{"location":"code/interfaces/IAllocationManager/#cleanup","title":"Cleanup","text":"<ul> <li>clearDeallocationQueue: Processes pending deallocations after the slashable period</li> </ul>"},{"location":"code/interfaces/IAllocationManager/#querying","title":"Querying","text":"<ul> <li>The interface provides numerous view functions to query:</li> <li>Operator allocations and encumbered magnitudes</li> <li>Registration statuses</li> <li>Slashable stake amounts</li> <li>Operator set memberships and strategies</li> </ul>"},{"location":"code/interfaces/IAllocationManager/#events","title":"Events","text":"<p>Key events include: - AllocationDelaySet: When an operator configures their allocation delay - AllocationUpdated: When an operator's allocation magnitude changes - EncumberedMagnitudeUpdated: When an operator's allocated magnitude changes for a strategy - OperatorSlashed: When an AVS slashes an operator for misbehavior - OperatorSetCreated: When an AVS creates a new operator set - OperatorAddedToOperatorSet/OperatorRemovedFromOperatorSet: When operators join or leave sets</p>"},{"location":"code/interfaces/IAllocationManager/#logic-flow","title":"Logic Flow","text":""},{"location":"code/interfaces/IAllocationManager/#allocation-process","title":"Allocation Process","text":"<ol> <li>An operator first calls <code>setAllocationDelay</code> to establish how long their allocations will take to become slashable</li> <li>The operator registers with one or more AVSs using <code>registerForOperatorSets</code></li> <li>The operator allocates their stake to various operator sets using <code>modifyAllocations</code></li> <li>After the allocation delay passes, the stake becomes slashable by the AVS</li> </ol>"},{"location":"code/interfaces/IAllocationManager/#slashing-mechanism","title":"Slashing Mechanism","text":"<ol> <li>If an operator misbehaves, an AVS calls <code>slashOperator</code> with slashing parameters</li> <li>For each specified strategy, the contract:</li> <li>Reduces the operator's current allocation magnitude proportionally</li> <li>Reduces the strategy's max and encumbered magnitudes</li> <li>Adjusts any pending deallocations proportionally</li> <li>Updates the operator's shares in the DelegationManager</li> </ol>"},{"location":"code/interfaces/IAllocationManager/#deregistration-process","title":"Deregistration Process","text":"<ol> <li>An operator or AVS calls <code>deregisterFromOperatorSets</code> to remove the operator from sets</li> <li>The operator's stake remains slashable for a DEALLOCATION_DELAY period</li> <li>After this period, <code>clearDeallocationQueue</code> can be called to remove deallocations from the queue</li> <li>This updates the operator's encumbered magnitude accordingly</li> </ol>"},{"location":"code/interfaces/IAllocationManager/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Operator] --&gt;|setAllocationDelay| B[AllocationManager]\n    A --&gt;|registerForOperatorSets| B\n    A --&gt;|modifyAllocations| B\n    A --&gt;|deregisterFromOperatorSets| B\n\n    C[AVS] --&gt;|createOperatorSets| B\n    C --&gt;|slashOperator| B\n    C --&gt;|setAVSRegistrar| B\n\n    B --&gt;|After delay| D[Stake becomes slashable]\n    B --&gt;|After deregistration| E[Stake remains slashable for DEALLOCATION_DELAY]\n    E --&gt;|After DEALLOCATION_DELAY| F[clearDeallocationQueue]\n\n    B &lt;--&gt;|Queries| G[External systems]</code></pre>"},{"location":"code/interfaces/IAllocationManager/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The AllocationManager interacts with several other core contracts:</p> <ol> <li> <p>Delegation Manager: The AllocationManager interacts with a delegation system to determine the actual token amounts backing the allocations and to update shares during slashing.</p> </li> <li> <p>Strategy Contracts: Implementing the <code>IStrategy</code> interface, these contracts represent different staking strategies from which operators can allocate their stake.</p> </li> <li> <p>AVS Registrars: Implementing the <code>IAVSRegistrar</code> interface, these contracts handle the AVS-specific registration logic when operators register or deregister.</p> </li> <li> <p>OperatorSetLib: A library that manages the structure and operations on operator sets.</p> </li> <li> <p>IPauserRegistry: Likely used to enable emergency pausing of operations.</p> </li> </ol> <p>The AllocationManager serves as a coordination layer between these components, managing how operators allocate their stake across different AVSs and how slashing is executed, while leaving the specifics of delegation and AVS-specific registration to their respective specialized contracts.</p> <p>This modular design allows for a flexible system where strategies, AVSs, and operators can interact according to well-defined interfaces, with the AllocationManager serving as the central hub for allocation management and slashing mechanics.</p>"},{"location":"code/interfaces/IBackingEigen/","title":"IBackingEigen","text":""},{"location":"code/interfaces/IBackingEigen/#1-contract-overview","title":"1. Contract Overview","text":"<p>IBackingEigen is an interface contract that defines the functionality for a tokenized representation of Eigen tokens with enhanced control mechanisms for transfers, minting, and burning. This interface extends the standard ERC20 interface (from OpenZeppelin) by adding additional governance and security-related functions.</p> <p>The primary purpose of this interface is to define a token contract that wraps the original EIGEN token with additional features like: - Controlled transfers through allowlist mechanisms - Minting and burning capabilities with designated minters - Time-based transfer restrictions that can be disabled - Support for checkpointing functionality for potential governance purposes</p> <p>This interface appears to be part of a token system where certain tokens can be wrapped with additional restrictions and controls, likely for governance or security purposes in the broader Eigen ecosystem.</p>"},{"location":"code/interfaces/IBackingEigen/#2-contract-interface","title":"2. Contract Interface","text":""},{"location":"code/interfaces/IBackingEigen/#publicexternal-functions","title":"Public/External Functions","text":""},{"location":"code/interfaces/IBackingEigen/#transfer-control-functions","title":"Transfer Control Functions","text":"<ul> <li><code>setAllowedFrom(address from, bool isAllowedFrom)</code>: Enables the owner to specify which addresses are allowed to send tokens.</li> <li><code>setAllowedTo(address to, bool isAllowedTo)</code>: Enables the owner to specify which addresses are allowed to receive tokens.</li> <li><code>disableTransferRestrictions()</code>: Permits the owner to remove all transfer restrictions permanently.</li> </ul>"},{"location":"code/interfaces/IBackingEigen/#token-management-functions","title":"Token Management Functions","text":"<ul> <li><code>initialize(address initialOwner)</code>: Sets up the contract with its initial state and owner.</li> <li><code>setIsMinter(address minterAddress, bool newStatus)</code>: Allows the owner to designate which addresses can mint new tokens.</li> <li><code>mint(address to, uint256 amount)</code>: Lets a minter create new tokens for a specified recipient.</li> <li><code>burn(uint256 amount)</code>: Allows token holders to destroy their own tokens.</li> </ul>"},{"location":"code/interfaces/IBackingEigen/#view-functions","title":"View Functions","text":"<ul> <li><code>EIGEN()</code>: Returns the address of the original EIGEN token that this contract wraps.</li> <li><code>transferRestrictionsDisabledAfter()</code>: Returns the timestamp after which transfer restrictions no longer apply.</li> <li><code>clock()</code>: Returns the current timestamp for checkpoint tracking.</li> <li><code>CLOCK_MODE()</code>: Returns a string indicating the contract uses timestamps rather than block numbers.</li> </ul>"},{"location":"code/interfaces/IBackingEigen/#important-events","title":"Important Events","text":"<p>While no events are explicitly defined in the interface, implementations would likely include events for: - Transfer restriction changes - Minter status changes - Burning or minting operations</p>"},{"location":"code/interfaces/IBackingEigen/#key-state-variables-implied","title":"Key State Variables (Implied)","text":"<ul> <li><code>EIGEN</code>: Address of the wrapped Eigen token</li> <li><code>transferRestrictionsDisabledAfter</code>: Timestamp for automatic restriction removal</li> <li><code>isMinter</code>: Mapping of addresses to boolean values indicating minting permission</li> <li>Two implied mappings for <code>allowedFrom</code> and <code>allowedTo</code> addresses</li> </ul>"},{"location":"code/interfaces/IBackingEigen/#3-logic-flow","title":"3. Logic Flow","text":"<p>The main workflows of this contract interface revolve around controlled token transfers and supply management:</p>"},{"location":"code/interfaces/IBackingEigen/#transfer-control-workflow","title":"Transfer Control Workflow","text":"<ol> <li>By default, the contract would restrict transfers based on the <code>allowedFrom</code> and <code>allowedTo</code> mappings</li> <li>The contract owner can modify these restrictions by:</li> <li>Allowing specific addresses to send tokens using <code>setAllowedFrom</code></li> <li>Allowing specific addresses to receive tokens using <code>setAllowedTo</code></li> <li>Transfer restrictions automatically expire after the timestamp specified in <code>transferRestrictionsDisabledAfter</code></li> <li>The owner can manually and permanently disable transfer restrictions using <code>disableTransferRestrictions</code></li> </ol>"},{"location":"code/interfaces/IBackingEigen/#token-supply-management","title":"Token Supply Management","text":"<ol> <li>The contract owner designates minters using the <code>setIsMinter</code> function</li> <li>Authorized minters can create new tokens using the <code>mint</code> function, specifying a recipient and amount</li> <li>Token holders can reduce supply by burning their tokens using the <code>burn</code> function</li> </ol>"},{"location":"code/interfaces/IBackingEigen/#checkpointing-system","title":"Checkpointing System","text":"<p>The contract implements EIP-6372's clock interface, indicating it supports a timestamp-based checkpointing system, likely for voting or governance purposes. This is evident from: 1. The <code>clock()</code> function that returns the current timestamp 2. The <code>CLOCK_MODE()</code> function that specifies timestamp usage</p>"},{"location":"code/interfaces/IBackingEigen/#4-visual-representation","title":"4. Visual Representation","text":"<pre><code>flowchart TD\n    A[Contract Owner] --&gt;|initialize| B[BackingEigen Contract]\n    A --&gt;|setAllowedFrom| B\n    A --&gt;|setAllowedTo| B\n    A --&gt;|setIsMinter| B\n    A --&gt;|disableTransferRestrictions| B\n\n    C[Minter] --&gt;|mint| B\n    D[Token Holder] --&gt;|burn| B\n    D --&gt;|transfer| B\n\n    B --&gt;|1. Check if transfer restrictions disabled| E{Transfer Logic}\n    B --&gt;|2. Check allowedFrom status| E\n    B --&gt;|3. Check allowedTo status| E\n\n    E --&gt;|Restrictions passed| F[Complete Transfer]\n    E --&gt;|Restrictions failed| G[Revert Transfer]\n\n    H[EIGEN Token] -.-&gt;|wrapped by| B</code></pre>"},{"location":"code/interfaces/IBackingEigen/#5-dependencies-and-interactions","title":"5. Dependencies and Interactions","text":""},{"location":"code/interfaces/IBackingEigen/#external-dependencies","title":"External Dependencies","text":"<ul> <li>OpenZeppelin Contracts: The interface extends OpenZeppelin's <code>IERC20</code> interface, inheriting standard ERC20 token functionality.</li> </ul>"},{"location":"code/interfaces/IBackingEigen/#contract-interactions","title":"Contract Interactions","text":"<ul> <li>EIGEN Token: The contract references and likely wraps the original EIGEN token, potentially allowing for conversion between the two.</li> <li>Governance Infrastructure: Based on the checkpointing functionality, this contract likely interacts with governance contracts for voting or proposal systems.</li> <li>Minters: Designated addresses authorized to increase the token supply, which may include other system contracts.</li> </ul>"},{"location":"code/interfaces/IBackingEigen/#security-mechanisms","title":"Security Mechanisms","text":"<ol> <li>Controlled Token Movements: The allowlist system for senders and receivers provides fine-grained control over token flow.</li> <li>Restricted Minting: Only designated minters can create new tokens, preventing unauthorized inflation.</li> <li>Time-Based Restrictions: Transfer restrictions can be automatically or manually lifted, allowing for initial protection that can be relaxed once the system matures.</li> <li>Ownership Controls: Critical functions are restricted to the contract owner, providing centralized governance during initial deployment.</li> </ol> <p>This interface design balances the need for initial centralized control with mechanisms for eventual decentralization, as evidenced by the ability to disable transfer restrictions permanently.</p>"},{"location":"code/interfaces/IDelegationManager/","title":"IDelegationManager","text":""},{"location":"code/interfaces/IDelegationManager/#1-contract-overview","title":"1. Contract Overview","text":"<p>The <code>IDelegationManager</code> interface defines the contract responsible for managing delegation relationships between stakers and operators in the EigenLayer protocol. EigenLayer is a restaking platform that allows users (stakers) to delegate their staked assets to operators who can then use those assets to provide security to various applications built on top of the protocol.</p>"},{"location":"code/interfaces/IDelegationManager/#purpose-and-main-functionality","title":"Purpose and Main Functionality","text":"<p>This contract handles several core functions: - Enabling users to register as operators in the EigenLayer ecosystem - Facilitating the delegation of staked assets from stakers to operators - Managing the withdrawal process when stakers want to retrieve their assets - Tracking delegation relationships and shares across the system - Handling slashing mechanisms to penalize malicious behavior</p>"},{"location":"code/interfaces/IDelegationManager/#system-architecture-position","title":"System Architecture Position","text":"<p>The <code>IDelegationManager</code> sits at the core of the EigenLayer delegation system. It interacts with several other components:</p> <ol> <li>StrategyManager - Manages the different strategies that hold staked assets</li> <li>EigenPodManager - Handles beacon chain ETH staking</li> <li>AllocationManager - Manages allocation of staked assets to applications</li> <li>Various Strategies - Contracts that hold and manage staked assets (e.g., beaconChainETHStrategy)</li> </ol>"},{"location":"code/interfaces/IDelegationManager/#key-design-patterns","title":"Key Design Patterns","text":"<ol> <li>Role-based Access Control - Different functions can only be called by specific roles (operators, stakers, etc.)</li> <li>EIP-712 Signatures - Used for delegation approvals</li> <li>Queued Withdrawals - Implements a delayed withdrawal mechanism for security</li> <li>Slashing Mechanism - Enables penalties for malicious behavior</li> <li>Delegation Relationships - One-to-many relationship model where multiple stakers can delegate to a single operator</li> </ol>"},{"location":"code/interfaces/IDelegationManager/#2-contract-interface","title":"2. Contract Interface","text":""},{"location":"code/interfaces/IDelegationManager/#publicexternal-functions","title":"Public/External Functions","text":""},{"location":"code/interfaces/IDelegationManager/#operator-management","title":"Operator Management","text":"<ul> <li><code>registerAsOperator</code> - Allows a user to register as an operator</li> <li><code>modifyOperatorDetails</code> - Updates an operator's delegation approver</li> <li><code>updateOperatorMetadataURI</code> - Updates metadata about an operator</li> </ul>"},{"location":"code/interfaces/IDelegationManager/#delegation-management","title":"Delegation Management","text":"<ul> <li><code>delegateTo</code> - Allows a staker to delegate their assets to an operator</li> <li><code>undelegate</code> - Undelegates a staker from their current operator</li> <li><code>redelegate</code> - Undelegates from current operator and delegates to a new one in one transaction</li> </ul>"},{"location":"code/interfaces/IDelegationManager/#withdrawal-management","title":"Withdrawal Management","text":"<ul> <li><code>queueWithdrawals</code> - Queues withdrawals of staker's deposit shares</li> <li><code>completeQueuedWithdrawal</code> - Completes a previously queued withdrawal</li> <li><code>completeQueuedWithdrawals</code> - Completes multiple queued withdrawals</li> </ul>"},{"location":"code/interfaces/IDelegationManager/#shares-management","title":"Shares Management","text":"<ul> <li><code>increaseDelegatedShares</code> - Called when a staker's deposit shares increase</li> <li><code>decreaseDelegatedShares</code> - Called when a staker's beacon chain ETH balance decreases</li> <li><code>slashOperatorShares</code> - Slashes an operator's shares after malicious behavior</li> </ul>"},{"location":"code/interfaces/IDelegationManager/#view-functions","title":"View Functions","text":"<ul> <li><code>delegatedTo</code> - Returns the operator a staker is delegated to</li> <li><code>isDelegated</code> - Checks if a staker is actively delegated</li> <li><code>isOperator</code> - Checks if an address is registered as an operator</li> <li><code>getOperatorShares</code> - Returns shares delegated to an operator</li> <li><code>getWithdrawableShares</code> - Returns a staker's withdrawable shares</li> <li><code>getDepositedShares</code> - Returns a staker's deposited shares</li> <li><code>getQueuedWithdrawal</code> - Returns details of a queued withdrawal</li> </ul>"},{"location":"code/interfaces/IDelegationManager/#key-events","title":"Key Events","text":"<ul> <li><code>OperatorRegistered</code> - Emitted when a new operator registers</li> <li><code>StakerDelegated</code> - Emitted when a staker delegates to an operator</li> <li><code>StakerUndelegated</code> - Emitted when a staker undelegates</li> <li><code>StakerForceUndelegated</code> - Emitted when a staker is forcefully undelegated</li> <li><code>OperatorSharesIncreased</code> - Emitted when an operator's shares increase</li> <li><code>OperatorSharesDecreased</code> - Emitted when an operator's shares decrease</li> <li><code>OperatorSharesSlashed</code> - Emitted when an operator's shares are slashed</li> <li><code>SlashingWithdrawalQueued</code> - Emitted when a withdrawal is queued</li> <li><code>SlashingWithdrawalCompleted</code> - Emitted when a queued withdrawal is completed</li> </ul>"},{"location":"code/interfaces/IDelegationManager/#key-state-variables","title":"Key State Variables","text":"<p>While the interface doesn't directly show state variables, it implies several important ones: - Mapping of stakers to operators they're delegated to - Tracking of operator shares across different strategies - Storage of queued withdrawals - Deposit scaling factors for stakers - Operator registration status - Slashing-related information for operators and strategies</p>"},{"location":"code/interfaces/IDelegationManager/#3-logic-flow","title":"3. Logic Flow","text":""},{"location":"code/interfaces/IDelegationManager/#operator-registration-flow","title":"Operator Registration Flow","text":"<ol> <li>A user calls <code>registerAsOperator</code> with their delegation approver address and metadata</li> <li>The contract verifies the user isn't already delegated to another operator</li> <li>The user is registered as an operator and is considered \"delegated to themselves\"</li> <li>The <code>OperatorRegistered</code> event is emitted</li> </ol>"},{"location":"code/interfaces/IDelegationManager/#delegation-flow","title":"Delegation Flow","text":"<ol> <li>A staker calls <code>delegateTo</code> specifying which operator to delegate to</li> <li>If the operator has set a delegation approver, the contract verifies a valid signature</li> <li>The staker is marked as delegated to the operator</li> <li>Any currently staked assets are delegated to the operator</li> <li>The <code>StakerDelegated</code> event is emitted</li> </ol>"},{"location":"code/interfaces/IDelegationManager/#withdrawal-flow","title":"Withdrawal Flow","text":"<ol> <li>A staker calls <code>queueWithdrawals</code> to initiate withdrawal of their assets</li> <li>The contract removes shares from the staker and operator's balances</li> <li>A withdrawal record is created with a unique root hash and a minimum delay period begins</li> <li>After the delay period, the staker calls <code>completeQueuedWithdrawal</code></li> <li>The contract verifies the withdrawal is valid and the delay has passed</li> <li>The staker receives either tokens or shares based on their preference</li> <li>The withdrawal record is removed from the queue</li> </ol>"},{"location":"code/interfaces/IDelegationManager/#slashing-flow","title":"Slashing Flow","text":"<ol> <li>The AllocationManager detects malicious behavior by an operator</li> <li>It calls <code>slashOperatorShares</code> to penalize the operator</li> <li>The operator's share balance is reduced based on the severity of the violation</li> <li>The <code>OperatorSharesSlashed</code> event is emitted</li> <li>Stakers delegated to the slashed operator will receive fewer assets when they withdraw</li> </ol>"},{"location":"code/interfaces/IDelegationManager/#redelegation-flow","title":"Redelegation Flow","text":"<ol> <li>A staker calls <code>redelegate</code> with the address of the new operator they wish to delegate to</li> <li>The contract first undelegates the staker from their current operator</li> <li>All of the staker's withdrawable shares are queued for withdrawal</li> <li>The contract then delegates the staker to the new operator</li> <li>The staker's assets will be delegated to the new operator after withdrawals are completed</li> </ol>"},{"location":"code/interfaces/IDelegationManager/#4-visual-representation","title":"4. Visual Representation","text":"<pre><code>flowchart TD\n    A[Staker] --&gt;|registerAsOperator| B[Operator]\n    A --&gt;|delegateTo| B\n    A --&gt;|undelegate| C[Undelegated Staker]\n    A --&gt;|redelegate| D[New Operator]\n    A --&gt;|queueWithdrawals| E[Queued Withdrawal]\n    E --&gt;|wait for delay| F[Completable Withdrawal]\n    F --&gt;|completeQueuedWithdrawal| G[Withdrawal Complete]\n\n    B --&gt;|slashOperatorShares| H[Slashed Operator]\n    B --&gt;|increaseDelegatedShares| I[Increased Shares]\n    B --&gt;|decreaseDelegatedShares| J[Decreased Shares]\n\n    K[StrategyManager] --&gt;|increaseDelegatedShares| B\n    L[EigenPodManager] --&gt;|decreaseDelegatedShares| B\n    M[AllocationManager] --&gt;|slashOperatorShares| B</code></pre> <pre><code>sequenceDiagram\n    participant Staker\n    participant DelegationManager\n    participant Operator\n    participant Strategy\n\n    Staker-&gt;&gt;DelegationManager: delegateTo(operator)\n    alt Operator has delegationApprover\n        DelegationManager-&gt;&gt;Operator: verify signature\n    end\n    DelegationManager-&gt;&gt;DelegationManager: update delegation status\n    DelegationManager-&gt;&gt;DelegationManager: emit StakerDelegated\n\n    Staker-&gt;&gt;DelegationManager: queueWithdrawals()\n    DelegationManager-&gt;&gt;DelegationManager: calculate shares\n    DelegationManager-&gt;&gt;DelegationManager: create withdrawal record\n    DelegationManager-&gt;&gt;DelegationManager: emit SlashingWithdrawalQueued\n\n    Note over Staker,DelegationManager: After minWithdrawalDelayBlocks\n\n    Staker-&gt;&gt;DelegationManager: completeQueuedWithdrawal()\n    DelegationManager-&gt;&gt;Strategy: withdraw shares\n    alt receiveAsTokens = true\n        Strategy-&gt;&gt;Staker: transfer tokens\n    else receiveAsTokens = false\n        Strategy-&gt;&gt;Staker: transfer shares\n    end\n    DelegationManager-&gt;&gt;DelegationManager: emit SlashingWithdrawalCompleted</code></pre>"},{"location":"code/interfaces/IDelegationManager/#5-dependencies-and-interactions","title":"5. Dependencies and Interactions","text":""},{"location":"code/interfaces/IDelegationManager/#core-contract-interactions","title":"Core Contract Interactions","text":"<ol> <li>With StrategyManager</li> <li>The StrategyManager calls <code>increaseDelegatedShares</code> when a staker's deposit increases</li> <li>The DelegationManager calls into StrategyManager during the withdrawal process</li> <li> <p>The DelegationManager may receive callbacks from StrategyManager for shares accounting</p> </li> <li> <p>With EigenPodManager</p> </li> <li>The EigenPodManager calls <code>decreaseDelegatedShares</code> when a staker's beacon chain ETH decreases</li> <li> <p>DelegationManager has special handling for the beaconChainETHStrategy</p> </li> <li> <p>With AllocationManager</p> </li> <li>The AllocationManager calls <code>slashOperatorShares</code> when applying slashing penalties</li> <li> <p>AllocationManager tracks allocations of operators' delegated stake</p> </li> <li> <p>With Strategy Contracts</p> </li> <li>DelegationManager interacts with various strategy contracts to manage shares</li> <li>Specific handling for beaconChainETHStrategy which represents beacon chain ETH stakes</li> </ol>"},{"location":"code/interfaces/IDelegationManager/#external-dependencies","title":"External Dependencies","text":"<ol> <li>IStrategy Interface</li> <li>Used to interact with different staking strategies</li> <li> <p>Each strategy represents a different type of staked asset</p> </li> <li> <p>IPauserRegistry</p> </li> <li> <p>Likely used for emergency pause functionality</p> </li> <li> <p>ISignatureUtilsMixin</p> </li> <li>Provides utilities for signature verification</li> <li> <p>Used in the delegation approval process</p> </li> <li> <p>SlashingLib</p> </li> <li>Library providing slashing calculation functionality</li> </ol> <p>The DelegationManager sits at the heart of the EigenLayer staking and delegation system, facilitating the core functionality that allows EigenLayer to provide security to various applications through restaking. It manages the complex relationships between stakers, operators, and the strategies that hold their assets, while implementing security measures like delayed withdrawals and slashing to protect the integrity of the system.</p>"},{"location":"code/interfaces/IETHPOSDeposit/","title":"IETHPOSDeposit","text":""},{"location":"code/interfaces/IETHPOSDeposit/#contract-overview","title":"Contract Overview","text":"<p>The <code>IETHPOSDeposit</code> contract is a crucial interface for Ethereum's transition from Proof of Work (PoW) to Proof of Stake (PoS), commonly known as \"The Merge\" or \"Ethereum 2.0\". This interface defines the contract that allows validators to deposit ETH and participate in Ethereum's consensus mechanism under the PoS model.</p>"},{"location":"code/interfaces/IETHPOSDeposit/#purpose-and-functionality","title":"Purpose and Functionality","text":"<p>The primary purpose of this contract is to facilitate the staking of ETH by validators who wish to participate in the Ethereum PoS consensus mechanism. It provides a standardized interface for:</p> <ol> <li>Depositing ETH with the necessary validator credentials</li> <li>Retrieving information about deposits (deposit root hash and count)</li> </ol> <p>This represents the critical bridge between Ethereum's execution layer (formerly \"Eth1\") and the consensus layer (formerly \"Eth2\"), allowing validators to register themselves and stake the required 32 ETH to become validators.</p>"},{"location":"code/interfaces/IETHPOSDeposit/#system-architecture-context","title":"System Architecture Context","text":"<p>This interface defines the deposit contract that sits at the boundary between Ethereum's execution layer and consensus layer. It's one of the foundational components that enabled Ethereum's transition to Proof of Stake. The actual implementation of this interface is deployed on the Ethereum network and is responsible for collecting and tracking validator deposits.</p>"},{"location":"code/interfaces/IETHPOSDeposit/#design-patterns","title":"Design Patterns","text":"<p>The contract follows several important design patterns:</p> <ol> <li>Interface Separation: By defining a clean interface, it allows for implementation changes while maintaining a consistent API.</li> <li>Event-Driven Architecture: Uses events to signal when deposits are processed, allowing off-chain services to monitor validator registrations.</li> <li>Immutable Design: The interface is designed to be simple and unchangeable, providing stability for such a critical system component.</li> </ol>"},{"location":"code/interfaces/IETHPOSDeposit/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/IETHPOSDeposit/#publicexternal-functions","title":"Public/External Functions","text":"<ol> <li><code>deposit</code> - The primary function that allows prospective validators to deposit their 32 ETH along with their validation credentials. Parameters include:</li> <li><code>pubkey</code>: The validator's BLS12-381 public key</li> <li><code>withdrawal_credentials</code>: Commitment to a public key for eventual withdrawals</li> <li><code>signature</code>: A BLS12-381 signature proving ownership of the validator keys</li> <li> <p><code>deposit_data_root</code>: A hash providing integrity protection for the deposit data</p> </li> <li> <p><code>get_deposit_root</code> - A view function that returns the current deposit root hash, which is part of the Merkle tree that tracks all deposits.</p> </li> <li> <p><code>get_deposit_count</code> - A view function that returns the current number of deposits that have been made, encoded as a little-endian 64-bit value.</p> </li> </ol>"},{"location":"code/interfaces/IETHPOSDeposit/#important-events","title":"Important Events","text":"<ol> <li><code>DepositEvent</code> - Emitted when a deposit is processed successfully. It includes:</li> <li><code>pubkey</code>: The validator's public key</li> <li><code>withdrawal_credentials</code>: The withdrawal credentials provided</li> <li><code>amount</code>: The amount of ETH deposited</li> <li><code>signature</code>: The signature provided with the deposit</li> <li><code>index</code>: Likely an index value for the deposit in the sequence of all deposits</li> </ol>"},{"location":"code/interfaces/IETHPOSDeposit/#key-state-variables","title":"Key State Variables","text":"<p>While the interface doesn't explicitly define state variables (as interfaces in Solidity can't contain state variables), the implementation would necessarily track:</p> <ul> <li>A Merkle tree of all deposits to generate the deposit root</li> <li>A counter for the total number of deposits</li> <li>Validator information associated with each deposit</li> </ul>"},{"location":"code/interfaces/IETHPOSDeposit/#logic-flow","title":"Logic Flow","text":""},{"location":"code/interfaces/IETHPOSDeposit/#deposit-process","title":"Deposit Process","text":"<ol> <li>A user prepares their validator credentials off-chain (generating keys using appropriate tools)</li> <li>They calculate the <code>deposit_data_root</code> according to the Ethereum 2.0 specification</li> <li>They call the <code>deposit</code> function with their validator credentials and exactly 32 ETH</li> <li>The contract verifies the deposit data integrity using the provided <code>deposit_data_root</code></li> <li>If valid, the contract:</li> <li>Records the deposit in its internal state</li> <li>Updates the deposit root hash</li> <li>Increments the deposit count</li> <li>Emits a <code>DepositEvent</code> with all relevant details</li> <li>The consensus layer clients observe this event and register the new validator</li> </ol>"},{"location":"code/interfaces/IETHPOSDeposit/#data-retrieval","title":"Data Retrieval","text":"<ul> <li>The <code>get_deposit_root()</code> function retrieves the current root hash of the Merkle tree of deposits</li> <li>The <code>get_deposit_count()</code> function returns the total number of deposits processed</li> </ul>"},{"location":"code/interfaces/IETHPOSDeposit/#security-mechanisms","title":"Security Mechanisms","text":"<ol> <li>Data Integrity Protection: The <code>deposit_data_root</code> parameter acts as a commitment to the deposit data, protecting against malformed inputs.</li> <li>BLS Signatures: The use of BLS12-381 signatures provides cryptographic proof of validator key ownership.</li> <li>Immutable Design: The simplicity and immutability of the interface reduce the attack surface.</li> </ol>"},{"location":"code/interfaces/IETHPOSDeposit/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Validator] --&gt;|Generate Keys| B[Create Deposit Data]\n    B --&gt;|Calculate deposit_data_root| C[Send 32 ETH + Credentials]\n    C --&gt;|deposit()| D[ETHPOSDeposit Contract]\n    D --&gt;|Verify deposit_data_root| E{Is Valid?}\n    E --&gt;|Yes| F[Record Deposit]\n    F --&gt; G[Update Merkle Tree]\n    G --&gt; H[Increment Deposit Count]\n    H --&gt; I[Emit DepositEvent]\n    E --&gt;|No| J[Revert Transaction]\n\n    K[External Systems] --&gt;|get_deposit_root()| D\n    L[External Systems] --&gt;|get_deposit_count()| D\n    I --&gt;|Listen for Events| M[Ethereum Consensus Layer]\n    M --&gt;|Register Validator| N[Validator Pool]</code></pre>"},{"location":"code/interfaces/IETHPOSDeposit/#dependencies-and-interactions","title":"Dependencies and Interactions","text":""},{"location":"code/interfaces/IETHPOSDeposit/#contract-interactions","title":"Contract Interactions","text":"<ol> <li> <p>Validator Clients: Consensus layer clients listen for <code>DepositEvent</code> events to detect new validator registrations.</p> </li> <li> <p>Block Explorers/Analytics: These services may call <code>get_deposit_root()</code> and <code>get_deposit_count()</code> to track the state of validator registrations.</p> </li> <li> <p>Staking Services/Pools: These might interact with the deposit contract to allow users to stake amounts smaller than 32 ETH by pooling resources.</p> </li> </ol>"},{"location":"code/interfaces/IETHPOSDeposit/#external-dependencies","title":"External Dependencies","text":"<ol> <li> <p>BLS12-381 Library: While not explicitly imported, the contract relies on the ability to verify BLS12-381 signatures.</p> </li> <li> <p>SSZ Encoding: The deposit data is expected to be SSZ-encoded before hashing for the <code>deposit_data_root</code>, following the Ethereum 2.0 specifications.</p> </li> <li> <p>Merkle Tree Implementation: The implementation relies on a Merkle tree structure to efficiently track all deposits and generate the deposit root.</p> </li> </ol> <p>This interface represents one of the most important bridges in Ethereum's evolution, enabling the transition to a more energy-efficient and scalable consensus mechanism while maintaining security and decentralization.</p>"},{"location":"code/interfaces/IEigen/","title":"IEigen","text":""},{"location":"code/interfaces/IEigen/#contract-overview","title":"Contract Overview","text":"<p>IEigen is an interface that extends the standard ERC20 token interface (IERC20) with additional functionality specific to the Eigen token ecosystem. This interface defines the contract interactions for Eigen, which appears to be a governance or utility token within a broader Web3 system.</p> <p>The interface functions suggest that Eigen implements a token with transfer restrictions, wrapping/unwrapping capabilities (likely for a related token named \"bEIGEN\"), and voting mechanisms through a checkpoint system. The contract follows a controlled access pattern where certain actions are restricted to specific addresses (likely the contract owner or designated roles).</p> <p>Based on the CLOCK_MODE and clock functions, Eigen also implements EIP-6372, which standardizes the way on-chain time is handled, specifically using timestamp-based voting mechanisms rather than block numbers.</p>"},{"location":"code/interfaces/IEigen/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/IEigen/#publicexternal-functions","title":"Public/External Functions","text":"<ol> <li>Transfer Restriction Management</li> <li><code>setAllowedFrom(address from, bool isAllowedFrom)</code>: Allows the owner to specify addresses that can transfer tokens from their accounts.</li> <li><code>setAllowedTo(address to, bool isAllowedTo)</code>: Allows the owner to specify addresses that can receive token transfers.</li> <li> <p><code>disableTransferRestrictions()</code>: Allows the owner to completely remove transfer restrictions from the token.</p> </li> <li> <p>Token Supply Management</p> </li> <li> <p><code>mint()</code>: Enables authorized minters to create new tokens, increasing the total supply.</p> </li> <li> <p>Token Wrapping</p> </li> <li><code>wrap(uint256 amount)</code>: Allows holders of bEIGEN tokens to convert them to Eigen tokens.</li> <li> <p><code>unwrap(uint256 amount)</code>: Allows Eigen token holders to convert them back to bEIGEN tokens.</p> </li> <li> <p>Checkpoint and Voting Mechanisms</p> </li> <li><code>clock()</code>: Returns the current timestamp, used for voting checkpoints.</li> <li> <p><code>CLOCK_MODE()</code>: Returns a string indicating the contract uses timestamps for its clock, complying with EIP-6372.</p> </li> <li> <p>Inherited ERC20 Functions (from IERC20)</p> </li> <li>Standard ERC20 functions like <code>transfer</code>, <code>approve</code>, <code>transferFrom</code>, <code>balanceOf</code>, and <code>allowance</code></li> </ol>"},{"location":"code/interfaces/IEigen/#key-events","title":"Key Events","text":"<p>While no events are explicitly defined in the interface, the implementation would typically include: - Events for successful wrapping/unwrapping operations - Events for changing allowance statuses - Events for enabling/disabling transfer restrictions - Standard ERC20 events like Transfer and Approval (inherited)</p>"},{"location":"code/interfaces/IEigen/#logic-flow","title":"Logic Flow","text":""},{"location":"code/interfaces/IEigen/#token-transfer-workflow","title":"Token Transfer Workflow","text":"<ol> <li>A user initiates a token transfer using ERC20's <code>transfer</code> or <code>transferFrom</code></li> <li>The contract checks if the sender is in the allowed \"from\" addresses list</li> <li>The contract checks if the recipient is in the allowed \"to\" addresses list</li> <li>If both checks pass (or if restrictions are disabled), the transfer proceeds</li> <li>If either check fails, the transfer is rejected</li> </ol>"},{"location":"code/interfaces/IEigen/#token-wrapping-workflow","title":"Token Wrapping Workflow","text":"<ol> <li>User approves the Eigen contract to spend their bEIGEN tokens</li> <li>User calls <code>wrap(amount)</code> with the desired amount</li> <li>The contract transfers bEIGEN tokens from the user to itself</li> <li>The contract mints an equivalent amount of Eigen tokens to the user</li> </ol>"},{"location":"code/interfaces/IEigen/#token-unwrapping-workflow","title":"Token Unwrapping Workflow","text":"<ol> <li>User calls <code>unwrap(amount)</code> with the desired amount</li> <li>The contract burns the specified amount of Eigen tokens from the user</li> <li>The contract transfers an equivalent amount of bEIGEN tokens to the user</li> </ol>"},{"location":"code/interfaces/IEigen/#voting-mechanism","title":"Voting Mechanism","text":"<ol> <li>Actions requiring governance votes use the <code>clock()</code> function to timestamp voting periods</li> <li>The contract creates checkpoints at specific timestamps</li> <li>Voting power is determined based on token balance at these checkpoints</li> <li>The <code>CLOCK_MODE()</code> function indicates timestamp-based voting to other contracts</li> </ol>"},{"location":"code/interfaces/IEigen/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[User] --&gt;|transfer| B{Transfer Restrictions}\n    B --&gt;|Sender Allowed?| C{Recipient Allowed?}\n    B --&gt;|Restrictions Disabled| E[Process Transfer]\n    C --&gt;|Yes| E\n    C --&gt;|No| F[Reject Transfer]\n\n    A --&gt;|wrap| G[Wrap bEIGEN to EIGEN]\n    G --&gt;|1. Take bEIGEN| H[Lock bEIGEN in Contract]\n    H --&gt;|2. Mint EIGEN| I[Send EIGEN to User]\n\n    A --&gt;|unwrap| J[Unwrap EIGEN to bEIGEN]\n    J --&gt;|1. Burn EIGEN| K[Reduce EIGEN Supply]\n    K --&gt;|2. Release bEIGEN| L[Send bEIGEN to User]\n\n    M[Owner] --&gt;|setAllowedFrom| N[Update Allowed Senders]\n    M --&gt;|setAllowedTo| O[Update Allowed Recipients]\n    M --&gt;|disableTransferRestrictions| P[Remove All Restrictions]\n\n    Q[Minter] --&gt;|mint| R[Increase EIGEN Supply]\n\n    S[Governance] --&gt;|read clock()| T[Get Current Timestamp]\n    S --&gt;|check CLOCK_MODE()| U[Confirm Timestamp-Based]</code></pre>"},{"location":"code/interfaces/IEigen/#dependencies-and-interactions","title":"Dependencies and Interactions","text":""},{"location":"code/interfaces/IEigen/#external-dependencies","title":"External Dependencies","text":"<ul> <li>OpenZeppelin's IERC20: The interface extends OpenZeppelin's standard IERC20 interface, inheriting all standard token functionalities.</li> <li>EIP-6372 Compliance: The implementation of <code>clock()</code> and <code>CLOCK_MODE()</code> indicates compliance with this EIP, which standardizes timestamp handling for on-chain voting.</li> </ul>"},{"location":"code/interfaces/IEigen/#related-contracts","title":"Related Contracts","text":"<ul> <li>bEIGEN Token: Based on the wrapping and unwrapping functions, this interface implies the existence of another token called bEIGEN, which likely has a 1:1 relationship with Eigen. bEIGEN might be a basic or bonded version of the EIGEN token.</li> <li>Access Control System: The functions that modify allowed addresses suggest the existence of an access control system, possibly using OpenZeppelin's Ownable pattern or a role-based system.</li> </ul>"},{"location":"code/interfaces/IEigen/#key-system-interactions","title":"Key System Interactions","text":"<ol> <li>Token Swapping Mechanism: The wrap/unwrap functions enable users to convert between two token types (EIGEN and bEIGEN).</li> <li>Governance Integration: The timestamp-based checkpointing suggests integration with a governance system where token holders can vote on proposals.</li> <li>Controlled Token Distribution: The transfer restrictions and minting capabilities indicate a controlled distribution model for the token.</li> </ol> <p>This interface combines standard ERC20 functionality with enhanced features for governance participation and controlled token distribution, making it suitable for a protocol that requires both economic incentives and decentralized governance.</p>"},{"location":"code/interfaces/IEigenPod/","title":"IEigenPod","text":""},{"location":"code/interfaces/IEigenPod/#contract-overview","title":"Contract Overview","text":"<p>IEigenPod is a key interface in the EigenLayer protocol that defines the functionality for restaking Ethereum beacon chain ETH. The contract serves as a personal vault for users who want to participate in EigenLayer's restaking ecosystem without unstaking their ETH from the beacon chain.</p> <p>The main purpose of this contract is to allow validators to \"restake\" their beacon chain ETH on EigenLayer, effectively putting the same ETH at risk for multiple networks. This process doesn't require physically moving ETH from the beacon chain but rather proving via cryptographic proofs that a user's validator has withdrawal credentials pointing to their EigenPod.</p> <p>This interface is part of a larger system where the EigenPodManager creates and manages individual EigenPods for users. The contract implements several design patterns including: - Proxy pattern (evidenced by the initialize method) - Role-based access control (owner vs proof submitter roles) - Cryptographic proof verification - Checkpointing mechanism for tracking validator balances</p>"},{"location":"code/interfaces/IEigenPod/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/IEigenPod/#key-state-variables","title":"Key State Variables","text":"<ul> <li><code>proofSubmitter</code>: An address delegated by the pod owner that can submit proofs on their behalf</li> <li><code>withdrawableRestakedExecutionLayerGwei</code>: Amount of ETH withdrawn from the beacon chain but still staked in EigenLayer</li> <li><code>eigenPodManager</code>: Reference to the EigenPodManager contract that manages all EigenPods</li> <li><code>podOwner</code>: The owner of this specific EigenPod</li> <li><code>validatorPubkeyHashToInfo</code>: Mapping that stores important information about each validator</li> <li><code>activeValidatorCount</code>: Number of validators with proven withdrawal credentials</li> <li><code>currentCheckpoint</code> and related variables: Track the ongoing checkpoint process</li> </ul>"},{"location":"code/interfaces/IEigenPod/#publicexternal-functions","title":"Public/External Functions","text":"<p>Initialization and Setup - <code>initialize(address owner)</code>: Sets up the EigenPod with an owner - <code>setProofSubmitter(address newProofSubmitter)</code>: Designates an address that can submit proofs on behalf of the owner</p> <p>Staking and Withdrawing - <code>stake(bytes pubkey, bytes signature, bytes32 depositDataRoot)</code>: Creates a new ETH validator through this EigenPod - <code>withdrawRestakedBeaconChainETH(address recipient, uint256 amount)</code>: Withdraws ETH that has been restaked - <code>recoverTokens(IERC20[] tokenList, uint256[] amountsToWithdraw, address recipient)</code>: Allows the owner to recover any ERC20 tokens sent to the pod</p> <p>Checkpoint Management - <code>startCheckpoint(bool revertIfNoBalance)</code>: Initiates a checkpoint to update validator balances - <code>verifyCheckpointProofs(...)</code>: Verifies proofs for validator balances in the current checkpoint</p> <p>Validator Management - <code>verifyWithdrawalCredentials(...)</code>: Proves that validators have their withdrawal credentials pointed to this EigenPod - <code>verifyStaleBalance(...)</code>: Proves that a validator has been slashed on the beacon chain</p>"},{"location":"code/interfaces/IEigenPod/#events","title":"Events","text":"<ul> <li><code>EigenPodStaked</code>: Emitted when a new validator is staked through this EigenPod</li> <li><code>ValidatorRestaked</code>: Emitted when a validator's withdrawal credentials are verified</li> <li><code>ValidatorBalanceUpdated</code>: Emitted when a validator's balance is updated</li> <li><code>RestakedBeaconChainETHWithdrawn</code>: Emitted when restaked ETH is withdrawn</li> <li><code>CheckpointCreated</code> and <code>CheckpointFinalized</code>: Track the checkpoint lifecycle</li> <li><code>ValidatorCheckpointed</code>: Emitted when a validator is successfully included in a checkpoint</li> <li><code>ValidatorWithdrawn</code>: Emitted when a validator is proven to have 0 balance</li> </ul>"},{"location":"code/interfaces/IEigenPod/#logic-flow","title":"Logic Flow","text":"<p>The EigenPod operates through several key workflow processes:</p>"},{"location":"code/interfaces/IEigenPod/#staking-and-restaking-process","title":"Staking and Restaking Process","text":"<ol> <li>A user first sets up an EigenPod through the EigenPodManager</li> <li>The user can then:</li> <li>Stake new validators directly through the EigenPod using <code>stake()</code></li> <li>\"Restake\" existing validators by proving their withdrawal credentials point to the EigenPod using <code>verifyWithdrawalCredentials()</code></li> </ol>"},{"location":"code/interfaces/IEigenPod/#checkpoint-management-process","title":"Checkpoint Management Process","text":"<p>Checkpoints are a crucial mechanism for tracking validator balances and rewarding pod owners:</p> <ol> <li>The pod owner (or proof submitter) initiates a checkpoint using <code>startCheckpoint()</code></li> <li>For each active validator, proofs are submitted via <code>verifyCheckpointProofs()</code></li> <li>Once all validators are proven, the checkpoint is finalized</li> <li>During finalization:</li> <li>The pod tracks the total change in validator balances</li> <li>Validators with 0 balance are marked as withdrawn</li> <li>The pod owner is awarded shares based on the balance changes and any unaccounted ETH</li> </ol>"},{"location":"code/interfaces/IEigenPod/#withdrawal-process","title":"Withdrawal Process","text":"<ol> <li>When a validator withdraws ETH from the beacon chain, it goes to their EigenPod</li> <li>The pod owner must complete a checkpoint to account for these withdrawals</li> <li>After successful checkpointing, the owner can call <code>withdrawRestakedBeaconChainETH()</code> to transfer the ETH</li> </ol>"},{"location":"code/interfaces/IEigenPod/#security-mechanisms","title":"Security Mechanisms","text":"<ul> <li>Role-based access: Different functions are restricted to the pod owner, EigenPodManager, or designated proof submitter</li> <li>Robust error handling: Comprehensive error messages for different failure scenarios</li> <li>Cryptographic proofs: All balance and validator status changes require cryptographic proofs from the beacon chain</li> <li>Slashing detection: Active validators can be proven to be slashed, triggering a checkpoint</li> </ul>"},{"location":"code/interfaces/IEigenPod/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    User[Pod Owner] --&gt; EigenPodManager\n    EigenPodManager --&gt; |creates| EigenPod\n    User --&gt; |stakes validators| EigenPod\n    User --&gt; |provides proofs| EigenPod\n    User --&gt; |withdraws ETH| EigenPod\n    ProofSubmitter[Proof Submitter] --&gt; |submits proofs| EigenPod\n\n    subgraph \"EigenPod Lifecycle\"\n        Init[Initialize Pod] --&gt; Stake[Stake/Restate Validators]\n        Stake --&gt; Verify[Verify Withdrawal Credentials]\n        Verify --&gt; Checkpoint[Create Checkpoint]\n        Checkpoint --&gt; VerifyProofs[Verify Checkpoint Proofs]\n        VerifyProofs --&gt; Finalize[Finalize Checkpoint]\n        Finalize --&gt; Withdraw[Withdraw ETH]\n        VerifyProofs --&gt; |if slashed| SlashDetect[Detect Slashing]\n    end\n\n    EigenPod --&gt; |emits events| Events[Contract Events]\n    BeaconChain[Beacon Chain] -.-&gt; |cryptographic proofs| EigenPod\n    EIP4788[EIP-4788 Oracle] -.-&gt; |block roots| EigenPod</code></pre>"},{"location":"code/interfaces/IEigenPod/#dependencies-and-interactions","title":"Dependencies and Interactions","text":""},{"location":"code/interfaces/IEigenPod/#external-dependencies","title":"External Dependencies","text":"<ol> <li>Beacon Chain: The contract relies heavily on the Ethereum beacon chain, using cryptographic proofs to verify:</li> <li>Validator withdrawal credentials</li> <li>Validator balances</li> <li> <p>Validator status (active, withdrawn, slashed)</p> </li> <li> <p>EIP-4788 Oracle: The contract uses the EIP-4788 beacon block roots oracle to verify the authenticity of beacon chain proofs:</p> </li> <li>The <code>getParentBlockRoot()</code> function queries this oracle to get beacon block roots</li> <li> <p>This allows the contract to verify that proofs are from legitimate beacon chain states</p> </li> <li> <p>OpenZeppelin Contracts: Imports the IERC20 interface for token recovery functionality</p> </li> </ol>"},{"location":"code/interfaces/IEigenPod/#system-interactions","title":"System Interactions","text":"<ol> <li>EigenPodManager: This contract is created and managed by the EigenPodManager, which:</li> <li>Initializes the EigenPod with an owner</li> <li>Acts as the entry point for certain operations</li> <li> <p>Maintains registry of all EigenPods in the system</p> </li> <li> <p>Beacon Deposit Contract: When staking new validators, this contract forwards ETH to the beacon chain deposit contract</p> </li> <li> <p>BeaconChainProofs Library: Contains the data structures and verification logic for all beacon chain proofs used by the contract</p> </li> <li> <p>IEigenPodTypes, IEigenPodEvents, IEigenPodErrors: These interfaces define the core data structures, events, and error messages used throughout the contract</p> </li> </ol> <p>The EigenPod represents a significant innovation in Ethereum's staking ecosystem, allowing beacon chain stakers to put their staked ETH to work in securing additional networks without needing to withdraw it from the beacon chain. The contract uses a sophisticated proof and checkpoint system to track validator balances and status, ensuring accurate accounting while maintaining security.</p>"},{"location":"code/interfaces/IEigenPodManager/","title":"IEigenPodManager","text":""},{"location":"code/interfaces/IEigenPodManager/#contract-overview","title":"Contract Overview","text":"<p>The <code>IEigenPodManager</code> interface defines a system for managing Ethereum validators that want to participate in EigenLayer, a protocol for restaking ETH. This contract is critical in the EigenLayer architecture as it allows ETH validators to create special pods (EigenPods) that point their withdrawal credentials to EigenLayer, enabling them to restake their staked ETH and receive additional rewards.</p> <p>The primary purpose of this contract is to create, track, and manage EigenPod instances, which are individual smart contracts that represent Ethereum validators participating in EigenLayer. It allows users to create pods, stake ETH to become validators, track balances, handle slashing events, and manage withdrawals.</p> <p>The contract uses a factory pattern to deploy EigenPods for users, a proxy pattern (via beacon proxies) for upgradability, and implements a sophisticated share accounting system to track restaked ETH. It also features safety mechanisms like pausability and slashing factor tracking.</p>"},{"location":"code/interfaces/IEigenPodManager/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/IEigenPodManager/#key-functions","title":"Key Functions","text":"<ul> <li> <p><code>createPod()</code>: Creates an EigenPod for the caller, allowing them to participate in EigenLayer with their validators.</p> </li> <li> <p><code>stake(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot)</code>: Stakes 32 ETH for a new beacon chain validator on the caller's EigenPod and creates a pod if they don't have one.</p> </li> <li> <p><code>recordBeaconChainETHBalanceUpdate(address podOwner, uint256 prevRestakedBalanceWei, int256 balanceDeltaWei)</code>: Updates the record of how much ETH a pod owner has staked, handling both increases and decreases in balance.</p> </li> <li> <p><code>getPod(address podOwner)</code>: Retrieves the EigenPod address for a given pod owner.</p> </li> <li> <p><code>hasPod(address podOwner)</code>: Checks if a given address has created an EigenPod.</p> </li> </ul>"},{"location":"code/interfaces/IEigenPodManager/#important-events","title":"Important Events","text":"<ul> <li> <p><code>PodDeployed</code>: Emitted when a new EigenPod is created for a user.</p> </li> <li> <p><code>BeaconChainETHDeposited</code>: Emitted when a deposit of beacon chain ETH is recorded in the strategy manager.</p> </li> <li> <p><code>PodSharesUpdated</code>: Emitted when an EigenPod's balance is updated.</p> </li> <li> <p><code>BeaconChainETHWithdrawalCompleted</code>: Emitted when a withdrawal of beacon chain ETH is completed.</p> </li> <li> <p><code>BeaconChainSlashingFactorDecreased</code>: Emitted when a staker's slashing factor is updated due to slashing events.</p> </li> </ul>"},{"location":"code/interfaces/IEigenPodManager/#key-state-variables","title":"Key State Variables","text":"<ul> <li> <p><code>ownerToPod</code>: Maps user addresses to their EigenPod contract addresses.</p> </li> <li> <p><code>podOwnerDepositShares</code>: Tracks the number of shares a pod owner has in the virtual beacon chain ETH strategy.</p> </li> <li> <p><code>beaconChainSlashingFactor</code>: Records the historical balance decreases a pod owner has experienced due to slashing.</p> </li> <li> <p><code>burnableETHShares</code>: Accumulated amount of ETH shares that can be burned (likely from slashing events).</p> </li> </ul>"},{"location":"code/interfaces/IEigenPodManager/#logic-flow","title":"Logic Flow","text":"<p>The main workflow in this contract follows these steps:</p> <ol> <li> <p>Pod Creation: A user calls <code>createPod()</code> to deploy their own EigenPod contract, which will serve as their interface to the EigenLayer system.</p> </li> <li> <p>Staking: Through the <code>stake()</code> function, users can deposit 32 ETH to become Ethereum validators, with withdrawal credentials pointed to their EigenPod.</p> </li> <li> <p>Balance Tracking: The EigenPod monitors the validator's beacon chain balance and reports changes through <code>recordBeaconChainETHBalanceUpdate()</code>.</p> </li> <li> <p>Share Accounting:</p> </li> <li>When balances increase, shares are added to the pod owner's account.</li> <li>When balances decrease (e.g., due to slashing), the system updates the slashing factor.</li> <li> <p>The system keeps track of shares using a sophisticated accounting mechanism that can handle both positive and negative balances.</p> </li> <li> <p>Withdrawals: When withdrawals occur, the contract emits the <code>BeaconChainETHWithdrawalCompleted</code> event and updates accounting accordingly.</p> </li> </ol> <p>The contract also maintains a \"slashing factor\" for each staker, which represents their historical experience with slashing on the beacon chain. This factor decreases when slashing occurs and affects the amount of shares they have delegated.</p> <p>An innovative aspect of the design is the handling of negative share balances. This accommodates scenarios where a pod owner's beacon chain ETH shares decrease between queuing and completing a withdrawal.</p>"},{"location":"code/interfaces/IEigenPodManager/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    U[User] --&gt;|createPod()| EPM[EigenPodManager]\n    EPM --&gt;|deploys| EP[EigenPod]\n    U --&gt;|stake()| EPM\n    EPM --&gt;|forwards stake request| EP\n    EP --&gt;|deposits| ETHPoS[ETH PoS Deposit Contract]\n    ETHPoS --&gt;|creates validator| BC[Beacon Chain]\n    BC --&gt;|balance updates| EP\n    EP --&gt;|recordBeaconChainETHBalanceUpdate()| EPM\n    EPM --&gt;|updates| Shares[Share Accounting]\n    EPM --&gt;|may update| SlashingFactor[Slashing Factor]\n    U --&gt;|withdrawal request| EP\n    EP --&gt;|completes withdrawal| EPM\n    EPM --&gt;|emits| WithdrawalEvent[BeaconChainETHWithdrawalCompleted]</code></pre>"},{"location":"code/interfaces/IEigenPodManager/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The <code>IEigenPodManager</code> interacts with several other contracts in the EigenLayer ecosystem:</p> <ol> <li> <p>IEigenPod: Individual pods created for users to interact with the Ethereum validator system.</p> </li> <li> <p>IETHPOSDeposit: The official Ethereum 2.0 deposit contract for becoming a validator.</p> </li> <li> <p>IStrategyManager: Likely manages the different strategies for restaking, including the virtual beacon chain ETH strategy.</p> </li> <li> <p>IBeacon: The OpenZeppelin beacon contract used for the proxy pattern, allowing for upgradability of the EigenPods.</p> </li> <li> <p>IShareManager: Interface for managing shares in the system.</p> </li> <li> <p>IStrategy: Interface for the virtual beacon chain ETH strategy that represents restaked ETH.</p> </li> </ol> <p>The contract also depends on OpenZeppelin's contracts for the proxy/beacon pattern and implements a semver interface for versioning, as well as a pausable interface for emergency control.</p> <p>The design shows careful consideration of the complexities involved in validator slashing and withdrawal processes. By tracking share balances that can go negative, the system can handle the asynchronous nature of the Ethereum beacon chain operations, ensuring that users cannot withdraw more than they are entitled to, even if slashing events occur during withdrawal processes.</p>"},{"location":"code/interfaces/IPausable/","title":"IPausable","text":""},{"location":"code/interfaces/IPausable/#1-contract-overview","title":"1. Contract Overview","text":""},{"location":"code/interfaces/IPausable/#purpose-and-main-functionality","title":"Purpose and Main Functionality","text":"<p>The <code>IPausable</code> interface defines a framework for implementing pausability in smart contracts within the EigenLayer ecosystem. This mechanism allows authorized entities to temporarily halt specific functionalities of a contract in emergency situations or when maintenance is required, providing an essential safety feature for complex blockchain systems.</p>"},{"location":"code/interfaces/IPausable/#system-architecture-context","title":"System Architecture Context","text":"<p>Within the EigenLayer system, <code>IPausable</code> serves as a foundational security interface that other contracts can implement to gain granular pause/unpause capabilities. It works in conjunction with the <code>PauserRegistry</code> contract, which manages the authorization logic for pause/unpause operations. This separation of concerns allows for a flexible security model where different entities can have different levels of control over pausing functionality.</p>"},{"location":"code/interfaces/IPausable/#key-design-patterns","title":"Key Design Patterns","text":"<ul> <li>Interface-based Design: Defines a standard interface for pausable contracts to implement</li> <li>Role-Based Access Control: Delegates authorization to dedicated pauser and unpauser roles</li> <li>Bit Flag Pattern: Uses a bitwise approach for granular control over pausing specific functionalities</li> <li>Event-driven Updates: Emits events to notify listeners of changes in pause status</li> </ul>"},{"location":"code/interfaces/IPausable/#2-contract-interface","title":"2. Contract Interface","text":""},{"location":"code/interfaces/IPausable/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li><code>pauserRegistry()</code>: Returns the address of the PauserRegistry contract this contract uses for access control</li> <li><code>pause(uint256 newPausedStatus)</code>: Allows the pauser to pause specific functionalities by setting bits in the paused status</li> <li><code>pauseAll()</code>: Convenience function to pause all functionalities at once</li> <li><code>unpause(uint256 newPausedStatus)</code>: Allows the unpauser to unpause specific functionalities</li> <li><code>paused()</code>: Returns the current paused status as a uint256</li> <li><code>paused(uint8 index)</code>: Checks if a specific functionality (identified by bit index) is paused</li> </ul>"},{"location":"code/interfaces/IPausable/#events","title":"Events","text":"<ul> <li><code>Paused(address indexed account, uint256 newPausedStatus)</code>: Emitted when a pause action occurs</li> <li><code>Unpaused(address indexed account, uint256 newPausedStatus)</code>: Emitted when an unpause action occurs</li> </ul>"},{"location":"code/interfaces/IPausable/#error-states","title":"Error States","text":"<ul> <li><code>OnlyPauser()</code>: Thrown when a non-pauser tries to pause functionality</li> <li><code>OnlyUnpauser()</code>: Thrown when a non-unpauser tries to unpause functionality</li> <li><code>CurrentlyPaused()</code>: Thrown when an action fails because the relevant functionality is paused</li> <li><code>InvalidNewPausedStatus()</code>: Thrown when an invalid pause status is provided</li> <li><code>InputAddressZero()</code>: Thrown when a zero address is provided where a valid address is required</li> </ul>"},{"location":"code/interfaces/IPausable/#3-logic-flow","title":"3. Logic Flow","text":"<p>The pause mechanism in this contract uses a bitwise approach to control different functionalities:</p> <ol> <li> <p>Initialization: A contract implementing this interface would initialize with the <code>PauserRegistry</code> address, which manages pause/unpause permissions.</p> </li> <li> <p>Pausing Process:</p> </li> <li>When critical issues are detected, the authorized pauser calls <code>pause()</code> with a bitwise representation of what to pause</li> <li>The implementation verifies caller is the pauser (through PauserRegistry)</li> <li>The new paused status can only add paused functions (turn bits from 0 to 1)</li> <li> <p>The contract updates its internal paused state and emits a <code>Paused</code> event</p> </li> <li> <p>Functionality Execution:</p> </li> <li>Before executing any pausable functionality, the contract checks if the relevant bit is set in the paused status</li> <li>If the bit is set (value is 1), the action is prevented with a <code>CurrentlyPaused</code> error</li> <li> <p>If the bit is not set (value is 0), the action proceeds normally</p> </li> <li> <p>Unpausing Process:</p> </li> <li>Once issues are resolved, the authorized unpauser calls <code>unpause()</code> with a bitwise representation of the desired state</li> <li>The implementation verifies caller is the unpauser (typically a higher authority than the pauser)</li> <li>The new unpaused status can only remove pauses (turn bits from 1 to 0)</li> <li>The contract updates its internal paused state and emits an <code>Unpaused</code> event</li> </ol>"},{"location":"code/interfaces/IPausable/#4-visual-representation","title":"4. Visual Representation","text":"<pre><code>flowchart TD\n    A[External Actor] --&gt;|calls function| B[Pausable Contract]\n    B --&gt;|checks| C{Is Function Paused?}\n    C --&gt;|Yes| D[Revert with CurrentlyPaused]\n    C --&gt;|No| E[Execute Function]\n\n    F[Pauser] --&gt;|calls| G[pause/pauseAll]\n    G --&gt;|verifies via| H[PauserRegistry]\n    H --&gt;|if authorized| I[Set Pause Bits]\n    I --&gt;|emit| J[Paused Event]\n\n    K[Unpauser] --&gt;|calls| L[unpause]\n    L --&gt;|verifies via| H\n    H --&gt;|if authorized| M[Clear Pause Bits]\n    M --&gt;|emit| N[Unpaused Event]</code></pre>"},{"location":"code/interfaces/IPausable/#5-dependencies-and-interactions","title":"5. Dependencies and Interactions","text":""},{"location":"code/interfaces/IPausable/#external-dependencies","title":"External Dependencies","text":"<ul> <li><code>IPauserRegistry.sol</code>: This interface defines the contract that manages authorization for pause/unpause actions. The pausable contract defers to this registry to determine if a caller has the right to pause or unpause functionality.</li> </ul>"},{"location":"code/interfaces/IPausable/#contract-interactions","title":"Contract Interactions","text":"<p>Contracts implementing the <code>IPausable</code> interface will:</p> <ol> <li>Store a reference to an <code>IPauserRegistry</code> contract that manages authorization</li> <li>Maintain an internal state variable (typically called <code>_paused</code>) that tracks which functionalities are paused</li> <li>Add checks in their functions to verify if the relevant functionality is paused</li> <li>Implement the pause/unpause functions with proper access controls</li> </ol>"},{"location":"code/interfaces/IPausable/#security-considerations","title":"Security Considerations","text":"<p>The design reflects a thoughtful security approach with:</p> <ol> <li>Tiered Authorization: Separating pauser (emergency response) and unpauser (more careful governance) roles</li> <li>Granular Control: Allowing specific functionality to be paused rather than an all-or-nothing approach</li> <li>Restricted Operations: Ensuring pause can only turn bits on, and unpause can only turn bits off</li> <li>Transparency: Emitting events for all state changes to facilitate monitoring</li> </ol> <p>This architecture is particularly valuable for EigenLayer, as it allows for quick response to vulnerabilities while maintaining a high bar for resuming normal operations, which is critical for a protocol handling significant financial assets.</p>"},{"location":"code/interfaces/IPauserRegistry/","title":"IPauserRegistry","text":""},{"location":"code/interfaces/IPauserRegistry/#contract-overview","title":"Contract Overview","text":"<p>IPauserRegistry is an interface that defines the structure for a registry contract that manages pause functionality within a system. In blockchain applications, especially DeFi and other financial services, the ability to pause certain functions during emergencies is a critical safety feature. This interface establishes the blueprint for a contract that controls which addresses have the authority to pause the system and which singular address has the ability to unpause it.</p> <p>This contract fits into the broader system architecture as a security mechanism that likely interacts with other contracts that implement pausable functionality. Based on its design, it appears to be part of a system with privileged roles where certain entities have special permissions to protect the protocol in emergency situations.</p> <p>The key design pattern used is the role-based access control pattern, specifically implementing a two-tier authority structure with: 1. Multiple pausers who can trigger emergency stops 2. A single unpauser who has higher authority to both manage pausers and restore system operations</p>"},{"location":"code/interfaces/IPauserRegistry/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/IPauserRegistry/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li> <p>isPauser(address pauser): A view function that returns a boolean indicating whether a specified address has the ability to pause the system. This would be called whenever the system needs to verify if an address has pauser privileges.</p> </li> <li> <p>unpauser(): A view function that returns the address of the current unpauser. This single address has the highest level of authority in this security system.</p> </li> </ul>"},{"location":"code/interfaces/IPauserRegistry/#important-events","title":"Important Events","text":"<ul> <li>PauserStatusChanged: Emitted when an address is granted or revoked pauser privileges. It includes two parameters:</li> <li><code>pauser</code>: The address whose status is being changed</li> <li> <p><code>canPause</code>: Boolean indicating whether the address now has pausing rights</p> </li> <li> <p>UnpauserChanged: Emitted when the unpauser role is transferred from one address to another. It includes:</p> </li> <li><code>previousUnpauser</code>: The address that previously held the unpauser role</li> <li><code>newUnpauser</code>: The address that now holds the unpauser role</li> </ul>"},{"location":"code/interfaces/IPauserRegistry/#key-state-variables","title":"Key State Variables","text":"<p>While the interface doesn't define the implementation of state variables, it implies the existence of:</p> <ul> <li>A mapping that tracks which addresses have pauser privileges</li> <li>A variable that stores the address of the unpauser</li> </ul>"},{"location":"code/interfaces/IPauserRegistry/#custom-errors","title":"Custom Errors","text":"<ul> <li>OnlyUnpauser: Thrown when a function restricted to the unpauser is called by another address</li> <li>InputAddressZero: Thrown when an operation involving an address receives the zero address as input, preventing potential security issues</li> </ul>"},{"location":"code/interfaces/IPauserRegistry/#logic-flow","title":"Logic Flow","text":"<p>The intended logic flow for this contract would be:</p> <ol> <li>The contract is initialized with a designated unpauser address.</li> <li>The unpauser can grant or revoke pauser status for any address.</li> <li>Addresses with pauser status can trigger pause functionality in connected contracts.</li> <li>Only the unpauser can unpause the system after it's been paused.</li> <li>The unpauser can transfer their role to another address if needed.</li> </ol> <p>Security is maintained through the clear separation of responsibilities - multiple entities can pause in an emergency, but only a single trusted entity can unpause or modify the registry itself.</p>"},{"location":"code/interfaces/IPauserRegistry/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Unpauser] --&gt;|Manages| B[Pauser Registry]\n    A --&gt;|Can modify| C[Pauser Addresses]\n    A --&gt;|Can change| D[Unpauser Address]\n    B --&gt;|Provides access control for| E[Pausable Contracts]\n    C --&gt;|Can pause| E\n    E --&gt;|Checks permissions with| B</code></pre>"},{"location":"code/interfaces/IPauserRegistry/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>While the interface itself doesn't have direct dependencies, the implementing contract would interact with:</p> <ol> <li> <p>Pausable Contracts: Any contract with pausable functionality would query the IPauserRegistry to determine if a caller has pause privileges.</p> </li> <li> <p>Access Control System: This interface likely works alongside a broader access control system within the protocol.</p> </li> <li> <p>Governance Mechanisms: The unpauser role might be controlled by or integrated with the protocol's governance system, particularly for decentralized protocols.</p> </li> </ol> <p>The clean separation between pauser and unpauser roles reflects a security-focused design choice. By allowing multiple pausers, the system ensures that emergency stops can be triggered quickly by various authorized entities when needed. By restricting unpause functionality to a single address, the system ensures that careful consideration must go into the decision to resume operations after an emergency pause.</p> <p>This two-tier design balances the need for quick response in emergencies (multiple pausers) with the need for careful deliberation when resuming normal operations (single unpauser).</p>"},{"location":"code/interfaces/IPermissionController/","title":"IPermissionController","text":""},{"location":"code/interfaces/IPermissionController/#contract-overview","title":"Contract Overview","text":"<p>The <code>IPermissionController</code> is a smart contract interface that defines a robust permission management system for blockchain accounts. Its primary purpose is to provide a flexible, multi-layered authorization framework that enables accounts to delegate specific permissions to other addresses, allowing for sophisticated access control patterns.</p> <p>This interface sits at the foundation of a permissions infrastructure, enabling accounts (which could be individual users, multi-signature wallets, or other smart contracts) to:</p> <ol> <li>Designate multiple admin addresses that have full control over the account's permissions</li> <li>Appoint specific addresses to execute particular functions on specific contracts</li> <li>Manage the lifecycle of these permission relationships</li> </ol> <p>The design follows the principle of least privilege, allowing precise control over which addresses can call which functions, rather than granting blanket permissions. It implements a two-step admin assignment pattern (pending admin \u2192 accepted admin) for security, ensuring that admin privileges can't be assigned to addresses without their explicit consent.</p>"},{"location":"code/interfaces/IPermissionController/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/IPermissionController/#publicexternal-functions","title":"Public/External Functions","text":""},{"location":"code/interfaces/IPermissionController/#admin-management","title":"Admin Management","text":"<ul> <li><code>addPendingAdmin(address account, address admin)</code>: Initiates the admin assignment process by setting an address as a pending admin</li> <li><code>removePendingAdmin(address account, address admin)</code>: Cancels a pending admin assignment before it's accepted</li> <li><code>acceptAdmin(address account)</code>: Allows a pending admin to accept their role, finalizing the admin assignment</li> <li><code>removeAdmin(address account, address admin)</code>: Removes an active admin's permissions</li> </ul>"},{"location":"code/interfaces/IPermissionController/#appointee-management","title":"Appointee Management","text":"<ul> <li><code>setAppointee(address account, address appointee, address target, bytes4 selector)</code>: Grants permission to an appointee to call a specific function on a specific contract</li> <li><code>removeAppointee(address account, address appointee, address target, bytes4 selector)</code>: Revokes a previously granted permission</li> </ul>"},{"location":"code/interfaces/IPermissionController/#permission-checks-and-views","title":"Permission Checks and Views","text":"<ul> <li><code>isAdmin(address account, address caller)</code>: Determines if an address is an admin for the account</li> <li><code>isPendingAdmin(address account, address pendingAdmin)</code>: Checks if an address is a pending admin</li> <li><code>canCall(address account, address caller, address target, bytes4 selector)</code>: Core permission check that determines if a caller can execute a specific function</li> <li><code>getAdmins(address account)</code>: Returns all active admins for an account</li> <li><code>getPendingAdmins(address account)</code>: Returns all pending admins for an account</li> <li><code>getAppointeePermissions(address account, address appointee)</code>: Lists all permissions granted to a specific appointee</li> <li><code>getAppointees(address account, address target, bytes4 selector)</code>: Retrieves all appointees for a specific function</li> </ul>"},{"location":"code/interfaces/IPermissionController/#important-events","title":"Important Events","text":"<ul> <li><code>AppointeeSet</code>: Triggered when a permission is granted to an appointee</li> <li><code>AppointeeRemoved</code>: Emitted when an appointee's permission is revoked</li> <li><code>PendingAdminAdded</code>: Fired when an address is designated as a pending admin</li> <li><code>PendingAdminRemoved</code>: Logged when a pending admin assignment is cancelled</li> <li><code>AdminSet</code>: Emitted when a pending admin accepts their role</li> <li><code>AdminRemoved</code>: Triggered when an admin is removed</li> </ul>"},{"location":"code/interfaces/IPermissionController/#key-errors","title":"Key Errors","text":"<p>The interface defines several custom errors for common failure scenarios: - <code>NotAdmin</code>: When a non-admin attempts to perform an admin-only action - <code>AdminNotSet</code>, <code>AdminAlreadySet</code>, <code>AdminNotPending</code>, <code>AdminAlreadyPending</code>: Various admin state validation errors - <code>AppointeeAlreadySet</code>, <code>AppointeeNotSet</code>: Validation errors for appointee operations - <code>CannotHaveZeroAdmins</code>: Prevents removing the last admin, ensuring accounts always have at least one admin</p>"},{"location":"code/interfaces/IPermissionController/#logic-flow","title":"Logic Flow","text":"<p>The permission management system operates through several key workflows:</p>"},{"location":"code/interfaces/IPermissionController/#admin-assignment-flow","title":"Admin Assignment Flow","text":"<ol> <li>An existing admin calls <code>addPendingAdmin</code> to initiate the admin assignment process</li> <li>The system records the pending status and emits a <code>PendingAdminAdded</code> event</li> <li>The designated address must actively call <code>acceptAdmin</code> to assume the role</li> <li>Upon acceptance, the system records them as an active admin and emits an <code>AdminSet</code> event</li> <li>An admin can be removed via <code>removeAdmin</code> (provided they're not the last admin)</li> </ol>"},{"location":"code/interfaces/IPermissionController/#permission-delegation-flow","title":"Permission Delegation Flow","text":"<ol> <li>An admin calls <code>setAppointee</code> to grant specific function-calling permissions</li> <li>The system records the permission and emits an <code>AppointeeSet</code> event</li> <li>The appointee can now call the specified function, which will be approved during permission checks</li> <li>Permissions can be revoked via <code>removeAppointee</code>, emitting an <code>AppointeeRemoved</code> event</li> </ol>"},{"location":"code/interfaces/IPermissionController/#permission-verification-flow","title":"Permission Verification Flow","text":"<p>When a function protected by this permission system is called: 1. The system calls <code>canCall</code> with the account, caller, target contract, and function selector 2. <code>canCall</code> checks if the caller is either:    - An admin of the account, which grants universal access, or    - An appointee specifically designated for that function on that contract 3. If either condition is true, the call is permitted; otherwise, it's rejected</p>"},{"location":"code/interfaces/IPermissionController/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Account Owner] --&gt;|Initial Setup| B[Add Pending Admin]\n    B --&gt;|Emits| C[PendingAdminAdded]\n    C --&gt;|Accepts| D[Accept Admin]\n    D --&gt;|Emits| E[AdminSet]\n\n    E --&gt;|Manages Permissions| F[Set Appointee]\n    F --&gt;|Emits| G[AppointeeSet]\n\n    E --&gt;|Manages Permissions| H[Remove Appointee]\n    H --&gt;|Emits| I[AppointeeRemoved]\n\n    E --&gt;|Manages Admins| J[Remove Admin]\n    J --&gt;|Emits| K[AdminRemoved]\n\n    E --&gt;|Manages Admins| L[Add Pending Admin]\n    L --&gt;|Emits| M[PendingAdminAdded]\n\n    E --&gt;|Manages Admins| N[Remove Pending Admin]\n    N --&gt;|Emits| O[PendingAdminRemoved]\n\n    P[Protected Function] --&gt;|Permission Check| Q{Can Call?}\n    Q --&gt;|Is Admin?| R[Allow]\n    Q --&gt;|Is Appointee?| R\n    Q --&gt;|Neither| S[Revert]</code></pre>"},{"location":"code/interfaces/IPermissionController/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p><code>IPermissionController</code> inherits from:</p> <ol> <li><code>IPermissionControllerErrors</code>: Defines the custom error types for permission-related operations</li> <li><code>IPermissionControllerEvents</code>: Defines the events emitted by the permission controller</li> <li><code>ISemVerMixin</code>: Suggests this contract follows semantic versioning for upgrades, helping track compatibility between versions</li> </ol> <p>This interface is likely implemented by a concrete <code>PermissionController</code> contract that manages the actual permission data structures. Other contracts in the system would consult this controller when access control decisions need to be made.</p> <p>The design allows for flexible integration with various other systems:</p> <ul> <li>External contracts can verify permissions by calling <code>canCall</code></li> <li>Accounts can be individual users, multisigs, or even other smart contracts</li> <li>The system can accommodate complex organizational structures with multiple layers of delegation</li> </ul> <p>This permission controller provides a foundation for implementing sophisticated access control patterns in Web3 applications, particularly those requiring fine-grained permission management beyond simple owner-based controls.</p>"},{"location":"code/interfaces/IRewardsCoordinator/","title":"IRewardsCoordinator","text":""},{"location":"code/interfaces/IRewardsCoordinator/#contract-overview","title":"Contract Overview","text":"<p>The <code>IRewardsCoordinator</code> interface defines a sophisticated rewards distribution system for Eigen Layer's Web3 middleware platform. This contract serves as the central hub for managing and distributing rewards across various participants in the ecosystem, including Active Validator Services (AVSs), operators, and stakers who delegate to operators.</p> <p>The primary purpose of this contract is to enable controlled, verifiable, and efficient reward distributions through a system of submissions, calculations, and merkle-based claims. It allows different reward sources (AVSs, platform-wide incentives, operator-directed rewards) to flow through a unified framework while maintaining fairness and transparency.</p> <p>Within the broader architecture, the RewardsCoordinator interfaces with core EigenLayer components like DelegationManager, StrategyManager, and AllocationManager to retrieve accurate staking and delegation data for calculations. It implements a delayed rewards calculation and claiming system using merkle trees, which allows for scalable verification of rewards without excessive on-chain computation.</p> <p>Key design patterns used include: - Merkle tree-based distribution and claiming - Role-based access control for different submission types - Cumulative record-keeping to minimize the need for historical claims - Flexible operator/staker split ratios for customizing reward distributions - Time-window based reward submissions and calculations</p>"},{"location":"code/interfaces/IRewardsCoordinator/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/IRewardsCoordinator/#core-functions","title":"Core Functions","text":"<p>Rewards Submission Functions: - <code>createAVSRewardsSubmission</code>: Allows AVSs to create rewards submissions for their operators and delegators - <code>createRewardsForAllSubmission</code>: Creates rewards for all stakers (permissioned) - <code>createRewardsForAllEarners</code>: Creates rewards for all operators and their delegated stakers (permissioned) - <code>createOperatorDirectedAVSRewardsSubmission</code>: Creates operator-specific rewards from an AVS - <code>createOperatorDirectedOperatorSetRewardsSubmission</code>: Creates operator-specific rewards for a specific operator set</p> <p>Root Management Functions: - <code>submitRoot</code>: Submits a new distribution root (calculation result) for future claims - <code>disableRoot</code>: Allows disabling an incorrect root before it becomes active</p> <p>Claiming Functions: - <code>processClaim</code>: Claims rewards against a specified distribution root - <code>processClaims</code>: Batch claims rewards against a specified distribution root</p> <p>Configuration Functions: - <code>setClaimerFor</code>: Sets an address allowed to claim on behalf of an earner - <code>setActivationDelay</code>: Sets the delay period before a root becomes active - <code>setDefaultOperatorSplit</code>: Sets the default operator/staker split ratio - <code>setOperatorAVSSplit</code>, <code>setOperatorPISplit</code>, <code>setOperatorSetSplit</code>: Sets specific operator split ratios - <code>setRewardsUpdater</code>, <code>setRewardsForAllSubmitter</code>: Sets permissioned roles</p>"},{"location":"code/interfaces/IRewardsCoordinator/#key-events","title":"Key Events","text":"<ul> <li><code>AVSRewardsSubmissionCreated</code>, <code>RewardsSubmissionForAllCreated</code>, etc.: Emitted when new reward submissions are created</li> <li><code>DistributionRootSubmitted</code>: Emitted when a new distribution root is submitted</li> <li><code>RewardsClaimed</code>: Emitted when rewards are successfully claimed</li> <li>Various configuration events for transparency</li> </ul>"},{"location":"code/interfaces/IRewardsCoordinator/#important-state-variables","title":"Important State Variables","text":"<ul> <li><code>activationDelay</code>: Delay period before a submitted root can be claimed against</li> <li><code>currRewardsCalculationEndTimestamp</code>: Timestamp until which rewards have been calculated</li> <li><code>defaultOperatorSplitBips</code>: Default ratio for operator/staker reward splitting</li> <li><code>rewardsUpdater</code>: Address allowed to submit distribution roots</li> <li>Operator-specific split ratios for different contexts (AVS, PI, OperatorSet)</li> <li><code>_distributionRoots</code>: Array of all historical distribution roots</li> </ul>"},{"location":"code/interfaces/IRewardsCoordinator/#logic-flow","title":"Logic Flow","text":""},{"location":"code/interfaces/IRewardsCoordinator/#rewards-submission-process","title":"Rewards Submission Process:","text":"<ol> <li>An AVS or authorized entity creates a reward submission by calling one of the submission functions</li> <li>The submission specifies token, amount, strategies/weights, and time window</li> <li>Tokens are transferred to the RewardsCoordinator contract</li> <li>The submission is recorded and emitted via an event</li> <li>The submission is later processed off-chain by the rewards updater to calculate individual distributions</li> </ol>"},{"location":"code/interfaces/IRewardsCoordinator/#rewards-calculation-and-root-submission","title":"Rewards Calculation and Root Submission:","text":"<ol> <li>Off-chain service calculates individual rewards based on submitted rewards and staking data</li> <li>Calculations are organized into a merkle tree with rewards per earner and token</li> <li>The root of this merkle tree is submitted on-chain via <code>submitRoot</code></li> <li>After the <code>activationDelay</code> period, the root becomes active for claims</li> </ol>"},{"location":"code/interfaces/IRewardsCoordinator/#claiming-process","title":"Claiming Process:","text":"<ol> <li>An earner (or their authorized claimer) calls <code>processClaim</code> with proof of their rewards</li> <li>The claim includes the merkle proof verifying their earnings against the active root</li> <li>The contract validates the proof and calculates unclaimed rewards (cumulativeEarnings - cumulativeClaimed)</li> <li>Verified tokens are transferred to the recipient</li> <li>The claimed amount is recorded to prevent double-claiming</li> </ol>"},{"location":"code/interfaces/IRewardsCoordinator/#split-ratio-mechanism","title":"Split Ratio Mechanism:","text":"<ol> <li>Operators can set custom split ratios for different reward sources</li> <li>When split ratios are set, they become active after an activation delay</li> <li>These ratios determine what percentage of rewards go to the operator vs. delegated stakers</li> <li>Different scenarios (AVS-specific, Programmatic Incentives, OperatorSet) can have different split ratios</li> </ol>"},{"location":"code/interfaces/IRewardsCoordinator/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[AVS/Authorized Entity] --&gt;|Submit Rewards| B[RewardsCoordinator]\n    B --&gt;|Emit Event| C[Off-chain Calculation Service]\n    C --&gt;|Calculate Distribution| D[Generate Merkle Tree]\n    D --&gt;|Root| E[RewardsUpdater]\n    E --&gt;|submitRoot| B\n\n    F[Earner/Claimer] --&gt;|processClaim| B\n    B --&gt;|Verify Proof| G{Valid?}\n    G --&gt;|Yes| H[Transfer Tokens]\n    G --&gt;|No| I[Revert]\n\n    J[Operator] --&gt;|Set Split Ratio| B\n\n    B --&gt;|Delayed Activation| K[Active Root]\n    K --&gt;|Used for| F</code></pre>"},{"location":"code/interfaces/IRewardsCoordinator/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The RewardsCoordinator interacts with several key components:</p> <ol> <li>DelegationManager: Provides information about operator-staker delegation relationships</li> <li>StrategyManager: Used to check staking amounts and strategies</li> <li>AllocationManager: Verifies AVS registrations and operator sets</li> <li>PermissionController: Handles access control for various functions</li> <li>ERC20 Tokens: Used for reward distributions</li> </ol> <p>External dependencies include: - Off-chain Reward Calculator: Processes reward submissions and calculates individual distributions - RewardsUpdater: Authorized entity that submits distribution roots - Active Validator Services (AVSs): Create reward submissions for their operators - Operators and Stakers: End recipients of rewards</p> <p>The contract also depends on a merkle tree generation and verification system for efficient proof-based claiming.</p> <p>The interface is designed to be flexible and extensible, allowing for different reward distribution models while maintaining security and verifiability throughout the process.</p>"},{"location":"code/interfaces/ISemVerMixin/","title":"ISemVerMixin","text":""},{"location":"code/interfaces/ISemVerMixin/#contract-overview","title":"Contract Overview","text":"<p>ISemVerMixin is a lightweight interface that defines a standardized way for smart contracts to report their version information. This simple yet powerful construct enables version transparency across the ecosystem, which is crucial for compatibility checking, upgrade management, and audit trails.</p> <p>The interface follows the Semantic Versioning 2.0.0 specification (SemVer), a widely adopted versioning standard in software development. By implementing this interface, contracts can communicate their version in a consistent and universally understood format.</p> <p>This contract uses the interface design pattern to define a standard that other contracts can implement, ensuring a consistent approach to versioning across the system. It's likely part of a broader governance or system management framework where tracking component versions is essential for risk management and system evolution.</p>"},{"location":"code/interfaces/ISemVerMixin/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/ISemVerMixin/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li><code>version()</code> - An external view function that returns the semantic version of the contract as a string. This function doesn't modify any state and doesn't cost gas when called from outside a transaction.</li> </ul>"},{"location":"code/interfaces/ISemVerMixin/#key-design-elements","title":"Key Design Elements","text":"<p>While the interface itself is minimal, its simplicity is intentional. It defines just enough functionality to ensure that any implementing contract can provide its version information in a standardized way.</p>"},{"location":"code/interfaces/ISemVerMixin/#logic-flow","title":"Logic Flow","text":"<p>The workflow for the ISemVerMixin interface is straightforward:</p> <ol> <li>A contract implements the ISemVerMixin interface</li> <li>The implementing contract provides its own implementation of the <code>version()</code> function</li> <li>Users or other contracts can call the <code>version()</code> function to retrieve version information</li> <li>This version information can be used for compatibility checks, upgrade decisions, or audit purposes</li> </ol>"},{"location":"code/interfaces/ISemVerMixin/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Client/User] --&gt;|Calls version()| B[Contract implementing ISemVerMixin]\n    B --&gt;|Returns| C[\"Version string (e.g., 'v1.1.1')\"]\n\n    D[External Contract] --&gt;|Calls version()| B\n    D --&gt;|Uses version for compatibility check| E[Execute further actions]\n\n    F[System Registry] --&gt;|Queries version| B\n    F --&gt;|Records version| G[Version Registry]</code></pre>"},{"location":"code/interfaces/ISemVerMixin/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>ISemVerMixin is designed to be implemented by other contracts that need to expose their version information. It doesn't depend on external contracts itself, making it a zero-dependency interface.</p> <p>When a contract implements this interface:</p> <ol> <li>Governance Systems may use the version information to track deployed contract versions, manage upgrades, and maintain system compatibility</li> <li>Client Applications can check contract versions to ensure compatibility with their expected functionality</li> <li>Auditing Tools might use version information to identify which version of a contract was deployed at a given time</li> <li>Package Managers or deployment systems could verify that the correct versions are being used</li> </ol> <p>The ISemVerMixin interface is especially valuable in upgradeable contract systems or complex protocol ecosystems where managing the versions of multiple interacting contracts becomes critical for system stability and security.</p> <p>By following the SemVer specification, contracts implementing this interface indicate: - MAJOR version changes when making incompatible API changes - MINOR version changes when adding functionality in a backward compatible manner - PATCH version changes when making backward compatible bug fixes</p> <p>This structured versioning approach helps developers and users understand the nature of changes between different versions of a contract, reducing integration risks and improving system transparency.</p>"},{"location":"code/interfaces/IShareManager/","title":"IShareManager","text":""},{"location":"code/interfaces/IShareManager/#1-contract-overview","title":"1. Contract Overview","text":""},{"location":"code/interfaces/IShareManager/#purpose-and-main-functionality","title":"Purpose and Main Functionality","text":"<p><code>IShareManager</code> is an interface contract that defines a standardized way to manage shares within the EigenLayer protocol. It serves as an abstraction layer that enables the DelegationManager contract to interact with different types of staking mechanisms (such as the StrategyManager and EigenPodManager) through a unified interface.</p>"},{"location":"code/interfaces/IShareManager/#system-architecture-placement","title":"System Architecture Placement","text":"<p>In the broader EigenLayer system, the <code>IShareManager</code> sits between the DelegationManager and the different share management implementations (like the StrategyManager for liquid staking tokens and the EigenPodManager for native ETH staking). This interface allows the DelegationManager to handle the movement of shares between stakers and operators without needing to know the specifics of how each type of underlying asset is managed.</p>"},{"location":"code/interfaces/IShareManager/#key-design-patterns","title":"Key Design Patterns","text":"<ul> <li>Interface Segregation: The contract isolates share management responsibilities into a dedicated interface.</li> <li>Facade Pattern: Provides a simplified interface to a complex subsystem of share accounting.</li> <li>Abstraction: Allows the DelegationManager to interact with different types of staking mechanisms without knowing their implementation details.</li> </ul>"},{"location":"code/interfaces/IShareManager/#2-contract-interface","title":"2. Contract Interface","text":""},{"location":"code/interfaces/IShareManager/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li><code>removeDepositShares</code>: Removes a specified amount of shares from a staker's position in a specific strategy, typically when queuing a withdrawal.</li> <li><code>addShares</code>: Awards shares to a staker, typically after a withdrawal has been processed and is ready to be returned to the staker.</li> <li><code>withdrawSharesAsTokens</code>: Converts a staker's shares into the underlying token and transfers them directly to the staker.</li> <li><code>stakerDepositShares</code>: A view function to check how many shares a staker has in a particular strategy.</li> <li><code>increaseBurnableShares</code>: Increases the amount of shares that should be burned for a specific strategy, used during slashing events.</li> </ul>"},{"location":"code/interfaces/IShareManager/#events","title":"Events","text":"<p>The interface does not define any events, but implementing contracts would typically emit events for the state changes described in these functions.</p>"},{"location":"code/interfaces/IShareManager/#key-state-variables","title":"Key State Variables","text":"<p>As an interface, <code>IShareManager</code> doesn't define state variables, but it implies the existence of: - A mapping that tracks stakers' deposit shares in various strategies - A mechanism to track burnable shares for slashing</p>"},{"location":"code/interfaces/IShareManager/#3-logic-flow","title":"3. Logic Flow","text":""},{"location":"code/interfaces/IShareManager/#share-management-workflow","title":"Share Management Workflow","text":"<ol> <li>Deposit: Not directly handled by this interface but precedes the workflows defined here.</li> <li>Queuing Withdrawal:</li> <li>DelegationManager calls <code>removeDepositShares</code> to decrement a staker's shares.</li> <li>The shares are placed in a withdrawal queue (in a different contract).</li> <li> <p>The function returns the updated number of shares after the removal.</p> </li> <li> <p>Completing Withdrawal:</p> </li> <li>When a withdrawal is ready to be fulfilled, <code>withdrawSharesAsTokens</code> converts shares to tokens and sends them to the staker.</li> <li> <p>For beacon chain ETH, the token parameter is ignored as it deals with native ETH.</p> </li> <li> <p>Share Addition:</p> </li> <li>In some cases, shares may be added back to a staker through <code>addShares</code>.</li> <li> <p>The function returns both the existing shares before addition and the amount of new shares added.</p> </li> <li> <p>Slashing Process:</p> </li> <li>When an operator is slashed, <code>increaseBurnableShares</code> marks shares to be burned.</li> <li>This function would be called by the DelegationManager during a slashing event.</li> </ol>"},{"location":"code/interfaces/IShareManager/#security-mechanisms","title":"Security Mechanisms","text":"<ul> <li>The interface specifies that only authorized contracts (like DelegationManager) should be able to call state-changing functions.</li> <li>The implementation would include access control to prevent unauthorized shares manipulation.</li> <li>Special handling is required for beaconChainETH, as noted in several function comments.</li> </ul>"},{"location":"code/interfaces/IShareManager/#4-visual-representation","title":"4. Visual Representation","text":"<pre><code>sequenceDiagram\n    participant DelegationManager\n    participant ShareManager as IShareManager Implementation\n    participant Strategy\n    participant EigenPodManager\n\n    Note over DelegationManager,EigenPodManager: Normal Operation\n    DelegationManager-&gt;&gt;ShareManager: stakerDepositShares(staker, strategy)\n    ShareManager-&gt;&gt;DelegationManager: depositShares\n\n    Note over DelegationManager,EigenPodManager: Withdrawal Process\n    DelegationManager-&gt;&gt;ShareManager: removeDepositShares(staker, strategy, amount)\n    ShareManager-&gt;&gt;Strategy: userShares updated\n    ShareManager-&gt;&gt;DelegationManager: updatedShares\n\n    Note over DelegationManager,EigenPodManager: Withdrawal Completion\n    DelegationManager-&gt;&gt;ShareManager: withdrawSharesAsTokens(staker, strategy, token, shares)\n    ShareManager-&gt;&gt;Strategy: convertToAssets(shares)\n    Strategy-&gt;&gt;ShareManager: assets\n    ShareManager-&gt;&gt;staker: assets transferred\n\n    Note over DelegationManager,EigenPodManager: Slashing Event\n    DelegationManager-&gt;&gt;ShareManager: increaseBurnableShares(strategy, amount)\n    ShareManager-&gt;&gt;Strategy: Shares marked for burning</code></pre>"},{"location":"code/interfaces/IShareManager/#5-dependencies-and-interactions","title":"5. Dependencies and Interactions","text":""},{"location":"code/interfaces/IShareManager/#contract-dependencies","title":"Contract Dependencies","text":"<ul> <li>SlashingLib: The interface imports the SlashingLib, which provides utilities for handling slashing calculations.</li> <li>IStrategy: Used to interact with the strategy contracts that manage the actual assets and share calculations.</li> <li>IERC20: Used for token interactions when converting shares to tokens.</li> </ul>"},{"location":"code/interfaces/IShareManager/#external-interactions","title":"External Interactions","text":"<ul> <li>DelegationManager: The main contract that calls this interface to manage stakers' shares based on delegation and withdrawal actions.</li> <li>StrategyManager: An implementation of this interface that manages shares for liquid staking tokens.</li> <li>EigenPodManager: An implementation that manages native ETH staking on the beacon chain.</li> </ul>"},{"location":"code/interfaces/IShareManager/#special-considerations","title":"Special Considerations","text":"<ul> <li>When interacting with the EigenPodManager, the strategy must be set to beaconChainETH.</li> <li>For beacon chain ETH withdrawals, the token parameter in <code>withdrawSharesAsTokens</code> is not validated as it deals with native ETH.</li> <li>The interface is designed with slashing in mind, allowing for the burning of shares when operators are slashed for malicious behavior.</li> </ul> <p>This interface plays a critical role in EigenLayer by providing a standardized way to manage shares across different types of staked assets, enabling the delegation system to operate consistently regardless of the underlying staking mechanism.</p>"},{"location":"code/interfaces/ISignatureUtilsMixin/","title":"ISignatureUtilsMixin","text":""},{"location":"code/interfaces/ISignatureUtilsMixin/#contract-overview","title":"Contract Overview","text":"<p><code>ISignatureUtilsMixin</code> is an interface that defines a standardized way of handling digital signatures within smart contracts in the EigenLayer ecosystem. This interface provides a foundation for signature validation, verification, and management that can be implemented by various contracts in the system.</p> <p>The primary purpose of this contract is to provide a consistent approach to handling EIP-712 typed signatures, which enable secure message signing and verification that is resistant to replay attacks and cross-contract signature misuse. EIP-712 is a standard that provides a way for users to sign typed data rather than just arbitrary binary messages, making the signing process more transparent and user-friendly.</p> <p>Within the EigenLayer architecture, this interface is likely incorporated into contracts that require user authorization via signatures, such as delegation, staking operations, or governance actions. The design follows the interface segregation principle, breaking down signature utilities into manageable components that can be integrated where needed.</p>"},{"location":"code/interfaces/ISignatureUtilsMixin/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/ISignatureUtilsMixin/#publicexternal-functions","title":"Public/External Functions","text":"<ol> <li><code>domainSeparator()</code>: </li> <li>Returns a bytes32 hash that represents the unique EIP-712 domain separator for the contract</li> <li>Used to prevent signature replay attacks across different contracts or chains</li> <li>The domain separator includes the name \"EigenLayer\", the contract's version, the current chain ID, and the contract's address</li> </ol>"},{"location":"code/interfaces/ISignatureUtilsMixin/#important-errors","title":"Important Errors","text":"<ol> <li><code>InvalidSignature()</code>:</li> <li>Thrown when a submitted signature fails validation</li> <li> <p>Could be due to incorrect format, signer mismatch, or tampering</p> </li> <li> <p><code>SignatureExpired()</code>:</p> </li> <li>Thrown when a signature is presented after its expiration timestamp</li> <li>Protects against delayed replay attacks</li> </ol>"},{"location":"code/interfaces/ISignatureUtilsMixin/#key-data-structures","title":"Key Data Structures","text":"<ol> <li><code>SignatureWithExpiry</code>:</li> <li>Bundles a signature with its expiration time</li> <li> <p>Contains:</p> <ul> <li><code>signature</code>: The actual signature bytes</li> <li><code>expiry</code>: Timestamp after which the signature is no longer valid</li> </ul> </li> <li> <p><code>SignatureWithSaltAndExpiry</code>:</p> </li> <li>Extends the previous struct by adding a salt value</li> <li>Contains:<ul> <li><code>signature</code>: The actual signature bytes</li> <li><code>salt</code>: A unique bytes32 value to prevent replay attacks</li> <li><code>expiry</code>: Timestamp after which the signature is no longer valid</li> </ul> </li> </ol>"},{"location":"code/interfaces/ISignatureUtilsMixin/#logic-flow","title":"Logic Flow","text":"<p>The interface establishes a pattern for signature handling that likely follows this general flow in implementing contracts:</p> <ol> <li>A user creates a message they wish to authorize (e.g., delegation, staking)</li> <li>The message is hashed according to EIP-712 standards using the contract's domain separator</li> <li>The user signs this hash with their private key</li> <li>The signature, possibly with expiration time and salt, is passed to the contract</li> <li>The implementing contract verifies:</li> <li>The signature hasn't expired</li> <li>The signature is valid for the given message and expected signer</li> <li>(If using salt) The signature with that salt hasn't been used before</li> </ol> <p>The domain separator returned by <code>domainSeparator()</code> is crucial in this process as it uniquely identifies the contract's context, preventing signatures meant for one contract from being used in another.</p>"},{"location":"code/interfaces/ISignatureUtilsMixin/#visual-representation","title":"Visual Representation","text":"<pre><code>sequenceDiagram\n    participant User\n    participant DApp\n    participant Contract implementing ISignatureUtilsMixin\n\n    User-&gt;&gt;DApp: Requests operation requiring authorization\n    DApp-&gt;&gt;Contract: Queries domainSeparator()\n    Contract--&gt;&gt;DApp: Returns domain separator\n\n    DApp-&gt;&gt;DApp: Creates typed data with domain separator\n    DApp-&gt;&gt;User: Requests signature of typed data\n    User-&gt;&gt;User: Signs data with private key\n    User-&gt;&gt;DApp: Returns signature\n\n    DApp-&gt;&gt;DApp: Bundles signature with expiry (and salt if needed)\n    DApp-&gt;&gt;Contract: Submits operation with SignatureWithExpiry\n\n    Contract-&gt;&gt;Contract: Checks if signature expired\n    Note right of Contract: Reverts with SignatureExpired if true\n\n    Contract-&gt;&gt;Contract: Validates signature against expected message\n    Note right of Contract: Reverts with InvalidSignature if invalid\n\n    Contract-&gt;&gt;Contract: Processes authorized operation\n    Contract--&gt;&gt;DApp: Returns success\n    DApp--&gt;&gt;User: Confirms operation completed</code></pre>"},{"location":"code/interfaces/ISignatureUtilsMixin/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>This interface extends <code>ISemVerMixin</code>, which likely provides semantic versioning functionality. The version of the contract is an important component of the domain separator calculation, as it ensures that signatures cannot be replayed across different versions of the same contract.</p> <p>The interface is designed to be implemented by various contracts within the EigenLayer ecosystem that need signature verification capabilities. Contracts implementing this interface would use it to standardize their approach to:</p> <ol> <li>Validating user signatures for operations like delegations or withdrawals</li> <li>Ensuring signatures haven't expired</li> <li>Preventing signature replay attacks using the domain separator and optional salt</li> </ol> <p>By standardizing signature utilities across the protocol, EigenLayer increases security and reduces the likelihood of implementation errors in the critical signature verification process. The EIP-712 approach also improves user experience, as it allows wallets to display human-readable signing requests rather than opaque message hashes.</p> <p>The reference to the EigenLayer Terms of Service in the contract comments suggests that this is part of a regulated protocol where legal compliance is important, underscoring the need for secure and well-defined authorization mechanisms.</p>"},{"location":"code/interfaces/IStrategy/","title":"IStrategy","text":""},{"location":"code/interfaces/IStrategy/#1-contract-overview","title":"1. Contract Overview","text":""},{"location":"code/interfaces/IStrategy/#purpose-and-main-functionality","title":"Purpose and Main Functionality","text":"<p>The <code>IStrategy</code> interface defines the standard functionality for strategy contracts within the EigenLayer protocol. These strategies represent different ways users can deploy their assets within the EigenLayer ecosystem. Each strategy handles specific tokens and provides users with shares in proportion to their deposits, allowing them to participate in the protocol while maintaining a claim on their underlying assets.</p>"},{"location":"code/interfaces/IStrategy/#system-architecture-context","title":"System Architecture Context","text":"<p>Within the EigenLayer ecosystem, strategy contracts serve as asset management vehicles that interact primarily with the StrategyManager contract. The StrategyManager tracks user deposits across different strategies and manages the overall delegation of these assets, while the individual strategy contracts implement the specific logic for how those assets are deployed.</p>"},{"location":"code/interfaces/IStrategy/#key-design-patterns","title":"Key Design Patterns","text":"<ul> <li>Interface Segregation: The contract separates concerns by splitting functionality into distinct interfaces (<code>IStrategyErrors</code>, <code>IStrategyEvents</code>, and <code>ISemVerMixin</code>).</li> <li>Token-Based Accounting: Uses an shares-based accounting system where users receive shares proportional to their deposits.</li> <li>Exchange Rate Mechanisms: Provides functions to convert between shares and underlying tokens.</li> <li>Role-Based Access Control: Restricts key functions to only be callable by the StrategyManager.</li> </ul>"},{"location":"code/interfaces/IStrategy/#2-contract-interface","title":"2. Contract Interface","text":""},{"location":"code/interfaces/IStrategy/#publicexternal-functions","title":"Public/External Functions","text":""},{"location":"code/interfaces/IStrategy/#depositwithdraw-functions","title":"Deposit/Withdraw Functions","text":"<ul> <li><code>deposit(IERC20 token, uint256 amount)</code>: Allows the StrategyManager to deposit tokens into the strategy, converting the amount to shares.</li> <li><code>withdraw(address recipient, IERC20 token, uint256 amountShares)</code>: Withdraws tokens from the strategy to a recipient address based on a specified amount of shares.</li> </ul>"},{"location":"code/interfaces/IStrategy/#conversion-functions","title":"Conversion Functions","text":"<ul> <li><code>sharesToUnderlying(uint256 amountShares)</code>: Converts shares to the equivalent amount of underlying tokens, may modify state.</li> <li><code>sharesToUnderlyingView(uint256 amountShares)</code>: View-only version of the above function.</li> <li><code>underlyingToShares(uint256 amountUnderlying)</code>: Converts underlying tokens to the equivalent amount of shares, may modify state.</li> <li><code>underlyingToSharesView(uint256 amountUnderlying)</code>: View-only version of the above function.</li> </ul>"},{"location":"code/interfaces/IStrategy/#user-information-functions","title":"User Information Functions","text":"<ul> <li><code>userUnderlying(address user)</code>: Calculates the underlying value of all a user's shares, may modify state.</li> <li><code>userUnderlyingView(address user)</code>: View-only version of the above function.</li> <li><code>shares(address user)</code>: Returns the current total shares a user has in this strategy.</li> </ul>"},{"location":"code/interfaces/IStrategy/#state-information-functions","title":"State Information Functions","text":"<ul> <li><code>underlyingToken()</code>: Returns the ERC20 token that the strategy accepts.</li> <li><code>totalShares()</code>: Returns the total number of shares issued by the strategy.</li> <li><code>explanation()</code>: Returns a description or link to metadata explaining the strategy's purpose.</li> </ul>"},{"location":"code/interfaces/IStrategy/#important-events","title":"Important Events","text":"<ul> <li><code>ExchangeRateEmitted(uint256 rate)</code>: Emitted when the exchange rate between shares and the underlying token changes.</li> <li><code>StrategyTokenSet(IERC20 token, uint8 decimals)</code>: Emitted upon strategy creation to indicate the underlying token and its decimals.</li> </ul>"},{"location":"code/interfaces/IStrategy/#key-errors","title":"Key Errors","text":"<ul> <li><code>OnlyStrategyManager()</code>: Thrown when functions restricted to the StrategyManager are called by other addresses.</li> <li><code>NewSharesZero()</code>: Thrown when a deposit would result in zero new shares.</li> <li><code>TotalSharesExceedsMax()</code>: Thrown when total shares would exceed the maximum allowed.</li> <li><code>WithdrawalAmountExceedsTotalDeposits()</code>: Thrown when attempting to withdraw more shares than available.</li> <li><code>OnlyUnderlyingToken()</code>: Thrown when attempting actions with tokens not accepted by the strategy.</li> <li><code>MaxPerDepositExceedsMax()</code>: Error related to per-deposit limits.</li> <li><code>BalanceExceedsMaxTotalDeposits()</code>: Error when a deposit would exceed maximum strategy capacity.</li> </ul>"},{"location":"code/interfaces/IStrategy/#3-logic-flow","title":"3. Logic Flow","text":""},{"location":"code/interfaces/IStrategy/#deposit-workflow","title":"Deposit Workflow","text":"<ol> <li>The StrategyManager calls the <code>deposit</code> function with a token and amount.</li> <li>The strategy verifies the token is the accepted underlying token.</li> <li>The strategy calculates the number of shares to be minted based on the current exchange rate.</li> <li>New shares are minted and recorded in the StrategyManager.</li> <li>The function returns the number of new shares issued.</li> </ol>"},{"location":"code/interfaces/IStrategy/#withdrawal-workflow","title":"Withdrawal Workflow","text":"<ol> <li>The StrategyManager calls the <code>withdraw</code> function with recipient, token, and amount of shares.</li> <li>The strategy verifies the token is the accepted underlying token.</li> <li>The strategy calculates the amount of underlying tokens corresponding to the shares being withdrawn.</li> <li>The calculated amount of underlying tokens is transferred to the recipient.</li> <li>The shares are burned/recorded as withdrawn in the StrategyManager.</li> </ol>"},{"location":"code/interfaces/IStrategy/#sharetoken-conversion","title":"Share/Token Conversion","text":"<p>The contract maintains an exchange rate between shares and the underlying token. This rate may: - Start at 1:1 (one token = one share) - Change over time based on strategy performance - Be calculated differently in various strategy implementations</p> <p>The conversion functions allow users and the protocol to determine: - How many tokens they would receive for a given amount of shares - How many shares they would receive for depositing a given amount of tokens</p> <p>This exchange rate represents the key mechanism by which users can benefit from strategy performance, as shares may appreciate in value relative to the underlying token.</p>"},{"location":"code/interfaces/IStrategy/#security-mechanisms","title":"Security Mechanisms","text":"<ul> <li>Function access control (only StrategyManager can deposit/withdraw)</li> <li>Validation checks for token types</li> <li>Checks to prevent withdrawal amounts exceeding available shares</li> <li>Limits on total deposits and per-deposit amounts</li> </ul>"},{"location":"code/interfaces/IStrategy/#4-visual-representation","title":"4. Visual Representation","text":"<pre><code>flowchart TD\n    User([User]) --&gt; |Deposits tokens| SM[StrategyManager]\n    SM --&gt; |deposit()| Strategy[Strategy Contract]\n    Strategy --&gt; |Returns shares| SM\n    SM --&gt; |Records user shares| SM\n\n    User --&gt; |Requests withdrawal| SM\n    SM --&gt; |withdraw()| Strategy\n    Strategy --&gt; |Sends tokens| User\n\n    User --&gt; |Queries position| SM\n    SM --&gt; |shares()| Strategy\n    Strategy --&gt; |sharesToUnderlyingView()| Strategy\n    Strategy --&gt; |Returns token value| User\n\n    subgraph Strategy Implementation\n        Strategy --&gt; |Manages| UnderlyingTokens[(Underlying Tokens)]\n        Strategy --&gt; |Tracks| TotalShares[(Total Shares)]\n        Strategy --&gt; |Calculates| ExchangeRate[(Exchange Rate)]\n    end</code></pre>"},{"location":"code/interfaces/IStrategy/#5-dependencies-and-interactions","title":"5. Dependencies and Interactions","text":""},{"location":"code/interfaces/IStrategy/#contract-dependencies","title":"Contract Dependencies","text":"<ul> <li>@openzeppelin/contracts/token/ERC20/IERC20.sol: Used for the underlying token interface.</li> <li>../libraries/SlashingLib.sol: While imported, this library isn't directly used in the interface but is likely used by implementing contracts for slashing logic.</li> <li>./ISemVerMixin.sol: Provides semantic versioning functionality for the contract.</li> </ul>"},{"location":"code/interfaces/IStrategy/#external-contract-interactions","title":"External Contract Interactions","text":"<ul> <li>StrategyManager: The primary contract that interacts with Strategy contracts. It manages user deposits across different strategies and is the only contract authorized to call the deposit and withdraw functions.</li> <li>DelegationManager: Referenced in documentation comments, suggesting that users can delegate their strategy shares to operators within the EigenLayer system.</li> </ul>"},{"location":"code/interfaces/IStrategy/#system-interactions","title":"System Interactions","text":"<p>Strategy contracts serve as the bridge between user assets and whatever protocol or system they deploy those assets to. While this interface doesn't specify implementation details, real-world strategies might:</p> <ol> <li>Deploy funds to external protocols like lending markets, DEXes, or yield farms</li> <li>Provide liquidity to various DeFi applications</li> <li>Stake assets in proof-of-stake validators</li> <li>Create derivatives or other financial products</li> </ol> <p>The primary value proposition is allowing users to deposit assets into EigenLayer while still generating yields from other activities, with the exchange rate mechanism enabling users to benefit from that yield.</p> <p>This interface creates a standardized way for the EigenLayer protocol to interact with diverse strategies while abstracting away the specifics of how each strategy generates returns.</p>"},{"location":"code/interfaces/IStrategyFactory/","title":"IStrategyFactory","text":""},{"location":"code/interfaces/IStrategyFactory/#contract-overview","title":"Contract Overview","text":"<p><code>IStrategyFactory</code> is an interface that defines the contract responsible for deploying and managing strategy contracts within the EigenLayer protocol. Its primary purpose is to create and track strategy contracts for different ERC20 tokens, allowing the protocol to standardize how these tokens are handled within the system.</p> <p>This interface sits at a crucial junction in the EigenLayer architecture, acting as the factory that produces strategy contracts which manage how different tokens are staked, delegated, and utilized. It employs the factory pattern to create new strategy instances while maintaining a registry of deployed strategies, and leverages the beacon proxy pattern for upgradability of the strategy implementation.</p> <p>The key design patterns evident in this interface are: - Factory Pattern: For creating new strategy contracts - Proxy Pattern: Using OpenZeppelin's beacon proxy for upgradability - Registry Pattern: Maintaining a record of deployed strategies</p>"},{"location":"code/interfaces/IStrategyFactory/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/IStrategyFactory/#publicexternal-functions","title":"Public/External Functions","text":"<ol> <li> <p>strategyBeacon() - Returns the beacon contract that all deployed strategies point to for their implementation. This enables upgrading all strategies at once by updating the beacon.</p> </li> <li> <p>deployedStrategies(IERC20 token) - Returns the strategy contract associated with a specific ERC20 token, allowing other contracts to find the appropriate strategy for a given token.</p> </li> <li> <p>deployNewStrategy(IERC20 token) - Deploys a new strategy contract for a specified ERC20 token. This function creates the strategy and registers it in the factory's records.</p> </li> <li> <p>whitelistStrategies(IStrategy[] calldata strategiesToWhitelist) - Allows the owner to whitelist strategies in the StrategyManager. Whitelisted strategies are approved for deposits within the protocol.</p> </li> <li> <p>removeStrategiesFromWhitelist(IStrategy[] calldata strategiesToRemoveFromWhitelist) - Allows the owner to remove strategies from the whitelist, preventing further deposits.</p> </li> </ol>"},{"location":"code/interfaces/IStrategyFactory/#events","title":"Events","text":"<ol> <li> <p>TokenBlacklisted(IERC20 token) - Emitted when a token is blacklisted, preventing strategy deployment for that token.</p> </li> <li> <p>StrategyBeaconModified(IBeacon previousBeacon, IBeacon newBeacon) - Emitted when the strategy beacon is updated, indicating a change in the implementation for all deployed strategies.</p> </li> <li> <p>StrategySetForToken(IERC20 token, IStrategy strategy) - Emitted when a strategy is associated with a specific token, either through deployment or manual configuration.</p> </li> </ol>"},{"location":"code/interfaces/IStrategyFactory/#errors","title":"Errors","text":"<ol> <li> <p>BlacklistedToken() - Thrown when attempting to deploy a strategy for a token that has been blacklisted.</p> </li> <li> <p>StrategyAlreadyExists() - Thrown when attempting to deploy a strategy for a token that already has an associated strategy.</p> </li> <li> <p>AlreadyBlacklisted() - Thrown when attempting to blacklist a token that is already blacklisted.</p> </li> </ol>"},{"location":"code/interfaces/IStrategyFactory/#logic-flow","title":"Logic Flow","text":"<p>The main workflow of the StrategyFactory revolves around the deployment and management of strategy contracts:</p> <ol> <li>Strategy Deployment Process:</li> <li>A request is made to deploy a new strategy for a specific ERC20 token</li> <li>The factory checks if the token is blacklisted</li> <li>The factory verifies that a strategy doesn't already exist for that token</li> <li>A new strategy is deployed using the beacon proxy pattern</li> <li>The strategy is registered in the <code>deployedStrategies</code> mapping</li> <li> <p>The new strategy is typically whitelisted in the StrategyManager for deposits</p> </li> <li> <p>Whitelist Management:</p> </li> <li>The owner can whitelist strategies to allow deposits</li> <li> <p>The owner can remove strategies from the whitelist to prevent new deposits</p> </li> <li> <p>Security Mechanisms:</p> </li> <li>Token blacklisting to prevent strategies for potentially dangerous tokens</li> <li>Owner-restricted access to critical functions like whitelist management</li> <li>Beacon proxy pattern for upgradability with centralized control</li> <li>Warning about non-standard ERC20 tokens, particularly reentrant ones like ERC777</li> </ol>"},{"location":"code/interfaces/IStrategyFactory/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Protocol Governance] --&gt;|Updates beacon implementation| B[StrategyBeacon]\n    A --&gt;|Deploys new strategies| C[StrategyFactory]\n    A --&gt;|Manages whitelist| C\n    C --&gt;|Creates| D[Strategy Proxy 1]\n    C --&gt;|Creates| E[Strategy Proxy 2]\n    C --&gt;|Creates| F[Strategy Proxy n]\n    B --&gt;|Implementation reference| D\n    B --&gt;|Implementation reference| E\n    B --&gt;|Implementation reference| F\n    D --&gt;|Manages| G[Token 1]\n    E --&gt;|Manages| H[Token 2]\n    F --&gt;|Manages| I[Token n]\n    J[StrategyManager] --&gt;|Reads whitelisted status| C\n    J --&gt;|Interacts with| D\n    J --&gt;|Interacts with| E\n    J --&gt;|Interacts with| F</code></pre>"},{"location":"code/interfaces/IStrategyFactory/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The <code>IStrategyFactory</code> interface relies on several external contracts and interfaces:</p> <ol> <li> <p>OpenZeppelin's IBeacon - Used for the upgradable beacon proxy pattern that all deployed strategies follow.</p> </li> <li> <p>OpenZeppelin's IERC20 - Used to interface with the ERC20 tokens that strategies are created for.</p> </li> <li> <p>IStrategy - The interface that all deployed strategy contracts implement, defining the standard functions for token management within the protocol.</p> </li> <li> <p>ISemVerMixin - Provides semantic versioning functionality, allowing the contract to track and report its version.</p> </li> <li> <p>StrategyManager (implied) - While not directly imported, the interface includes functions to interact with the StrategyManager contract, particularly for whitelist management.</p> </li> </ol> <p>The StrategyFactory serves as a central registry and deployment mechanism for strategies within the EigenLayer ecosystem. When users or other contracts need to interact with a particular token, they can query the factory to find the appropriate strategy. The factory ensures standardization across all strategies while providing flexibility for different token characteristics through the individual strategy implementations.</p> <p>The factory also plays a crucial security role by maintaining a blacklist of tokens that cannot have strategies deployed for them, protecting the system from potentially dangerous token contracts (like those with reentrancy capabilities that could exploit the protocol).</p>"},{"location":"code/interfaces/IStrategyManager/","title":"IStrategyManager","text":""},{"location":"code/interfaces/IStrategyManager/#contract-overview","title":"Contract Overview","text":"<p>IStrategyManager serves as the primary entrypoint for funds into the EigenLayer protocol. This interface defines the core functionality for depositing assets into various strategies within the EigenLayer ecosystem. EigenLayer is a restaking protocol that allows users to \"restake\" their ETH or other tokens to earn additional yield while still participating in Ethereum's consensus mechanism.</p> <p>The contract primarily manages the relationship between users (stakers), their delegated operators, and the various strategies that handle different assets. It enables users to deposit tokens into whitelisted strategies, track their shares in each strategy, and provides mechanisms for slashing (penalizing) when necessary.</p> <p>The interface uses a robust design pattern combining several smaller interfaces (errors, events, share management) to create a comprehensive contract that handles the critical fund management aspects of the EigenLayer protocol.</p>"},{"location":"code/interfaces/IStrategyManager/#contract-interface","title":"Contract Interface","text":""},{"location":"code/interfaces/IStrategyManager/#publicexternal-functions","title":"Public/External Functions","text":"<ol> <li>initialize(address initialOwner, address initialStrategyWhitelister, uint256 initialPausedStatus)</li> <li>Initializes the StrategyManager contract</li> <li>Sets up ownership and whitelister controls</li> <li> <p>Sets initial pause status for emergency controls</p> </li> <li> <p>depositIntoStrategy(IStrategy strategy, IERC20 token, uint256 amount)</p> </li> <li>Allows users to deposit tokens into a whitelisted strategy</li> <li> <p>Returns the number of shares issued to the staker</p> </li> <li> <p>depositIntoStrategyWithSignature(IStrategy strategy, IERC20 token, uint256 amount, address staker, uint256 expiry, bytes memory signature)</p> </li> <li>Permits depositing on behalf of another user with their signature</li> <li> <p>Enables third-party deposits while maintaining security</p> </li> <li> <p>burnShares(IStrategy strategy)</p> </li> <li>Burns strategy shares as part of the slashing mechanism</li> <li> <p>Used for protocol penalties</p> </li> <li> <p>setStrategyWhitelister(address newStrategyWhitelister)</p> </li> <li> <p>Owner-only function to update the strategy whitelister address</p> </li> <li> <p>addStrategiesToDepositWhitelist(IStrategy[] calldata strategiesToWhitelist)</p> </li> <li> <p>Owner-only function to approve new strategies for deposits</p> </li> <li> <p>removeStrategiesFromDepositWhitelist(IStrategy[] calldata strategiesToRemoveFromWhitelist)</p> </li> <li> <p>Owner-only function to remove strategies from the whitelist</p> </li> <li> <p>View Functions</p> </li> <li>strategyIsWhitelistedForDeposit(IStrategy strategy) - Checks if strategy is approved</li> <li>getDeposits(address staker) - Returns staker's strategies and shares</li> <li>getStakerStrategyList(address staker) - Lists strategies a staker is using</li> <li>stakerStrategyListLength(address staker) - Returns count of strategies used</li> <li>stakerDepositShares(address user, IStrategy strategy) - Returns user's shares in a strategy</li> <li>delegation() - Returns the central Delegation contract</li> <li>strategyWhitelister() - Returns the address allowed to whitelist strategies</li> <li>getBurnableShares(IStrategy strategy) - Returns burnable shares for a strategy</li> <li>getStrategiesWithBurnableShares() - Returns all strategies with burnable shares</li> <li>calculateStrategyDepositDigestHash(...) - Calculates hash for signature-based deposits</li> </ol>"},{"location":"code/interfaces/IStrategyManager/#important-events","title":"Important Events","text":"<ol> <li>Deposit(address staker, IStrategy strategy, uint256 shares)</li> <li>Emitted when a new deposit occurs for a staker</li> <li> <p>Tracks which strategy was used and how many shares were issued</p> </li> <li> <p>StrategyWhitelisterChanged(address previousAddress, address newAddress)</p> </li> <li> <p>Records changes to the strategy whitelister role</p> </li> <li> <p>StrategyAddedToDepositWhitelist(IStrategy strategy)</p> </li> <li> <p>Indicates when a new strategy is approved for deposits</p> </li> <li> <p>StrategyRemovedFromDepositWhitelist(IStrategy strategy)</p> </li> <li> <p>Shows when a strategy is removed from the whitelist</p> </li> <li> <p>BurnableSharesIncreased(IStrategy strategy, uint256 shares)</p> </li> <li> <p>Triggered when an operator is slashed and shares marked for burning</p> </li> <li> <p>BurnableSharesDecreased(IStrategy strategy, uint256 shares)</p> </li> <li>Emitted when shares are burned</li> </ol>"},{"location":"code/interfaces/IStrategyManager/#key-state-variables","title":"Key State Variables","text":"<p>While state variables aren't explicitly defined in this interface, the function signatures imply several important state mappings:</p> <ul> <li>Mapping of stakers to their strategies</li> <li>Mapping of stakers to their share amounts per strategy</li> <li>Whitelist of approved strategies</li> <li>Registry of burnable shares per strategy</li> <li>Delegation manager contract reference</li> </ul>"},{"location":"code/interfaces/IStrategyManager/#logic-flow","title":"Logic Flow","text":""},{"location":"code/interfaces/IStrategyManager/#depositing-funds","title":"Depositing Funds","text":"<ol> <li>A user approves the StrategyManager contract to spend their tokens</li> <li>The user calls <code>depositIntoStrategy</code> with a whitelisted strategy, token, and amount</li> <li>The contract verifies the strategy is whitelisted</li> <li>Tokens are transferred from the user to the strategy</li> <li>The strategy mints shares that represent the user's deposit</li> <li>These shares are recorded in the StrategyManager and associated with the user</li> <li>The Deposit event is emitted</li> </ol>"},{"location":"code/interfaces/IStrategyManager/#delegated-deposits","title":"Delegated Deposits","text":"<ol> <li>A staker signs a message authorizing a deposit on their behalf</li> <li>A third party calls <code>depositIntoStrategyWithSignature</code> with the staker's address and signature</li> <li>The contract validates the signature against the calculated digest hash</li> <li>If valid, the third party's tokens are transferred to the strategy</li> <li>Shares are credited to the staker's account, not the caller</li> <li>The staker gains shares without directly interacting with the contract</li> </ol>"},{"location":"code/interfaces/IStrategyManager/#slashing-process","title":"Slashing Process","text":"<ol> <li>When a delegated operator violates protocol rules, slashing is initiated</li> <li>The delegation contract marks certain shares as \"burnable\"</li> <li><code>BurnableSharesIncreased</code> event is emitted</li> <li>Later, <code>burnShares</code> can be called to permanently remove these shares</li> <li>When shares are burned, <code>BurnableSharesDecreased</code> event is emitted</li> <li>This effectively penalizes the operator and their delegators</li> </ol>"},{"location":"code/interfaces/IStrategyManager/#strategy-management","title":"Strategy Management","text":"<ol> <li>Owner or whitelister can add strategies to the whitelist</li> <li>Whitelisted strategies can be removed when necessary</li> <li>Users can only deposit into whitelisted strategies</li> <li>The contract tracks which strategies each user has deposited into</li> <li>Users can have deposits across multiple strategies simultaneously</li> </ol>"},{"location":"code/interfaces/IStrategyManager/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    User[User/Staker] --&gt;|Deposit Tokens| SM[StrategyManager]\n    ThirdParty[Third Party] --&gt;|Deposit with Signature| SM\n    SM --&gt;|Transfer Tokens| S[Strategy]\n    S --&gt;|Issue Shares| SM\n    SM --&gt;|Record Shares| UserShares[User Share Records]\n\n    Owner[Owner] --&gt;|Manage| Whitelist[Strategy Whitelist]\n    Whitelist --&gt;|Control| SM\n\n    DM[DelegationManager] --&gt;|Slash Request| SM\n    SM --&gt;|Burn Shares| S\n\n    subgraph EigenLayer Core\n        SM\n        DM\n        UserShares\n        Whitelist\n    end\n\n    subgraph Strategies\n        S\n        S1[Strategy 1]\n        S2[Strategy 2]\n        S3[Strategy 3]\n    end</code></pre>"},{"location":"code/interfaces/IStrategyManager/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The StrategyManager interacts with several key contracts in the EigenLayer ecosystem:</p> <ol> <li> <p>IStrategy - Each strategy represents a specific asset class or yield-generating mechanism. The StrategyManager deposits tokens into strategies and tracks the shares issued.</p> </li> <li> <p>IShareManager - The StrategyManager inherits from IShareManager, suggesting it manages share accounting for all strategies and users.</p> </li> <li> <p>IDelegationManager - The delegation contract manages the relationship between stakers and operators. The StrategyManager interacts with the delegation contract for slashing operations.</p> </li> <li> <p>IEigenPodManager - Though not directly referenced in the interface functions, this is imported, suggesting interaction with Ethereum validators.</p> </li> <li> <p>ISemVerMixin - Provides semantic versioning capabilities for contract upgrades and compatibility tracking.</p> </li> </ol> <p>The contract serves as a central hub within EigenLayer, connecting users with strategies while enforcing security rules. It allows for deposits, manages whitelist controls, and facilitates the slashing mechanism that's core to EigenLayer's security model.</p> <p>This interface represents a carefully designed system for managing restaked assets with provisions for security, delegation, and proper accounting - all critical aspects of a successful restaking protocol.</p>"},{"location":"code/libraries/BeaconChainProofs/","title":"BeaconChainProofs","text":""},{"location":"code/libraries/BeaconChainProofs/#contract-overview","title":"Contract Overview","text":"<p>BeaconChainProofs is a utility library designed to verify and parse data from Ethereum's beacon chain. Its primary purpose is to validate various proofs about validator states and balances within the beacon chain using Merkle proof verification. This library serves as a crucial connection between the Ethereum execution layer (where smart contracts run) and the consensus layer (beacon chain).</p> <p>The library follows the Simple Serialize (SSZ) specification for Ethereum's consensus layer, particularly focusing on the Phase 0 beacon chain structures like BeaconBlockHeader and BeaconState. It implements complex Merkle proof verification logic to confirm the authenticity of data claimed to exist in the beacon chain without requiring direct access to it.</p> <p>Key design patterns include: - Use of Merkle tree verification for cryptographic proofs - Structured data parsing for beacon chain objects - Clear separation of proof verification for different beacon chain components - Utility functions to extract specific validator data from verified proofs</p>"},{"location":"code/libraries/BeaconChainProofs/#contract-interface","title":"Contract Interface","text":""},{"location":"code/libraries/BeaconChainProofs/#key-state-variables","title":"Key State Variables","text":"<ul> <li>Constants for Tree Heights: Define the heights of various Merkle trees in the beacon chain (e.g., <code>BEACON_BLOCK_HEADER_TREE_HEIGHT</code>, <code>VALIDATOR_TREE_HEIGHT</code>)</li> <li>Field Indices: Constants defining the position of various fields within beacon chain data structures (e.g., <code>STATE_ROOT_INDEX</code>, <code>VALIDATOR_PUBKEY_INDEX</code>)</li> <li>Timing Constants: Define beacon chain time parameters (e.g., <code>SECONDS_PER_SLOT</code>, <code>SLOTS_PER_EPOCH</code>)</li> <li>Special Values: Constants like <code>FAR_FUTURE_EPOCH</code> that have specific meanings in the beacon chain protocol</li> </ul>"},{"location":"code/libraries/BeaconChainProofs/#struct-definitions","title":"Struct Definitions","text":"<ol> <li>StateRootProof: Contains a beacon state root and proof of its inclusion in a beacon block</li> <li>ValidatorProof: Contains a validator's fields and proof of their inclusion in a beacon state</li> <li>BalanceContainerProof: Contains a balance container root and its proof under a beacon block root</li> <li>BalanceProof: Contains validator balance information and proof of its inclusion in the balance container</li> </ol>"},{"location":"code/libraries/BeaconChainProofs/#public-functions","title":"Public Functions","text":"<ol> <li>verifyStateRoot: Verifies that a beacon state root exists in a specified beacon block</li> <li>verifyValidatorFields: Verifies a validator's data against a beacon state root</li> <li>verifyBalanceContainer: Verifies the balance container root against a beacon block root</li> <li>verifyValidatorBalance: Verifies a validator's balance against the balance container and returns the balance</li> <li>Getter functions: Several utility functions to extract specific validator data:</li> <li>getPubkeyHash</li> <li>getWithdrawalCredentials</li> <li>getEffectiveBalanceGwei</li> <li>getActivationEpoch</li> <li>isValidatorSlashed</li> <li>getExitEpoch</li> </ol>"},{"location":"code/libraries/BeaconChainProofs/#custom-errors","title":"Custom Errors","text":"<ul> <li>InvalidProof: Thrown when a proof verification fails</li> <li>InvalidProofLength: Thrown when a proof has an incorrect length</li> <li>InvalidValidatorFieldsLength: Thrown when validator fields don't match the expected count</li> </ul>"},{"location":"code/libraries/BeaconChainProofs/#logic-flow","title":"Logic Flow","text":"<p>The BeaconChainProofs library provides verification for a hierarchy of Merkle proofs that lead from individual validator data up to beacon block roots. The proof verification follows this logical flow:</p>"},{"location":"code/libraries/BeaconChainProofs/#beacon-state-root-verification","title":"Beacon State Root Verification","text":"<ol> <li>Takes a beacon block root and a state root with its proof</li> <li>Verifies that the state root is properly included in the block's header using Merkle verification</li> <li>This establishes trust in the beacon state root for further proofs</li> </ol>"},{"location":"code/libraries/BeaconChainProofs/#validator-fields-verification","title":"Validator Fields Verification","text":"<ol> <li>Takes a trusted beacon state root and validator data with proof</li> <li>Merkleizes the validator fields to obtain a validator root</li> <li>Calculates the appropriate index in the combined Merkle trees</li> <li>Verifies the validator root is properly included in the beacon state</li> <li>This confirms the validator's data (like withdrawal credentials or effective balance) is legitimate</li> </ol>"},{"location":"code/libraries/BeaconChainProofs/#balance-verification-two-step-process","title":"Balance Verification (Two-step process)","text":"<ol> <li>Balance Container Verification:</li> <li>Takes a beacon block root and balance container proof</li> <li>Verifies the balance container's inclusion in the beacon state</li> <li> <p>This establishes trust in the balance container root</p> </li> <li> <p>Individual Balance Verification:</p> </li> <li>Takes a trusted balance container root and a specific validator index</li> <li>Verifies the proof for a specific \"balance root\" (which contains 4 balances)</li> <li>Extracts the individual validator's balance from the verified balance root</li> <li>Returns the validator's balance in Gwei</li> </ol> <p>The library handles complex bit manipulation and endian conversion to properly extract little-endian encoded values from the beacon chain data structures, ensuring accurate representation of numeric values.</p>"},{"location":"code/libraries/BeaconChainProofs/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Beacon Block Root] --&gt;|verifyStateRoot| B[Beacon State Root]\n    B --&gt;|verifyValidatorFields| C[Validator Data]\n    B --&gt;|Part of verifyBalanceContainer| D[Balance Container Root]\n    D --&gt;|verifyValidatorBalance| E[Individual Validator Balance]\n\n    C --&gt;|getPubkeyHash| F[Pubkey Hash]\n    C --&gt;|getWithdrawalCredentials| G[Withdrawal Credentials]\n    C --&gt;|getEffectiveBalanceGwei| H[Effective Balance]\n    C --&gt;|getActivationEpoch| I[Activation Epoch]\n    C --&gt;|isValidatorSlashed| J[Slashed Status]\n    C --&gt;|getExitEpoch| K[Exit Epoch]</code></pre>"},{"location":"code/libraries/BeaconChainProofs/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The BeaconChainProofs library has two key dependencies:</p> <ol> <li> <p>Merkle.sol: Provides core Merkle tree verification functionality. The library heavily relies on <code>Merkle.verifyInclusionSha256()</code> to perform cryptographic verification of proofs and <code>Merkle.merkleizeSha256()</code> to create Merkle roots from validator data.</p> </li> <li> <p>Endian.sol: Handles endian conversion, particularly for extracting little-endian encoded uint64 values from the beacon chain data structures. This is crucial for correctly parsing numeric fields like balances and epochs.</p> </li> </ol> <p>This library likely interfaces with other contracts in the broader system that need to verify data from the beacon chain, such as: - Staking contracts that need to verify validator balances - Withdrawal contracts that need to verify validator status and credentials - Oracle or bridge contracts that relay information from the beacon chain to the execution layer</p> <p>The library serves as a critical security layer, ensuring that any claimed data about the beacon chain can be cryptographically verified before being used in smart contract logic. Its meticulous implementation of Merkle proof verification creates a trust link between the consensus and execution layers of Ethereum.</p>"},{"location":"code/libraries/BytesLib/","title":"BytesLib","text":""},{"location":"code/libraries/BytesLib/#1-contract-overview","title":"1. Contract Overview","text":"<p>BytesLib is a utility library for Solidity smart contracts that provides advanced manipulation capabilities for byte arrays. Created by Gon\u00e7alo S\u00e1, this library is designed to address common operations that aren't natively supported in Solidity but are frequently needed in smart contract development.</p> <p>The primary purpose of BytesLib is to enable developers to manipulate bytes arrays more efficiently and safely, whether they're stored in memory or storage. The key operations provided include:</p> <ul> <li>Concatenating (joining) two byte arrays together</li> <li>Extracting portions (slicing) from a byte array</li> <li>Converting byte arrays to various data types (address, uint8, uint16, etc.)</li> <li>Comparing byte arrays for equality</li> </ul> <p>The library primarily uses inline assembly (Yul) to achieve performance optimizations and direct memory manipulation that wouldn't be possible with standard Solidity. This approach makes the code more gas-efficient by avoiding unnecessary memory allocations and copying operations.</p> <p>The design pattern used here is a pure utility library pattern, where all functions are internal and meant to be used by importing the library into other contracts rather than deploying it as a standalone contract.</p>"},{"location":"code/libraries/BytesLib/#2-contract-interface","title":"2. Contract Interface","text":""},{"location":"code/libraries/BytesLib/#publicexternal-functions","title":"Public/External Functions","text":"<p>BytesLib doesn't expose any public or external functions, as it's designed to be used as an imported library rather than directly interacted with. All functions are marked as <code>internal</code> and can be accessed by importing the library.</p>"},{"location":"code/libraries/BytesLib/#key-functions","title":"Key Functions","text":"<ol> <li>Byte Array Operations:</li> <li><code>concat(bytes memory _preBytes, bytes memory _postBytes)</code>: Joins two byte arrays into one</li> <li><code>concatStorage(bytes storage _preBytes, bytes memory _postBytes)</code>: Appends memory bytes to storage bytes</li> <li><code>slice(bytes memory _bytes, uint256 _start, uint256 _length)</code>: Extracts a portion from a byte array</li> <li><code>equal(bytes memory _preBytes, bytes memory _postBytes)</code>: Compares two byte arrays in memory</li> <li> <p><code>equalStorage(bytes storage _preBytes, bytes memory _postBytes)</code>: Compares storage bytes with memory bytes</p> </li> <li> <p>Type Conversion:</p> </li> <li><code>toAddress(bytes memory _bytes, uint256 _start)</code>: Converts bytes to an address</li> <li><code>toUint8/16/32/64/96/128/256(bytes memory _bytes, uint256 _start)</code>: Converts bytes to various unsigned integers</li> <li><code>toBytes32(bytes memory _bytes, uint256 _start)</code>: Converts bytes to bytes32</li> </ol>"},{"location":"code/libraries/BytesLib/#error-handling","title":"Error Handling","text":"<p>The library defines two custom errors: - <code>Overflow</code>: Triggered when arithmetic operations might overflow - <code>OutOfBounds</code>: Thrown when attempting to access bytes outside the array boundaries</p>"},{"location":"code/libraries/BytesLib/#3-logic-flow","title":"3. Logic Flow","text":""},{"location":"code/libraries/BytesLib/#concatenation-logic","title":"Concatenation Logic","text":"<p>The <code>concat</code> and <code>concatStorage</code> functions both join two byte arrays together but with different approaches:</p> <ol> <li>Memory Concatenation (<code>concat</code>):</li> <li>Allocates a new memory area to hold the combined arrays</li> <li>Copies the first array into this new area</li> <li>Appends the second array</li> <li> <p>Updates the free memory pointer</p> </li> <li> <p>Storage Concatenation (<code>concatStorage</code>):</p> </li> <li>This is more complex due to Solidity's storage layout</li> <li>The function handles three different cases based on the current and resulting array lengths:<ul> <li>Case 1: Both original and resulting arrays fit in a single storage slot (&lt; 32 bytes)</li> <li>Case 2: Original array fits in a slot but combined array doesn't</li> <li>Default case: Original array already spans multiple slots</li> </ul> </li> </ol>"},{"location":"code/libraries/BytesLib/#slicing-logic","title":"Slicing Logic","text":"<p>The <code>slice</code> function extracts a section from a byte array: 1. Validates that the requested segment exists within the source array 2. Allocates a new memory area for the result 3. Copies the specified bytes from the source to the result 4. Special handling for zero-length slices</p>"},{"location":"code/libraries/BytesLib/#type-conversion-logic","title":"Type Conversion Logic","text":"<p>All type conversion functions follow a similar pattern: 1. Check if the byte array has enough bytes to extract the desired type 2. Use assembly to extract the specific bytes and interpret them as the target type 3. Return the converted value</p>"},{"location":"code/libraries/BytesLib/#equality-comparison","title":"Equality Comparison","text":"<p>The equality functions compare byte arrays: 1. First check if the lengths match (if not, arrays are not equal) 2. If lengths match, compare the contents word by word 3. Return true only if all words match</p>"},{"location":"code/libraries/BytesLib/#4-visual-representation","title":"4. Visual Representation","text":"<pre><code>flowchart TD\n    A[BytesLib] --&gt; B[Byte Array Operations]\n    A --&gt; C[Type Conversions]\n\n    B --&gt; B1[concat\\nmemory to memory]\n    B --&gt; B2[concatStorage\\nmemory to storage]\n    B --&gt; B3[slice\\nextract portion]\n    B --&gt; B4[equal\\ncompare arrays]\n    B --&gt; B5[equalStorage\\ncompare with storage]\n\n    C --&gt; C1[toAddress]\n    C --&gt; C2[toUint8/16/32/64/96/128/256]\n    C --&gt; C3[toBytes32]\n\n    B1 --&gt; D[Assembly Operations]\n    B2 --&gt; D\n    B3 --&gt; D\n    B4 --&gt; D\n    B5 --&gt; D\n    C1 --&gt; D\n    C2 --&gt; D\n    C3 --&gt; D\n\n    D --&gt; D1[Memory Management]\n    D --&gt; D2[Storage Access]\n    D --&gt; D3[Bit Operations]</code></pre>"},{"location":"code/libraries/BytesLib/#5-dependencies-and-interactions","title":"5. Dependencies and Interactions","text":"<p>BytesLib is designed to be a standalone utility library with no external dependencies. It doesn't interact with other contracts directly but serves as a foundation that other contracts can build upon.</p> <p>Contracts that need to handle raw byte data extensively would benefit from using this library, including:</p> <ul> <li>Cross-chain bridges that process serialized messages</li> <li>Smart contracts dealing with cryptographic operations</li> <li>Contracts that need to parse or construct encoded data formats</li> <li>Any system working with raw transaction data or RLP encoding</li> </ul> <p>The primary interaction model is through Solidity's library linking system. Other contracts would import BytesLib using:</p> <pre><code>import \"./BytesLib.sol\";\n\ncontract MyContract {\n    using BytesLib for bytes;\n\n    function myFunction(bytes memory data) public {\n        bytes memory slice = data.slice(0, 32);\n        address extracted = data.toAddress(32);\n        // other operations...\n    }\n}\n</code></pre> <p>This linking allows the consuming contract to call BytesLib functions as if they were methods on the bytes arrays themselves.</p> <p>The extensive use of inline assembly makes BytesLib highly efficient but requires careful usage to avoid unintended consequences. The library includes checks to prevent common issues like out-of-bounds access, but developers using it should understand the underlying memory model to use it effectively.</p>"},{"location":"code/libraries/Endian/","title":"Endian","text":""},{"location":"code/libraries/Endian/#contract-overview","title":"Contract Overview","text":"<p>The Endian library is a specialized utility smart contract for handling endianness conversions in blockchain applications. Endianness refers to the order in which bytes are arranged in computer memory - either with the most significant byte first (big-endian) or the least significant byte first (little-endian). </p> <p>This library specifically focuses on converting little-endian formatted integers to big-endian format, which is essential when integrating with systems or data formats that use different endianness conventions. Such conversions are particularly important in cross-platform communication, cryptographic operations, and when handling binary data from external sources.</p> <p>The library follows a pure functional design pattern, containing only stateless utility functions that perform data transformations without modifying any state. This makes it highly reusable and gas-efficient, as it can be deployed once and used by multiple contracts.</p>"},{"location":"code/libraries/Endian/#contract-interface","title":"Contract Interface","text":""},{"location":"code/libraries/Endian/#functions","title":"Functions","text":"<p><code>fromLittleEndianUint64(bytes32 lenum)</code> - Purpose: Converts a 64-bit unsigned integer from little-endian format to big-endian format - Input: A bytes32 value containing the little-endian formatted number - Output: A uint64 value in big-endian format - Visibility: internal pure (can only be called from within the contract or from contracts that use this library)</p>"},{"location":"code/libraries/Endian/#state-variables","title":"State Variables","text":"<p>The library does not contain any state variables, making it completely stateless and gas-efficient for endianness conversion operations.</p>"},{"location":"code/libraries/Endian/#logic-flow","title":"Logic Flow","text":"<p>The <code>fromLittleEndianUint64</code> function performs the conversion through several bitwise operations:</p> <ol> <li> <p>Initial Extraction: The function first extracts the relevant 64 bits from the 256-bit input by right-shifting the input by 192 bits (<code>lenum &gt;&gt; 192</code>) and casting the result to a uint64.</p> </li> <li> <p>Byte Swapping: It then systematically swaps the positions of all 8 bytes of the uint64 value:</p> </li> <li>The most significant byte (bits 56-63) is moved to the least significant position</li> <li>The second most significant byte (bits 48-55) is moved to the second least significant position</li> <li> <p>And so on, until all 8 bytes have been reordered</p> </li> <li> <p>Bit Manipulation: This is accomplished through a series of bitwise AND (<code>&amp;</code>) operations to isolate each byte, combined with shifts (<code>&gt;&gt;</code> and <code>&lt;&lt;</code>) to move each byte to its new position, and finally bitwise OR (<code>|</code>) operations to combine all the reordered bytes.</p> </li> </ol> <p>This process effectively reverses the byte order, converting from little-endian to big-endian format.</p>"},{"location":"code/libraries/Endian/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Input: bytes32 little-endian value] --&gt; B[Extract uint64 from bytes32]\n    B --&gt; C[Isolate each byte with bitwise AND masks]\n    C --&gt; D[Shift bytes to new positions]\n    D --&gt; E[Combine reordered bytes with bitwise OR]\n    E --&gt; F[Output: uint64 big-endian value]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style F fill:#9ff,stroke:#333,stroke-width:2px</code></pre>"},{"location":"code/libraries/Endian/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The Endian library is a standalone utility that doesn't depend on other smart contracts. It serves as a dependency for other contracts in the system that need to handle endianness conversions, particularly when:</p> <ol> <li> <p>Interoperating with External Systems: When the blockchain application needs to communicate with external systems that use a different endianness convention.</p> </li> <li> <p>Processing Raw Binary Data: When handling binary data from external sources, especially in scenarios involving cryptographic operations, hashing functions, or low-level data manipulation.</p> </li> <li> <p>Cross-Chain Communication: When data needs to be formatted consistently across different blockchain platforms that might utilize different endianness standards.</p> </li> </ol> <p>The library's focused functionality makes it a useful building block in more complex systems where data format conversions are necessary. By centralizing this utility function in a library, the system ensures consistent endianness handling throughout the application while minimizing code duplication and potential conversion errors.</p>"},{"location":"code/libraries/Merkle/","title":"Merkle","text":""},{"location":"code/libraries/Merkle/#contract-overview","title":"Contract Overview","text":"<p>The Merkle library provides utility functions for working with Merkle trees in blockchain applications. Merkle trees are a fundamental data structure in blockchain technology that allow for efficient and secure verification of data integrity. This library, adapted from OpenZeppelin's MerkleProof contract, offers functionality for both verifying Merkle proofs and constructing Merkle trees.</p> <p>The primary purpose of this library is to: 1. Verify that a piece of data (a leaf) is part of a dataset without requiring the entire dataset 2. Support both keccak256 (Ethereum's default hash function) and SHA-256 hash algorithms 3. Enable the construction of Merkle trees from a set of leaves</p> <p>This library fits into blockchain systems that need to efficiently verify data without storing or transmitting complete datasets. Common use cases include: - Whitelists for token sales or NFT minting - Airdrops to specific addresses - State verification in Layer 2 scaling solutions - Efficient data verification across blockchain networks</p> <p>The contract follows the library design pattern, which means it contains reusable code that can be imported and used by other contracts without deploying the Merkle contract itself to the blockchain.</p>"},{"location":"code/libraries/Merkle/#contract-interface","title":"Contract Interface","text":""},{"location":"code/libraries/Merkle/#publicexternal-functions","title":"Public/External Functions","text":"<p>The library provides several key functions:</p> <ol> <li>verifyInclusionKeccak(bytes memory proof, bytes32 root, bytes32 leaf, uint256 index) \u2192 bool</li> <li>Verifies that a leaf is included in a Merkle tree with the given root using keccak256 hashing</li> <li> <p>Returns true if the proof is valid, false otherwise</p> </li> <li> <p>processInclusionProofKeccak(bytes memory proof, bytes32 leaf, uint256 index) \u2192 bytes32</p> </li> <li>Computes the Merkle root from a leaf and proof using keccak256 hashing</li> <li> <p>Returns the computed root which can be compared to the expected root</p> </li> <li> <p>verifyInclusionSha256(bytes memory proof, bytes32 root, bytes32 leaf, uint256 index) \u2192 bool</p> </li> <li>Verifies that a leaf is included in a Merkle tree with the given root using SHA-256 hashing</li> <li> <p>Returns true if the proof is valid, false otherwise</p> </li> <li> <p>processInclusionProofSha256(bytes memory proof, bytes32 leaf, uint256 index) \u2192 bytes32</p> </li> <li>Computes the Merkle root from a leaf and proof using SHA-256 hashing</li> <li> <p>Returns the computed root which can be compared to the expected root</p> </li> <li> <p>merkleizeSha256(bytes32[] memory leaves) \u2192 bytes32</p> </li> <li>Constructs a Merkle tree from a set of leaves using SHA-256 hashing</li> <li>Returns the Merkle root of the tree</li> </ol>"},{"location":"code/libraries/Merkle/#key-errors","title":"Key Errors","text":"<ul> <li>InvalidProofLength() - Custom error thrown when a provided Merkle proof has an invalid length</li> </ul>"},{"location":"code/libraries/Merkle/#notable-state-variables","title":"Notable State Variables","text":"<p>As a library, Merkle does not maintain state variables itself but operates on the data provided in function parameters.</p>"},{"location":"code/libraries/Merkle/#logic-flow","title":"Logic Flow","text":""},{"location":"code/libraries/Merkle/#merkle-proof-verification","title":"Merkle Proof Verification","text":"<p>The Merkle proof verification process follows these steps:</p> <ol> <li>Start with a leaf node and its index in the tree</li> <li>For each node in the proof:</li> <li>Determine if the current computed hash is a left or right sibling based on the current bit of the index</li> <li>If the current bit is 0, the computed hash is a left sibling</li> <li>If the current bit is 1, the computed hash is a right sibling</li> <li>Combine the computed hash with the current proof element in the correct order</li> <li>Hash the combined data using either keccak256 or SHA-256</li> <li>Update the index by dividing it by 2 (moving up one level in the tree)</li> <li>The final computed hash should match the Merkle root if the proof is valid</li> </ol> <p>Both keccak256 and SHA-256 implementations follow the same logical steps, but they differ in how the hash function is called. The keccak256 implementation uses Solidity's built-in hash function, while the SHA-256 implementation uses an assembly call to the SHA-256 precompiled contract (precompile address 2).</p>"},{"location":"code/libraries/Merkle/#merkle-tree-construction","title":"Merkle Tree Construction","text":"<p>The <code>merkleizeSha256</code> function constructs a Merkle tree from a set of leaves using these steps:</p> <ol> <li>Start with an array of leaf nodes</li> <li>Compute the parent nodes by hashing adjacent pairs of nodes</li> <li>Create a new layer with the parent nodes</li> <li>Repeat until only one node remains (the root)</li> <li>Return the root node</li> </ol> <p>An important precondition for this function is that the number of leaves must be a power of two. If this condition is not met, the function will still execute but may produce an incorrect Merkle root.</p>"},{"location":"code/libraries/Merkle/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Client Contract] --&gt;|\"1. Call verification with leaf, proof, root\"| B[Merkle Library]\n    B --&gt;|\"2. Process proof (keccak256 or SHA-256)\"| C{Computed Root == Expected Root?}\n    C --&gt;|\"3a. Yes\"| D[Return True - Proof Valid]\n    C --&gt;|\"3b. No\"| E[Return False - Proof Invalid]\n\n    F[Set of leaves] --&gt;|\"1. Call merkleizeSha256\"| G[Merkle Library]\n    G --&gt;|\"2. Compute pairwise hashes\"| H[Build Tree Bottom-up]\n    H --&gt;|\"3. Return Root\"| I[Merkle Root]</code></pre> <pre><code>sequenceDiagram\n    participant Contract as Client Contract\n    participant Merkle as Merkle Library\n\n    Note over Contract, Merkle: Verification Flow\n    Contract-&gt;&gt;Merkle: verifyInclusionKeccak(proof, root, leaf, index)\n    Merkle-&gt;&gt;Merkle: processInclusionProofKeccak(proof, leaf, index)\n    loop For each proof element\n        Merkle-&gt;&gt;Merkle: Determine if left or right sibling\n        Merkle-&gt;&gt;Merkle: Combine and hash with keccak256\n    end\n    Merkle-&gt;&gt;Contract: Return verification result (boolean)\n\n    Note over Contract, Merkle: Tree Construction Flow\n    Contract-&gt;&gt;Merkle: merkleizeSha256(leaves)\n    loop Until root is computed\n        Merkle-&gt;&gt;Merkle: Compute parent hashes using SHA-256\n        Merkle-&gt;&gt;Merkle: Move up one level in tree\n    end\n    Merkle-&gt;&gt;Contract: Return Merkle root</code></pre>"},{"location":"code/libraries/Merkle/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The Merkle library has minimal external dependencies:</p> <ol> <li> <p>Solidity Compiler (^0.8.0): The library requires Solidity version 0.8.0 or higher due to its use of custom errors and other language features.</p> </li> <li> <p>SHA-256 Precompiled Contract: The SHA-256 functions rely on the Ethereum precompiled contract at address 2, which provides an efficient implementation of the SHA-256 hash function.</p> </li> </ol> <p>The library is designed to be used by other contracts in a system. Typical integrations might include:</p> <ul> <li>Token Distribution Contracts: To verify claims against a whitelist</li> <li>Bridge Contracts: To verify state transitions between chains</li> <li>Governance Contracts: To efficiently verify voting rights</li> <li>Layer 2 Solutions: For compact state verification</li> </ul> <p>The library's functions are marked as <code>internal</code>, meaning they can only be called from contracts that include this library. This is a common pattern for utility libraries in Solidity, as it allows the compiler to inline the code for efficiency rather than making external calls.</p> <p>It's worth noting that the library includes a specific warning about avoiding 64-byte leaf values prior to hashing with keccak256, as this could lead to potential vulnerabilities where the concatenation of sorted internal nodes could be reinterpreted as a leaf value. The library recommends using OpenZeppelin's JavaScript library for generating Merkle trees that are safe against this attack.</p>"},{"location":"code/libraries/OperatorSetLib/","title":"OperatorSetLib","text":""},{"location":"code/libraries/OperatorSetLib/#contract-overview","title":"Contract Overview","text":"<p>OperatorSetLib is a utility library designed to manage the identification and encoding of operator sets in a blockchain system. An operator set represents a group of operators associated with an Active Validator Set (AVS) service, identified by a unique combination of the AVS address and a numeric identifier.</p> <p>The primary purpose of this contract is to provide standardized methods for: 1. Converting an operator set structure into a unique key for storage and reference 2. Decoding such keys back into their constituent parts</p> <p>This library appears to be part of a broader validator management system, likely supporting a Proof-of-Stake blockchain network or a similar consensus mechanism where validators (operators) are organized into sets for particular services.</p> <p>The design follows the library pattern in Solidity, which allows for reusable code that can be attached to specific data types. In this case, the library functions are attached to the OperatorSet struct globally, meaning any contract in the system can use these utility functions.</p>"},{"location":"code/libraries/OperatorSetLib/#contract-interface","title":"Contract Interface","text":""},{"location":"code/libraries/OperatorSetLib/#structs","title":"Structs","text":"<pre><code>struct OperatorSet {\n    address avs;    // The address of the AVS this operator set belongs to\n    uint32 id;      // The unique identifier for the operator set\n}\n</code></pre>"},{"location":"code/libraries/OperatorSetLib/#public-functions","title":"Public Functions","text":"<ul> <li>key(OperatorSet memory os) \u2192 bytes32</li> <li>Converts an OperatorSet structure into a unique 32-byte identifier</li> <li>This key can be used as a mapping key for storage or for cross-contract communication</li> <li> <p>Pure function that doesn't modify state</p> </li> <li> <p>decode(bytes32 _key) \u2192 OperatorSet memory</p> </li> <li>Extracts the original AVS address and ID from an encoded key</li> <li>Returns the reconstructed OperatorSet structure</li> <li>Pure function that doesn't modify state</li> </ul>"},{"location":"code/libraries/OperatorSetLib/#state-variables","title":"State Variables","text":"<p>This contract is a library and does not maintain any state variables itself. It operates purely on the data provided to it.</p>"},{"location":"code/libraries/OperatorSetLib/#logic-flow","title":"Logic Flow","text":""},{"location":"code/libraries/OperatorSetLib/#key-generation-process","title":"Key Generation Process","text":"<ol> <li>The <code>key()</code> function takes an OperatorSet structure as input</li> <li>It uses <code>abi.encodePacked()</code> to tightly pack the AVS address and ID together</li> <li>The packed data is cast to bytes32, creating a standardized format for the key</li> <li>This key uniquely represents the specific operator set in the system</li> </ol>"},{"location":"code/libraries/OperatorSetLib/#decoding-process","title":"Decoding Process","text":"<ol> <li>The <code>decode()</code> function takes a bytes32 key as input</li> <li>It extracts the AVS address by:</li> <li>Interpreting the key as a uint256</li> <li>Shifting right by 96 bits to isolate the address portion</li> <li>Converting to an address (uint160)</li> <li>It extracts the ID by:</li> <li>Applying a bitwise AND with the maximum uint96 value to isolate the ID portion</li> <li>Converting to uint32</li> <li>It constructs and returns a new OperatorSet structure with these extracted values</li> </ol> <p>This approach efficiently packs two pieces of information (address and ID) into a single storage slot, optimizing for gas efficiency.</p>"},{"location":"code/libraries/OperatorSetLib/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart LR\n    OperatorSet[\"OperatorSet\\navs: address\\nid: uint32\"] \n\n    subgraph OperatorSetLib\n        KeyFunction[\"key()\\nConverts to bytes32\"]\n        DecodeFunction[\"decode()\\nExtracts from bytes32\"]\n    end\n\n    OperatorSet --&gt;|Input| KeyFunction\n    KeyFunction --&gt;|Output| EncodedKey[\"bytes32 key\"]\n    EncodedKey --&gt;|Input| DecodeFunction\n    DecodeFunction --&gt;|Output| OperatorSet\n\n    ExternalContracts[\"External Contracts\"] -.-&gt;|Uses key for storage/reference| EncodedKey</code></pre>"},{"location":"code/libraries/OperatorSetLib/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The library is designed to be used by other contracts in the system through the global directive:</p> <pre><code>using OperatorSetLib for OperatorSet global;\n</code></pre> <p>This means any contract in the system can call these utility functions directly on OperatorSet instances.</p> <p>While this library itself has minimal dependencies (only using basic Solidity functionality), it likely serves as a foundation for other contracts in the system that:</p> <ol> <li>Manage validator registrations</li> <li>Handle staking and delegation</li> <li>Coordinate operator responsibilities</li> <li>Track performance and rewards</li> </ol> <p>The compact key representation is particularly useful for: - Gas-efficient storage in mappings - Cross-contract communication where a compact identifier is beneficial - Event emissions where a single parameter can represent the full operator set identity</p> <p>The choice to separate this functionality into a library demonstrates good software engineering practices, keeping the code modular and promoting reuse across the broader system.</p>"},{"location":"code/libraries/SlashingLib/","title":"SlashingLib","text":""},{"location":"code/libraries/SlashingLib/#1-contract-overview","title":"1. Contract Overview","text":"<p>SlashingLib is a utility library designed to handle the conversion and scaling of shares in a staking system that supports slashing penalties. This library is a critical component of a delegated staking protocol where:</p> <ol> <li>Stakers can deposit tokens into strategies</li> <li>Operators can have delegated stakes from multiple stakers</li> <li>The protocol needs to enforce slashing penalties for misbehaving operators</li> </ol> <p>The primary purpose of this library is to maintain proper accounting of shares when slashing occurs, ensuring that penalties are applied fairly and accurately across all affected stakeholders.</p> <p>The library uses a \"deposit scaling factor\" mechanism to differentiate between deposit shares (what users actually deposit) and withdrawable shares (what users can actually withdraw after accounting for slashing). This design pattern allows the protocol to maintain proper accounting of shares even when operators suffer slashing penalties, without having to modify everyone's deposit records.</p> <p>Key design patterns employed include: - Fixed-point arithmetic (WAD) for precise calculations - Storage structures that track scaling factors instead of repeatedly calculating values - Pure mathematical functions that handle the complex scaling logic</p>"},{"location":"code/libraries/SlashingLib/#2-contract-interface","title":"2. Contract Interface","text":""},{"location":"code/libraries/SlashingLib/#state-variables","title":"State Variables","text":"<ul> <li><code>WAD</code> (constant): Represents the scaling base of 10^18, used for fixed-point arithmetic to maintain precision.</li> </ul>"},{"location":"code/libraries/SlashingLib/#structs","title":"Structs","text":"<ul> <li><code>DepositScalingFactor</code>: Contains a single field <code>_scalingFactor</code> that tracks the conversion rate between deposit shares and withdrawable shares.</li> </ul>"},{"location":"code/libraries/SlashingLib/#key-functions","title":"Key Functions","text":""},{"location":"code/libraries/SlashingLib/#getters","title":"Getters","text":"<ul> <li><code>scalingFactor(DepositScalingFactor)</code>: Returns the current scaling factor, defaulting to WAD (1e18) if not set.</li> <li><code>scaleForQueueWithdrawal(DepositScalingFactor, uint256)</code>: Scales deposit shares for the withdrawal queue.</li> <li><code>scaleForCompleteWithdrawal(uint256, uint256)</code>: Scales shares for completing a withdrawal, applying the slashing factor.</li> <li><code>scaleForBurning(uint256, uint64, uint64)</code>: Calculates shares to burn based on magnitude changes.</li> </ul>"},{"location":"code/libraries/SlashingLib/#state-changing-functions","title":"State-Changing Functions","text":"<ul> <li><code>update(DepositScalingFactor, uint256, uint256, uint256)</code>: Updates the deposit scaling factor when adding shares.</li> <li><code>reset(DepositScalingFactor)</code>: Resets the scaling factor to the default value.</li> </ul>"},{"location":"code/libraries/SlashingLib/#conversion-functions","title":"Conversion Functions","text":"<ul> <li><code>calcWithdrawable(DepositScalingFactor, uint256, uint256)</code>: Calculates withdrawable shares from deposit shares.</li> <li><code>calcDepositShares(DepositScalingFactor, uint256, uint256)</code>: Calculates deposit shares from withdrawable shares.</li> <li><code>calcSlashedAmount(uint256, uint256, uint256)</code>: Calculates the amount of shares to slash.</li> </ul>"},{"location":"code/libraries/SlashingLib/#wad-math-utilities","title":"WAD Math Utilities","text":"<ul> <li><code>mulWad(uint256, uint256)</code>: Multiplies two numbers and divides by WAD.</li> <li><code>divWad(uint256, uint256)</code>: Divides a number by another and multiplies by WAD.</li> <li><code>mulWadRoundUp(uint256, uint256)</code>: Like mulWad but rounds up to prevent zero-slashing.</li> </ul>"},{"location":"code/libraries/SlashingLib/#3-logic-flow","title":"3. Logic Flow","text":""},{"location":"code/libraries/SlashingLib/#share-conversion-flow","title":"Share Conversion Flow","text":"<ol> <li>Initial Deposit</li> <li>When a staker first deposits or delegates to an operator, the deposit scaling factor is initialized based on the current slashing factor.</li> <li> <p>This scaling factor will be used for all conversions between deposit shares and withdrawable shares.</p> </li> <li> <p>Subsequent Deposits</p> </li> <li>For additional deposits, the deposit scaling factor is recalculated to account for both existing shares and the new shares.</li> <li> <p>The calculation ensures that the staker's share of any past slashing penalties is maintained proportionally.</p> </li> <li> <p>Withdrawal Process</p> </li> <li> <p>When a user wants to withdraw:</p> <ul> <li>First, deposit shares are converted to withdrawable shares using the deposit scaling factor</li> <li>Then, withdrawable shares are converted back to underlying tokens (this happens outside this library)</li> </ul> </li> <li> <p>Slashing Event</p> </li> <li>When an operator is slashed:<ul> <li>The protocol updates the slashing factor for that operator</li> <li>All stakers delegated to that operator will have their withdrawable shares reduced when they try to withdraw</li> <li>The deposit scaling factor ensures that slashing is applied proportionally</li> </ul> </li> </ol>"},{"location":"code/libraries/SlashingLib/#key-algorithms","title":"Key Algorithms","text":"<p>The core mathematical relationship maintained by this library is: <pre><code>withdrawableShares = depositShares * depositScalingFactor * slashingFactor\n</code></pre></p> <p>This formula is crucial for allowing the system to: 1. Track what a user originally deposited 2. Apply cumulative slashing penalties 3. Calculate the correct amount that can be withdrawn</p> <p>The <code>update</code> function uses a complex calculation to ensure that when users add more shares to an existing deposit, the deposit scaling factor is adjusted correctly to maintain the proper proportion of withdrawable shares.</p>"},{"location":"code/libraries/SlashingLib/#4-visual-representation","title":"4. Visual Representation","text":"<pre><code>flowchart TD\n    A[User Deposit] --&gt; B{First Deposit?}\n    B --&gt;|Yes| C[Initialize DepositScalingFactor\\nDSF = WAD/slashingFactor]\n    B --&gt;|No| D[Calculate new DSF based on\\nexisting and new shares]\n\n    E[User Withdrawal Request] --&gt; F[Convert deposit shares to withdrawable shares\\nwithdrawableShares = depositShares * DSF * slashingFactor]\n\n    G[Operator Slashed] --&gt; H[Update operator's slashing factor]\n    H --&gt; I[Affected withdrawals will receive fewer tokens]\n\n    J[User Undelegates] --&gt; K[Reset DSF to default]\n    K --&gt; L[Future deposits start fresh]</code></pre>"},{"location":"code/libraries/SlashingLib/#5-dependencies-and-interactions","title":"5. Dependencies and Interactions","text":"<p>The library imports and depends on: - <code>@openzeppelin/contracts/utils/math/Math.sol</code> - For precise mathematical operations - <code>@openzeppelin-upgrades/contracts/utils/math/SafeCastUpgradeable.sol</code> - For safe type conversions</p> <p>This library is designed to be used by multiple other contracts in the system, specifically: 1. Strategy Manager - For tracking deposit shares in different strategies 2. EigenPodManager - For handling delegation of staked ETH 3. Withdrawal Queue - For processing withdrawal requests with appropriate slashing applied</p> <p>While the library itself doesn't directly interact with these contracts, it provides the mathematical foundation for maintaining the relationship between deposit shares and withdrawable shares throughout the system, especially when slashing penalties are applied.</p> <p>The library handles the complex mathematical calculations related to slashing, so that other contracts in the system can focus on their specific responsibilities, making the overall architecture more modular and easier to maintain.</p>"},{"location":"code/libraries/Snapshots/","title":"Snapshots","text":""},{"location":"code/libraries/Snapshots/#contract-overview","title":"Contract Overview","text":"<p>The <code>Snapshots.sol</code> contract is a specialized library designed to record and retrieve historical values at different points in time. It serves as a mechanism for creating checkpoints of data values, allowing contracts to track how values change over time and query past values based on block numbers.</p>"},{"location":"code/libraries/Snapshots/#purpose-and-main-functionality","title":"Purpose and Main Functionality","text":"<p>This library is primarily used for maintaining historical records of values that change throughout the lifecycle of a contract. It enables: - Recording new values at specific points in time (blocks) - Looking up historical values based on a specific point in time - Retrieving the most recent recorded value</p>"},{"location":"code/libraries/Snapshots/#architectural-role","title":"Architectural Role","text":"<p>Based on the context provided, this library appears to be a core component in a governance or staking system. It's particularly used for: 1. Tracking allocation values in an <code>AllocationManager</code> contract 2. Managing delegation shares in a <code>DelegationManager</code> contract</p> <p>The library supports two default value behaviors through separate data structures: 1. <code>DefaultWadHistory</code>: Uses WAD (10^18) as the default value when no snapshots exist 2. <code>DefaultZeroHistory</code>: Uses 0 as the default value when no snapshots exist</p>"},{"location":"code/libraries/Snapshots/#key-design-patterns","title":"Key Design Patterns","text":"<ol> <li>Library Pattern: Implemented as a reusable library that can be imported by other contracts</li> <li>Snapshot Pattern: Records historical values with associated keys (typically block numbers)</li> <li>Binary Search Algorithm: Uses binary search for efficient lookups in the historical data</li> <li>Type Safety: Provides separate structs for different default value behaviors</li> <li>Gas Optimization: Uses assembly for direct storage access in critical functions</li> </ol>"},{"location":"code/libraries/Snapshots/#contract-interface","title":"Contract Interface","text":""},{"location":"code/libraries/Snapshots/#key-state-variables","title":"Key State Variables","text":"<p>The library defines structured types to store historical data:</p> <ol> <li> <p>DefaultWadHistory and DefaultZeroHistory:    <pre><code>struct DefaultWadHistory {\n    Snapshot[] _snapshots;\n}\n\nstruct DefaultZeroHistory {\n    Snapshot[] _snapshots;\n}\n</code></pre>    These are the main data structures that store an array of snapshots with different default values.</p> </li> <li> <p>Snapshot:    <pre><code>struct Snapshot {\n    uint32 _key;\n    uint224 _value;\n}\n</code></pre>    Each snapshot contains a key (typically a block number) and a value representing the state at that point in time.</p> </li> </ol>"},{"location":"code/libraries/Snapshots/#publicexternal-functions","title":"Public/External Functions","text":"<ol> <li><code>push</code>:</li> <li>Records a new snapshot with the provided key and value</li> <li>Overloaded to work with both <code>DefaultWadHistory</code> and <code>DefaultZeroHistory</code></li> <li> <p>If a snapshot with the same key already exists, it updates the value instead</p> </li> <li> <p><code>upperLookup</code>:</p> </li> <li>Retrieves the value from the most recent snapshot with a key less than or equal to the provided key</li> <li> <p>Returns the appropriate default value (WAD or 0) if no such snapshot exists</p> </li> <li> <p><code>latest</code>:</p> </li> <li>Returns the value from the most recent snapshot</li> <li> <p>Returns the appropriate default value (WAD or 0) if no snapshots exist</p> </li> <li> <p><code>length</code>:</p> </li> <li>Returns the number of snapshots in the history</li> </ol>"},{"location":"code/libraries/Snapshots/#important-events","title":"Important Events","text":"<p>The library does not emit any events directly, which is typical for library contracts in Solidity.</p>"},{"location":"code/libraries/Snapshots/#logic-flow","title":"Logic Flow","text":""},{"location":"code/libraries/Snapshots/#recording-a-new-snapshot","title":"Recording a New Snapshot","text":"<ol> <li>When <code>push</code> is called with a key and value:</li> <li>The library first checks if the snapshots array already contains entries</li> <li>If entries exist, it verifies that the new key is greater than or equal to the last recorded key</li> <li>If the key matches the most recent snapshot, it updates the value of that snapshot</li> <li>Otherwise, it adds a new snapshot to the array with the provided key and value</li> </ol>"},{"location":"code/libraries/Snapshots/#looking-up-historical-values","title":"Looking Up Historical Values","text":"<ol> <li>When <code>upperLookup</code> is called with a key:</li> <li>The library performs a binary search to find the snapshot with the highest key that is less than or equal to the provided key</li> <li>If no such snapshot exists, it returns the default value (WAD or 0, depending on the history type)</li> <li>Otherwise, it returns the value from the found snapshot</li> </ol>"},{"location":"code/libraries/Snapshots/#retrieving-the-latest-value","title":"Retrieving the Latest Value","text":"<ol> <li>When <code>latest</code> is called:</li> <li>The library checks if any snapshots exist</li> <li>If none exist, it returns the default value (WAD or 0, depending on the history type)</li> <li>Otherwise, it returns the value from the most recent snapshot</li> </ol>"},{"location":"code/libraries/Snapshots/#security-mechanisms","title":"Security Mechanisms","text":"<ol> <li>Input Validation:</li> <li>The library ensures that keys are added in a non-decreasing order to maintain the integrity of the binary search</li> <li> <p>It uses a custom error <code>InvalidSnapshotOrdering</code> to revert if this condition is violated</p> </li> <li> <p>Type Safety:</p> </li> <li>The library uses separate structs to distinguish between different default behaviors</li> <li> <p>It handles type conversion explicitly, though it notes that responsibility for safe conversions falls outside the library</p> </li> <li> <p>Gas Optimization:</p> </li> <li>Uses assembly for direct storage access to reduce gas costs</li> <li>Implements binary search for efficient lookups in potentially large snapshot arrays</li> </ol>"},{"location":"code/libraries/Snapshots/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Contract Using Snapshots] --&gt;|push| B[Record New Snapshot]\n    A --&gt;|upperLookup| C[Find Historical Value]\n    A --&gt;|latest| D[Get Most Recent Value]\n\n    B --&gt;|Check if key exists| E{Key already exists?}\n    E --&gt;|Yes| F[Update existing snapshot]\n    E --&gt;|No| G[Add new snapshot]\n\n    C --&gt;|Binary search| H{Snapshot found?}\n    H --&gt;|Yes| I[Return snapshot value]\n    H --&gt;|No| J[Return default value]\n\n    D --&gt;|Check snapshots length| K{Snapshots exist?}\n    K --&gt;|Yes| L[Return latest value]\n    K --&gt;|No| M[Return default value]\n\n    subgraph \"Snapshot Storage\"\n        N[DefaultWadHistory] \n        O[DefaultZeroHistory]\n    end</code></pre>"},{"location":"code/libraries/Snapshots/#dependencies-and-interactions","title":"Dependencies and Interactions","text":""},{"location":"code/libraries/Snapshots/#external-dependencies","title":"External Dependencies","text":"<ol> <li>OpenZeppelin's MathUpgradeable:</li> <li>Imported from <code>@openzeppelin-upgrades/contracts/utils/math/MathUpgradeable.sol</code></li> <li> <p>Used for safe mathematical operations, specifically the <code>average</code> function in binary search</p> </li> <li> <p>SlashingLib:</p> </li> <li>Imported from <code>./SlashingLib.sol</code></li> <li>Though imported, it doesn't appear to be directly used within this file, suggesting this library is part of a broader slashing mechanism</li> </ol>"},{"location":"code/libraries/Snapshots/#contract-interactions","title":"Contract Interactions","text":"<p>Based on the provided comments and function names, this library interacts with:</p> <ol> <li>AllocationManager:</li> <li>Uses <code>DefaultWadHistory</code> for tracking maximum magnitudes</li> <li> <p>Default value is WAD (10^18)</p> </li> <li> <p>DelegationManager:</p> </li> <li>Uses <code>DefaultZeroHistory</code> for tracking cumulative scaled shares</li> <li>Default value is 0</li> </ol> <p>The library is designed as a flexible component that can be used by any contract needing to track historical values, particularly in staking, delegation, or governance systems where historical state is important for calculations like rewards, voting power, or slashing penalties.</p> <p>Overall, the <code>Snapshots</code> library provides an efficient and flexible mechanism for recording and retrieving historical data, which is crucial for many complex DeFi and governance protocols that need to reference past states for current calculations.</p>"},{"location":"code/mixins/PermissionControllerMixin/","title":"PermissionControllerMixin","text":""},{"location":"code/mixins/PermissionControllerMixin/#contract-overview","title":"Contract Overview","text":"<p>The <code>PermissionControllerMixin</code> is an abstract contract that provides permission management functionality to contracts that inherit from it. Its primary purpose is to provide a standardized way to verify whether a caller has the necessary permissions to execute functions on behalf of another account. </p> <p>This contract serves as a reusable component in a permission management architecture, allowing inheriting contracts to delegate permission checks to a central permission controller. It implements a pattern similar to the proxy authorization pattern, where one address can be authorized to act on behalf of another.</p> <p>The contract follows the \"mixin\" design pattern, which provides modular functionality that can be easily incorporated into other contracts through inheritance. This approach promotes code reusability and separation of concerns across the system.</p>"},{"location":"code/mixins/PermissionControllerMixin/#contract-interface","title":"Contract Interface","text":""},{"location":"code/mixins/PermissionControllerMixin/#state-variables","title":"State Variables","text":"<ul> <li>permissionController: An immutable public variable that references the <code>IPermissionController</code> interface implementation. This central contract handles all permission validations.</li> </ul>"},{"location":"code/mixins/PermissionControllerMixin/#functions","title":"Functions","text":"<ul> <li>_checkCanCall(address account): An internal function that determines whether the current message sender (<code>msg.sender</code>) is authorized to call a function on behalf of the specified account. Returns a boolean result rather than reverting on failure.</li> </ul>"},{"location":"code/mixins/PermissionControllerMixin/#modifiers","title":"Modifiers","text":"<ul> <li>checkCanCall(address account): A modifier that uses <code>_checkCanCall</code> to verify permissions and reverts with <code>InvalidPermissions()</code> error if the check fails.</li> </ul>"},{"location":"code/mixins/PermissionControllerMixin/#events","title":"Events","text":"<ul> <li>The contract does not emit any events itself, though the referenced permission controller might.</li> </ul>"},{"location":"code/mixins/PermissionControllerMixin/#errors","title":"Errors","text":"<ul> <li>InvalidPermissions(): Custom error thrown when the caller does not have the required permissions to act on behalf of an account.</li> </ul>"},{"location":"code/mixins/PermissionControllerMixin/#logic-flow","title":"Logic Flow","text":"<p>The permission validation flow works as follows:</p> <ol> <li>A contract that inherits from <code>PermissionControllerMixin</code> applies the <code>checkCanCall</code> modifier to functions that require permission checks.</li> <li>When such a function is called, the modifier executes before the function body.</li> <li>The modifier calls the <code>_checkCanCall</code> internal function, passing the account address for which the caller claims to act.</li> <li><code>_checkCanCall</code> forwards this request to the external permission controller by calling <code>canCall</code> on the <code>permissionController</code> interface.</li> <li>It passes four parameters to the permission controller:</li> <li>The account being acted on behalf of</li> <li>The actual caller (<code>msg.sender</code>)</li> <li>The address of the current contract (<code>address(this)</code>)</li> <li>The function signature (<code>msg.sig</code>)</li> <li>The permission controller evaluates these parameters according to its rules and returns a boolean result.</li> <li>If the result is <code>true</code>, the function execution continues; if <code>false</code>, the transaction reverts with the <code>InvalidPermissions()</code> error.</li> </ol> <p>This design allows for flexible and centralized permission management since the actual rules for determining permissions are implemented in the separate permission controller contract.</p>"},{"location":"code/mixins/PermissionControllerMixin/#visual-representation","title":"Visual Representation","text":"<pre><code>sequenceDiagram\n    actor User\n    participant DerivedContract as Contract inheriting PermissionControllerMixin\n    participant Mixin as PermissionControllerMixin\n    participant Controller as IPermissionController\n\n    User-&gt;&gt;DerivedContract: call function with checkCanCall modifier\n    DerivedContract-&gt;&gt;Mixin: checkCanCall(accountToActFor)\n    Mixin-&gt;&gt;Mixin: _checkCanCall(accountToActFor)\n    Mixin-&gt;&gt;Controller: canCall(accountToActFor, msg.sender, address(this), msg.sig)\n    Controller--&gt;&gt;Mixin: return true/false\n\n    alt Permission Granted\n        Mixin--&gt;&gt;DerivedContract: continue execution\n        DerivedContract--&gt;&gt;User: function result\n    else Permission Denied\n        Mixin--&gt;&gt;User: revert with InvalidPermissions()\n    end</code></pre>"},{"location":"code/mixins/PermissionControllerMixin/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The contract has one critical external dependency:</p> <ul> <li>IPermissionController: An interface that defines the contract responsible for determining permissions. The actual implementation of this interface is passed to the constructor during initialization, establishing a permanent connection to the permission management system.</li> </ul> <p>The interaction between <code>PermissionControllerMixin</code> and the permission controller is one-way: the mixin queries the controller, but the controller does not call back to the mixin. This creates a clean separation where permission logic can evolve independently from the contracts that use it.</p> <p>The contract is designed to be inherited by other contracts that need permission management functionality. By inheriting this mixin, contracts gain access to standardized permission checks without having to implement the logic themselves. This approach ensures consistent permission handling across the system while maintaining modularity.</p> <p>The actual permission rules and logic are implemented in the permission controller contract, which is not shown in this code. This separation allows the permission system to be updated or replaced without changing the contracts that rely on it, as long as the interface remains consistent.</p>"},{"location":"code/mixins/SemVerMixin/","title":"SemVerMixin","text":""},{"location":"code/mixins/SemVerMixin/#contract-overview","title":"Contract Overview","text":"<p>The <code>SemVerMixin</code> contract is a reusable abstract contract that provides semantic versioning functionality for other smart contracts in the system. Its primary purpose is to standardize version tracking across the protocol, allowing contracts to maintain and expose their version information in a consistent format that follows the SemVer 2.0.0 specification.</p> <p>This mixin exists as part of a modular contract architecture where it can be inherited by other contracts that need to expose their version information. The contract uses the gas-efficient <code>ShortString</code> data structure from OpenZeppelin's upgradeable contracts library to store version strings with minimal gas costs.</p> <p>Key design patterns used: - Mixin Pattern: Provides specific functionality that can be combined with other contracts - Immutability: The version is set once at construction time and cannot be changed - Inheritance: Implements the <code>ISemVerMixin</code> interface, allowing for consistent interface across the protocol</p>"},{"location":"code/mixins/SemVerMixin/#contract-interface","title":"Contract Interface","text":""},{"location":"code/mixins/SemVerMixin/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li><code>version()</code>: A public view function that returns the full semantic version string of the contract (e.g., \"v1.2.3\"). This function is virtual, meaning inheriting contracts can override its behavior if needed.</li> </ul>"},{"location":"code/mixins/SemVerMixin/#key-state-variables","title":"Key State Variables","text":"<ul> <li><code>_VERSION</code>: An immutable internal <code>ShortString</code> variable that stores the contract's semantic version in a gas-efficient manner. This variable is set during contract construction and cannot be changed afterward.</li> </ul>"},{"location":"code/mixins/SemVerMixin/#internal-functions","title":"Internal Functions","text":"<ul> <li><code>_majorVersion()</code>: An internal view function that extracts and returns just the major version portion (e.g., \"v1\" from \"v1.2.3\") from the full version string.</li> </ul>"},{"location":"code/mixins/SemVerMixin/#logic-flow","title":"Logic Flow","text":"<p>The contract has a straightforward workflow:</p> <ol> <li>Initialization:</li> <li>During contract deployment, the constructor accepts a version string parameter (e.g., \"v1.2.3\").</li> <li> <p>It converts this string to a gas-efficient <code>ShortString</code> format and stores it in the immutable <code>_VERSION</code> variable.</p> </li> <li> <p>Version Retrieval:</p> </li> <li>When external contracts or users call the <code>version()</code> function, it converts the stored <code>ShortString</code> back to a regular string and returns it.</li> <li>If needed, internal contract logic can retrieve only the major version using the <code>_majorVersion()</code> function, which parses the first two characters from the version string (e.g., \"v1\").</li> </ol> <p>The design ensures that version information is: - Stored in a gas-efficient manner - Immutable once set - Accessible through a standard interface - Follows the SemVer 2.0.0 specification format</p>"},{"location":"code/mixins/SemVerMixin/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Contract Deployment] --&gt;|Constructor called with version string| B[Store version as ShortString]\n    B --&gt; C[Immutable _VERSION set]\n\n    D[External Call to version\\(\\)] --&gt; E[Convert _VERSION to string]\n    E --&gt; F[Return version string]\n\n    G[Internal Call to _majorVersion\\(\\)] --&gt; H[Parse first two chars from version]\n    H --&gt; I[Return major version string]\n\n    J[Inheriting Contract] --&gt;|Extends| K[SemVerMixin]\n    K --&gt;|Provides| L[Standardized version tracking]</code></pre>"},{"location":"code/mixins/SemVerMixin/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The <code>SemVerMixin</code> contract has the following dependencies:</p> <ol> <li> <p>ISemVerMixin Interface: The contract implements this interface, which standardizes the version-related functionality across the protocol. This ensures that all contracts exposing version information do so in a consistent manner.</p> </li> <li> <p>OpenZeppelin ShortStringsUpgradeable: The contract imports and utilizes OpenZeppelin's <code>ShortStringsUpgradeable</code> library to efficiently store string data. This optimization is important because storing strings on the blockchain can be expensive in terms of gas costs. The <code>ShortString</code> data type is used to store strings of up to 31 bytes directly in a single storage slot, significantly reducing gas costs compared to regular string storage.</p> </li> </ol> <p>The <code>SemVerMixin</code> is designed to interact with other contracts through inheritance. Any contract in the system that needs to expose version information would inherit from this mixin, ensuring that version tracking is consistent across the entire protocol. This approach promotes:</p> <ul> <li>Standardization: All contracts handle versioning in the same way</li> <li>Gas Efficiency: All contracts benefit from the optimized storage approach</li> <li>Maintainability: Changes to version handling can be made in one place</li> <li>Compatibility: External systems can reliably interact with the versioning information</li> </ul> <p>The version tracking can be particularly useful for: - On-chain governance processes that need to verify contract versions - Protocol upgrades where version compatibility needs to be checked - Auditing and tracking deployed contract versions in production systems</p>"},{"location":"code/mixins/SignatureUtilsMixin/","title":"SignatureUtilsMixin","text":""},{"location":"code/mixins/SignatureUtilsMixin/#contract-overview","title":"Contract Overview","text":"<p>The <code>SignatureUtilsMixin</code> contract is a foundational utility component designed to standardize and simplify signature validation across the EigenLayer protocol. It implements the EIP-712 and EIP-1271 signature standards, providing a secure and consistent way to validate signatures from both Externally Owned Accounts (EOAs) and smart contracts.</p> <p>This contract serves as a mixin, meaning it's meant to be inherited by other contracts within the EigenLayer ecosystem that require signature validation capabilities. By centralizing signature validation logic, it ensures consistent security practices and reduces code duplication across the protocol.</p> <p>The contract leverages the semantic versioning pattern through its integration with <code>SemVerMixin</code>, enabling version-aware signature validation that maintains compatibility across minor updates while providing clear boundaries for breaking changes.</p>"},{"location":"code/mixins/SignatureUtilsMixin/#contract-interface","title":"Contract Interface","text":""},{"location":"code/mixins/SignatureUtilsMixin/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li><code>domainSeparator()</code> - Returns the EIP-712 domain separator used for creating typed data signatures. The domain separator includes the protocol name (\"EigenLayer\"), the major version, chain ID, and contract address to create a unique identifier for signatures in this domain.</li> </ul>"},{"location":"code/mixins/SignatureUtilsMixin/#key-state-variables","title":"Key State Variables","text":"<p>While the contract doesn't explicitly declare state variables, it inherits version information from <code>SemVerMixin</code> that influences the domain separator calculation.</p>"},{"location":"code/mixins/SignatureUtilsMixin/#internal-helper-functions","title":"Internal Helper Functions","text":"<ul> <li><code>_calculateSignableDigest(bytes32 hash)</code> - Creates a complete EIP-712 compliant digest by combining the domain separator with a structured data hash.</li> <li><code>_checkIsValidSignatureNow(address signer, bytes32 signableDigest, bytes memory signature, uint256 expiry)</code> - Validates a signature against a specific signer, checking both validity and expiration.</li> </ul>"},{"location":"code/mixins/SignatureUtilsMixin/#error-conditions","title":"Error Conditions","text":"<ul> <li><code>SignatureExpired()</code> - Thrown when attempting to verify a signature that has passed its expiration timestamp.</li> <li><code>InvalidSignature()</code> - Thrown when a signature doesn't match the expected signer or fails validation.</li> </ul>"},{"location":"code/mixins/SignatureUtilsMixin/#logic-flow","title":"Logic Flow","text":"<p>The signature validation process in this contract follows a well-defined flow:</p> <ol> <li> <p>Domain Separator Creation: The contract establishes a unique domain identifier using the protocol name, major version, chain ID, and contract address as specified in EIP-712.</p> </li> <li> <p>Digest Creation: When preparing a message for signature verification, the contract creates a signable digest by combining:</p> </li> <li>The EIP-712 prefix (<code>\\x19\\x01</code>)</li> <li>The domain separator</li> <li> <p>The hash of the typed data being signed</p> </li> <li> <p>Signature Validation: When validating a signature, the contract:</p> </li> <li>First checks if the signature has expired by comparing the provided expiry timestamp with the current block time</li> <li> <p>Then validates the signature using OpenZeppelin's <code>isValidSignatureNow</code> function which:</p> <ul> <li>For EOAs, performs standard ECDSA signature recovery and verification</li> <li>For smart contract signers, calls the EIP-1271 <code>isValidSignature</code> method on the signing contract</li> </ul> </li> <li> <p>Version Handling: The contract uses only the major version component (e.g., \"v1\" from \"v1.2.3\") for the domain separator, ensuring signature compatibility across minor and patch updates.</p> </li> </ol>"},{"location":"code/mixins/SignatureUtilsMixin/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Caller Contract] --&gt;|Inherits| B[SignatureUtilsMixin]\n    B --&gt;|Inherits| C[SemVerMixin]\n\n    D[EOA or Contract] --&gt;|Signs Message| E[EIP-712 Typed Data]\n    E --&gt;|Hash| F[Typed Data Hash]\n\n    B --&gt;|Uses| G[DomainSeparator]\n    G --&gt;|Includes| H[\"Protocol Name ('EigenLayer')\"]\n    G --&gt;|Includes| I[Major Version]\n    G --&gt;|Includes| J[Chain ID]\n    G --&gt;|Includes| K[Contract Address]\n\n    F --&gt;|Combined with| G\n    F --&gt;|_calculateSignableDigest| L[Complete Digest]\n\n    M[Signature] --&gt;|Validate| N[_checkIsValidSignatureNow]\n    L --&gt;|Input to| N\n    N --&gt;|Check| O[Expiry]\n    N --&gt;|Verify| P[Signature Validity]\n\n    P --&gt;|For EOAs| Q[ECDSA Verification]\n    P --&gt;|For Contracts| R[EIP-1271 Call]\n\n    N --&gt;|Result| S[Valid Signature] \n    N --&gt;|or| T[Revert with Error]</code></pre>"},{"location":"code/mixins/SignatureUtilsMixin/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The <code>SignatureUtilsMixin</code> relies on several key dependencies:</p> <ol> <li>OpenZeppelin Libraries:</li> <li><code>ShortStringsUpgradeable</code> - Provides utilities for working with compact string representations</li> <li> <p><code>SignatureCheckerUpgradeable</code> - Implements signature verification logic for both EOAs and contracts (EIP-1271)</p> </li> <li> <p>Interface Implementation:</p> </li> <li> <p><code>ISignatureUtilsMixin</code> - The interface that defines the contract's public functionality</p> </li> <li> <p>Inherited Contracts:</p> </li> <li><code>SemVerMixin</code> - Provides semantic versioning capabilities, allowing the contract to maintain version awareness</li> </ol> <p>This contract serves as a building block for other EigenLayer contracts that need signature validation. As a mixin, it's designed to be inherited rather than interacted with directly. Contracts inheriting from <code>SignatureUtilsMixin</code> gain access to robust signature validation tools while maintaining consistent security practices across the protocol.</p> <p>The primary design choice of using the major version component for the domain separator is particularly noteworthy, as it allows the protocol to make non-breaking changes (minor and patch updates) without invalidating existing signatures, while still providing a clean break for major version changes that might alter the signature scheme.</p>"},{"location":"code/permissions/Pausable/","title":"Pausable","text":""},{"location":"code/permissions/Pausable/#1-contract-overview","title":"1. Contract Overview","text":"<p>The <code>Pausable</code> contract is a foundational security component that implements a sophisticated pause mechanism for smart contracts in the EigenLayer ecosystem. Its primary purpose is to provide emergency circuit breaker functionality, allowing designated entities to suspend specific contract operations when necessary, such as during upgrades or when security vulnerabilities are discovered.</p> <p>This abstract contract is designed to be inherited by other contracts in the EigenLayer system that require pausability features. Rather than implementing a simple boolean pause mechanism, it uses a bitmap approach with up to 256 different pause flags, allowing for fine-grained control over which specific functionalities can be paused independently.</p> <p>The contract leverages several key design patterns: - Role-Based Access Control: Pause/unpause functions are restricted to designated pausers and unpausers - Bitmap Flags: Uses a 256-bit integer to represent multiple pause switches - Registry Pattern: Defers access control decisions to a separate PauserRegistry contract - Modifier Pattern: Provides reusable checks for paused status and authorization</p>"},{"location":"code/permissions/Pausable/#2-contract-interface","title":"2. Contract Interface","text":""},{"location":"code/permissions/Pausable/#state-variables","title":"State Variables","text":"<ul> <li><code>_paused</code>: A uint256 bitmap where each bit represents a different pause flag. When a bit is set to 1, the corresponding functionality is paused.</li> <li><code>pauserRegistry</code>: An immutable reference to the PauserRegistry contract that manages authorization for pause/unpause operations.</li> </ul>"},{"location":"code/permissions/Pausable/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li><code>pause(uint256 newPausedStatus)</code>: Allows a pauser to selectively pause functionalities by setting specific bits in the pause bitmap.</li> <li><code>pauseAll()</code>: Convenience function that pauses all functionalities by setting all bits to 1.</li> <li><code>unpause(uint256 newPausedStatus)</code>: Allows the unpauser to selectively unpause functionalities.</li> <li><code>paused()</code>: Returns the complete pause status bitmap.</li> <li><code>paused(uint8 index)</code>: Checks if a specific functionality (identified by bit index) is paused.</li> </ul>"},{"location":"code/permissions/Pausable/#events","title":"Events","text":"<ul> <li><code>Paused(address indexed account, uint256 newPausedStatus)</code>: Emitted when the pause status changes to a new paused state.</li> <li><code>Unpaused(address indexed account, uint256 newPausedStatus)</code>: Emitted when the pause status changes to a new unpaused state.</li> </ul>"},{"location":"code/permissions/Pausable/#modifiers","title":"Modifiers","text":"<ul> <li><code>onlyPauser()</code>: Restricts functions to be callable only by addresses authorized as pausers.</li> <li><code>onlyUnpauser()</code>: Restricts functions to be callable only by the designated unpauser.</li> <li><code>whenNotPaused()</code>: Requires that the contract is not paused in any way.</li> <li><code>onlyWhenNotPaused(uint8 index)</code>: Requires that a specific functionality is not paused.</li> </ul>"},{"location":"code/permissions/Pausable/#3-logic-flow","title":"3. Logic Flow","text":""},{"location":"code/permissions/Pausable/#pause-mechanism","title":"Pause Mechanism","text":"<ol> <li>The contract maintains a bitmap (<code>_paused</code>) where each bit position represents a specific functionality that can be paused.</li> <li>When a bit is set to 1, the corresponding functionality is considered paused.</li> <li>When a bit is set to 0, the corresponding functionality is considered active.</li> </ol>"},{"location":"code/permissions/Pausable/#pausing-workflow","title":"Pausing Workflow","text":"<ol> <li>A designated pauser calls <code>pause()</code> with a bitmap indicating which functionalities to pause.</li> <li>The contract verifies the caller is an authorized pauser via the PauserRegistry.</li> <li>The contract ensures the new pause status only adds pauses (it can't unpause anything).</li> <li>The pause status is updated, and the <code>Paused</code> event is emitted.</li> </ol>"},{"location":"code/permissions/Pausable/#unpausing-workflow","title":"Unpausing Workflow","text":"<ol> <li>The designated unpauser calls <code>unpause()</code> with a bitmap indicating the new pause status.</li> <li>The contract verifies the caller is the authorized unpauser via the PauserRegistry.</li> <li>The contract ensures the new pause status only removes pauses (it can't pause anything new).</li> <li>The pause status is updated, and the <code>Unpaused</code> event is emitted.</li> </ol>"},{"location":"code/permissions/Pausable/#security-mechanisms","title":"Security Mechanisms","text":"<ol> <li>Role Segregation: Pausing and unpausing permissions are separated between different roles.</li> <li>External Registry: Authorization logic is delegated to a separate contract, following separation of concerns.</li> <li>Bitmap Validation: The contract ensures that pause operations can only add pauses and unpause operations can only remove pauses.</li> <li>Storage Gap: Includes a storage gap to allow for future upgrades without storage collision.</li> </ol>"},{"location":"code/permissions/Pausable/#4-visual-representation","title":"4. Visual Representation","text":"<pre><code>flowchart TD\n    subgraph Pausable Contract\n        constructor[Constructor\\nInitializes pauserRegistry]\n        pauseMethod[pause(uint256 newPausedStatus)\\nOnly pauser can call]\n        pauseAllMethod[pauseAll()\\nOnly pauser can call]\n        unpauseMethod[unpause(uint256 newPausedStatus)\\nOnly unpauser can call]\n        pausedGetter[paused()\\nReturns complete bitmap]\n        pausedIndexGetter[paused(uint8 index)\\nChecks specific bit]\n        pausedStatus[_paused\\nBitmap storage]\n    end\n\n    subgraph Modifiers\n        onlyPauser[onlyPauser\\nChecks if caller is pauser]\n        onlyUnpauser[onlyUnpauser\\nChecks if caller is unpauser]\n        whenNotPaused[whenNotPaused\\nChecks if fully unpaused]\n        onlyWhenNotPaused[onlyWhenNotPaused\\nChecks specific bit]\n    end\n\n    subgraph External\n        PauserRegistry[IPauserRegistry\\nManages pause permissions]\n        InheritingContract[Contract inheriting Pausable\\nImplements pausing logic]\n    end\n\n    constructor --&gt; PauserRegistry\n    pauseMethod --&gt; onlyPauser\n    pauseAllMethod --&gt; onlyPauser\n    unpauseMethod --&gt; onlyUnpauser\n\n    onlyPauser --&gt; PauserRegistry\n    onlyUnpauser --&gt; PauserRegistry\n\n    pauseMethod --&gt; pausedStatus\n    pauseAllMethod --&gt; pausedStatus\n    unpauseMethod --&gt; pausedStatus\n\n    pausedGetter --&gt; pausedStatus\n    pausedIndexGetter --&gt; pausedStatus\n\n    InheritingContract --&gt; Pausable\n    whenNotPaused --&gt; pausedStatus\n    onlyWhenNotPaused --&gt; pausedStatus</code></pre>"},{"location":"code/permissions/Pausable/#5-dependencies-and-interactions","title":"5. Dependencies and Interactions","text":""},{"location":"code/permissions/Pausable/#external-dependencies","title":"External Dependencies","text":"<ul> <li>IPausable: Interface that defines the pause-related functions and events.</li> <li>IPauserRegistry: Interface for the registry contract that manages pauser and unpauser access control.</li> </ul>"},{"location":"code/permissions/Pausable/#contract-interactions","title":"Contract Interactions","text":"<ol> <li>Interaction with PauserRegistry:</li> <li>The contract calls <code>isPauser(address)</code> to verify if an account is authorized to pause.</li> <li> <p>The contract calls <code>unpauser()</code> to verify if an account is authorized to unpause.</p> </li> <li> <p>Interaction with Inheriting Contracts:</p> </li> <li>Contracts that inherit from <code>Pausable</code> can define specific pause flags for different functionalities.</li> <li>Inheriting contracts should use the provided modifiers (<code>whenNotPaused</code>, <code>onlyWhenNotPaused</code>) to protect functions that should respect pause status.</li> <li>Inheriting contracts can implement custom pause/unpause functions that target specific bits in the pause bitmap, with appropriate access control.</li> </ol> <p>The pausable pattern implemented in this contract provides an elegant solution for emergency circuit breaking with granular control. By using a bitmap approach rather than a simple boolean, the system can selectively pause specific functions while keeping others operational, minimizing disruption during maintenance or emergency scenarios.</p>"},{"location":"code/permissions/PauserRegistry/","title":"PauserRegistry","text":""},{"location":"code/permissions/PauserRegistry/#contract-overview","title":"Contract Overview","text":"<p>PauserRegistry is a smart contract designed to manage permission controls for pausing functionality within the EigenLayer protocol. The contract establishes a security hierarchy with two distinct roles: pausers and a single unpauser. This architecture implements a governance pattern that enables emergency response capabilities while maintaining administrative security.</p> <p>The contract serves as a central registry for pausing permissions, which other contracts in the EigenLayer ecosystem can query to determine if an address has the authority to pause critical protocol operations. This pattern decouples the permission logic from the functional contracts, creating a more modular and maintainable system architecture.</p> <p>Key design patterns employed include: - Role-based access control (RBAC) for managing permissions - Single responsibility principle by focusing solely on pause/unpause permissions - Event-driven design for transparency and off-chain monitoring - Hierarchical permission structure with the unpauser at the highest level</p>"},{"location":"code/permissions/PauserRegistry/#contract-interface","title":"Contract Interface","text":""},{"location":"code/permissions/PauserRegistry/#state-variables","title":"State Variables","text":"<ul> <li><code>isPauser</code>: A mapping that tracks which addresses have permission to pause functionality in dependent contracts</li> <li><code>unpauser</code>: A single address with the highest privileges, capable of managing both pausers and appointing a new unpauser</li> </ul>"},{"location":"code/permissions/PauserRegistry/#modifiers","title":"Modifiers","text":"<ul> <li><code>onlyUnpauser</code>: Restricts function access to only the designated unpauser address</li> </ul>"},{"location":"code/permissions/PauserRegistry/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li><code>setIsPauser(address newPauser, bool canPause)</code>: Enables the unpauser to grant or revoke pauser privileges for a specific address</li> <li><code>setUnpauser(address newUnpauser)</code>: Allows the current unpauser to transfer their role to a new address</li> </ul>"},{"location":"code/permissions/PauserRegistry/#events","title":"Events","text":"<ul> <li><code>PauserStatusChanged(address pauser, bool canPause)</code>: Emitted when an address is granted or revoked pauser privileges</li> <li><code>UnpauserChanged(address previousUnpauser, address newUnpauser)</code>: Emitted when the unpauser role is transferred</li> </ul>"},{"location":"code/permissions/PauserRegistry/#constructor","title":"Constructor","text":"<p>Initializes the contract by setting up the initial set of pausers and the unpauser address.</p>"},{"location":"code/permissions/PauserRegistry/#logic-flow","title":"Logic Flow","text":"<p>The PauserRegistry follows a straightforward but effective permission management flow:</p> <ol> <li> <p>Initialization: During contract deployment, the constructor accepts arrays of pauser addresses and a single unpauser address, establishing the initial permission structure.</p> </li> <li> <p>Permission Checks: External contracts query the <code>isPauser</code> mapping to verify if an address has pausing privileges.</p> </li> <li> <p>Pauser Management:</p> </li> <li>Only the unpauser can add or remove addresses from the pauser role</li> <li>Changes to pauser status are recorded through events for transparency</li> <li> <p>Pauser addresses cannot be set to the zero address (0x0)</p> </li> <li> <p>Unpauser Transfer:</p> </li> <li>The unpauser can transfer their role to a new address</li> <li>This provides flexibility to update governance as needed</li> <li>The unpauser address cannot be set to the zero address (0x0)</li> <li>Each change emits an event recording the previous and new unpauser</li> </ol> <p>The security hierarchy is intentionally designed with the unpauser at the top. The documentation suggests the unpauser should be a high-security entity, potentially a multisig wallet with a higher threshold of required signatures. This approach balances the need for emergency action capability (through pausers) with strong governance controls (through the more secure unpauser role).</p>"},{"location":"code/permissions/PauserRegistry/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Deploy PauserRegistry] --&gt; B[Initialize pausers &amp; unpauser]\n    B --&gt; C{Contract Operation}\n\n    C --&gt;|Add/Remove Pauser| D[setIsPauser]\n    C --&gt;|Change Unpauser| E[setUnpauser]\n\n    D --&gt; F{Is caller the unpauser?}\n    E --&gt; F\n\n    F --&gt;|Yes| G[Execute Change &amp; Emit Event]\n    F --&gt;|No| H[Revert Transaction]\n\n    I[External Contracts] --&gt;|Query isPauser| J[Check Pausing Permission]</code></pre>"},{"location":"code/permissions/PauserRegistry/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>PauserRegistry implements the <code>IPauserRegistry</code> interface, which defines the contract's essential functions and events. This interface likely serves as a connection point for other contracts in the EigenLayer ecosystem that need to verify pausing permissions.</p> <p>While the contract itself doesn't directly interact with other contracts, it's designed to be queried by them. Any contract that needs pausing functionality would:</p> <ol> <li>Reference the PauserRegistry address</li> <li>Call <code>isPauser(address)</code> to check if a specific address has pausing privileges</li> <li>Implement pausing logic based on the result</li> </ol> <p>This pattern allows for centralized permission management while enabling decentralized implementation across the protocol. If the protocol needs to update who can pause operations, they only need to update the PauserRegistry rather than each individual contract.</p> <p>The design also suggests that the unpauser role is intended for a highly secure multisig wallet, providing an additional layer of security for this critical administrative function. This reflects a thoughtful approach to balancing operational flexibility with robust security measures.</p>"},{"location":"code/permissions/PermissionController/","title":"PermissionController","text":""},{"location":"code/permissions/PermissionController/#contract-overview","title":"Contract Overview","text":"<p>The <code>PermissionController</code> is a smart contract designed to manage permissions and access control within a Web3 system. Its primary purpose is to provide a flexible and secure way to delegate administrative rights and specific function permissions to different Ethereum addresses.</p> <p>This contract implements a sophisticated permission management system with two key concepts: 1. Admins: Addresses with full administrative rights over an account 2. Appointees: Addresses granted permission to call specific functions on specific target contracts on behalf of an account</p> <p>The contract utilizes the proxy pattern (as seen from the Initializable import) for upgradability, allowing the contract logic to be updated while preserving state. It also implements version control through the SemVerMixin, making it easier to track contract iterations.</p> <p>The PermissionController sits at the core of the platform's access control architecture, providing the infrastructure needed for secure multi-user account management and function-specific permission delegation.</p>"},{"location":"code/permissions/PermissionController/#contract-interface","title":"Contract Interface","text":""},{"location":"code/permissions/PermissionController/#publicexternal-functions","title":"Public/External Functions","text":""},{"location":"code/permissions/PermissionController/#admin-management","title":"Admin Management","text":"<ul> <li>addPendingAdmin(address account, address admin): Allows an existing admin to nominate a new admin (requires approval)</li> <li>removePendingAdmin(address account, address admin): Removes a pending admin nomination</li> <li>acceptAdmin(address account): Called by a pending admin to accept the admin role</li> <li>removeAdmin(address account, address admin): Removes an existing admin (requires at least one admin to remain)</li> </ul>"},{"location":"code/permissions/PermissionController/#appointee-management","title":"Appointee Management","text":"<ul> <li>setAppointee(address account, address appointee, address target, bytes4 selector): Grants an appointee permission to call a specific function on a target contract</li> <li>removeAppointee(address account, address appointee, address target, bytes4 selector): Removes a previously granted permission</li> </ul>"},{"location":"code/permissions/PermissionController/#view-functions","title":"View Functions","text":"<ul> <li>isAdmin(address account, address caller): Checks if a caller is an admin for an account</li> <li>isPendingAdmin(address account, address pendingAdmin): Checks if an address is a pending admin</li> <li>getAdmins(address account): Returns all admins for an account</li> <li>getPendingAdmins(address account): Returns all pending admins for an account</li> <li>canCall(address account, address caller, address target, bytes4 selector): Checks if a caller can execute a specific function</li> <li>getAppointeePermissions(address account, address appointee): Lists all permissions granted to an appointee</li> <li>getAppointees(address account, address target, bytes4 selector): Lists all appointees for a specific function</li> </ul>"},{"location":"code/permissions/PermissionController/#important-events","title":"Important Events","text":"<ul> <li>PendingAdminAdded(address account, address admin): Emitted when a new admin is nominated</li> <li>PendingAdminRemoved(address account, address admin): Emitted when a pending admin nomination is removed</li> <li>AdminSet(address account, address admin): Emitted when a pending admin accepts the role</li> <li>AdminRemoved(address account, address admin): Emitted when an admin is removed</li> <li>AppointeeSet(address account, address appointee, address target, bytes4 selector): Emitted when a new appointee permission is granted</li> <li>AppointeeRemoved(address account, address appointee, address target, bytes4 selector): Emitted when an appointee permission is removed</li> </ul>"},{"location":"code/permissions/PermissionController/#key-state-variables","title":"Key State Variables","text":"<p>The core state is stored in the <code>_permissions</code> mapping inherited from <code>PermissionControllerStorage</code>, which associates each account with: - A set of admin addresses - A set of pending admin addresses - Mappings for appointee permissions to specific function selectors on target contracts</p>"},{"location":"code/permissions/PermissionController/#logic-flow","title":"Logic Flow","text":""},{"location":"code/permissions/PermissionController/#admin-management-flow","title":"Admin Management Flow","text":"<ol> <li>Admin Nomination Process:</li> <li>An existing admin calls <code>addPendingAdmin</code> to nominate a new admin</li> <li>The nominated admin is added to the account's <code>pendingAdmins</code> set</li> <li>The pending admin must then call <code>acceptAdmin</code> to assume the admin role</li> <li> <p>Once accepted, the admin is moved from <code>pendingAdmins</code> to <code>admins</code></p> </li> <li> <p>Default Admin Behavior:</p> </li> <li>If an account has no admins set, the account address itself is considered the admin</li> <li> <p>Once explicit admins are set, only those addresses have admin permissions</p> </li> <li> <p>Admin Removal:</p> </li> <li>An admin can be removed via <code>removeAdmin</code></li> <li>The system enforces a minimum of one admin at all times for security reasons</li> </ol>"},{"location":"code/permissions/PermissionController/#appointee-permission-management","title":"Appointee Permission Management","text":"<ol> <li>Granting Specific Permissions:</li> <li>Admins can call <code>setAppointee</code> to grant an appointee permission to call specific functions</li> <li>The permission is encoded by combining the target contract address and function selector</li> <li> <p>This encoded permission is stored in the appointee's permission set</p> </li> <li> <p>Permission Verification:</p> </li> <li> <p>When checking if a caller can execute a function via <code>canCall</code>, the system:</p> <ul> <li>First checks if the caller is an admin (full access)</li> <li>If not, checks if the caller has a specific appointee permission for the target function</li> </ul> </li> <li> <p>Permission Removal:</p> </li> <li>Admins can revoke appointee permissions via <code>removeAppointee</code></li> <li>This removes the encoded permission from the appointee's permission set</li> </ol>"},{"location":"code/permissions/PermissionController/#target-selector-encoding-mechanism","title":"Target-Selector Encoding Mechanism","text":"<p>The contract uses a compact encoding mechanism to store target addresses and function selectors efficiently: - <code>_encodeTargetSelector</code>: Combines a target address and function selector into a single bytes32 value - <code>_decodeTargetSelector</code>: Extracts the original target address and function selector from the encoded value</p> <p>This encoding follows the format: [160 bits target][32 bits selector][64 bits padding]</p>"},{"location":"code/permissions/PermissionController/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Account Owner] --&gt;|Initial Admin| B[Permission Controller]\n    B --&gt;|addPendingAdmin| C[Pending Admin Added]\n    C --&gt;|acceptAdmin| D[New Admin Set]\n    D --&gt;|removeAdmin| E[Admin Removed]\n\n    D --&gt;|setAppointee| F[Appointee Permission Set]\n    F --&gt;|removeAppointee| G[Appointee Permission Removed]\n\n    H[External Contract] --&gt;|canCall| B\n    B --&gt;|Permission Check| I{Is Admin?}\n    I --&gt;|Yes| J[Allow Call]\n    I --&gt;|No| K{Has Specific Permission?}\n    K --&gt;|Yes| J\n    K --&gt;|No| L[Deny Call]</code></pre>"},{"location":"code/permissions/PermissionController/#dependencies-and-interactions","title":"Dependencies and Interactions","text":""},{"location":"code/permissions/PermissionController/#contract-dependencies","title":"Contract Dependencies","text":"<ul> <li>OpenZeppelin's Initializable: Provides initialization pattern for upgradeable contracts</li> <li>SemVerMixin: Implements semantic versioning for the contract</li> <li>PermissionControllerStorage: Contains the storage structure for permissions</li> </ul>"},{"location":"code/permissions/PermissionController/#storage-structure","title":"Storage Structure","text":"<p>The contract doesn't directly define storage variables but instead inherits them from <code>PermissionControllerStorage</code>, which likely defines: - Mapping of accounts to their permission configurations - EnumerableSet data structures for efficient storage and retrieval of admins, pending admins, and appointee permissions</p>"},{"location":"code/permissions/PermissionController/#system-interactions","title":"System Interactions","text":"<p>This contract serves as a central authority for permission management in the platform. Other contracts in the system likely: 1. Query this contract to check if operations are permitted 2. Defer access control decisions to this contract's <code>canCall</code> function 3. Rely on this contract to enforce a proper chain of administrative control</p> <p>The design prioritizes security and flexibility, allowing for fine-grained permission control while maintaining a clear administrative hierarchy.</p>"},{"location":"code/permissions/PermissionControllerStorage/","title":"PermissionControllerStorage","text":""},{"location":"code/permissions/PermissionControllerStorage/#contract-overview","title":"Contract Overview","text":"<p>PermissionControllerStorage is an abstract smart contract serving as a foundational storage component for implementing granular permission management systems in blockchain applications. It defines the data structures needed to track and manage permissions across different accounts, enabling a hierarchical access control system with admin and appointee roles. </p> <p>The contract is designed as a storage layer meant to be inherited by other contracts (likely a PermissionController implementation contract) that will provide the actual logic to manipulate these permission structures. By separating storage from logic, the system follows the proxy pattern, which is a common practice in upgradeable smart contract architectures.</p> <p>The contract specifically focuses on providing a flexible data structure for: - Managing admin users for accounts - Tracking pending admin appointments - Managing granular function-level permissions for appointees - Creating a relationship between specific contract functions and appointed users</p>"},{"location":"code/permissions/PermissionControllerStorage/#contract-interface","title":"Contract Interface","text":""},{"location":"code/permissions/PermissionControllerStorage/#key-state-variables","title":"Key State Variables","text":"<ul> <li><code>_permissions</code>: A mapping from each account address to its <code>AccountPermissions</code> struct, which contains:</li> <li><code>pendingAdmins</code>: A set of addresses that have been nominated as admins but haven't accepted yet</li> <li><code>admins</code>: A set of addresses that have admin privileges for the account</li> <li><code>appointeePermissions</code>: Maps appointee addresses to their permitted contract functions (encoded as bytes32)</li> <li><code>permissionAppointees</code>: Reverse mapping that maps functions (encoded as bytes32) to the addresses permitted to call them</li> </ul>"},{"location":"code/permissions/PermissionControllerStorage/#imports-and-libraries","title":"Imports and Libraries","text":"<ul> <li><code>EnumerableSet</code>: From OpenZeppelin, used to store unique collections of values and efficiently check for membership</li> <li><code>IPermissionController</code>: An interface that this contract implements, defining the expected API for permission management</li> </ul>"},{"location":"code/permissions/PermissionControllerStorage/#logic-flow","title":"Logic Flow","text":"<p>The PermissionControllerStorage contract doesn't implement any logic itself; rather, it defines the data structure that will be used by implementing contracts. The primary data structure flow is:</p> <ol> <li>Each account in the system has its own permission management system (via the <code>_permissions</code> mapping)</li> <li>For each account, there are two key user roles:</li> <li>Admins: Users with broad control over the account's settings and permissions</li> <li>Appointees: Users granted specific permissions to interact with certain functions</li> <li>Admin management includes a pending state, suggesting a two-step process where admin appointments must be accepted</li> <li>Permissions are tracked bidirectionally:</li> <li>From appointees to their permitted functions</li> <li>From functions to the appointees allowed to call them</li> </ol> <p>This bidirectional tracking allows for efficient lookups in either direction, whether checking if a user has permissions for a function or finding all users with permissions for a particular function.</p>"},{"location":"code/permissions/PermissionControllerStorage/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Account Address] --&gt; B[AccountPermissions Struct]\n    B --&gt; C[pendingAdmins Set]\n    B --&gt; D[admins Set]\n    B --&gt; E[appointeePermissions Mapping]\n    B --&gt; F[permissionAppointees Mapping]\n\n    E --&gt; G[Appointee Address]\n    G --&gt; H[Set of encoded function selectors]\n\n    F --&gt; I[Function selector bytes32]\n    I --&gt; J[Set of appointee addresses]\n\n    C --&gt; K[Address 1, Address 2, ...]\n    D --&gt; L[Address 1, Address 2, ...]\n    H --&gt; M[bytes32 1, bytes32 2, ...]\n    J --&gt; N[Address 1, Address 2, ...]</code></pre>"},{"location":"code/permissions/PermissionControllerStorage/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>This contract has the following dependencies:</p> <ol> <li> <p>OpenZeppelin's EnumerableSet: Used to efficiently manage unique collections of admins, appointees, and function selectors. The library provides functionality for adding, removing, and checking membership in sets.</p> </li> <li> <p>IPermissionController: An interface that defines the contract's API. While the storage contract doesn't implement these functions, it inherits the interface, indicating that any contract extending PermissionControllerStorage must implement the methods defined in the interface.</p> </li> </ol> <p>As an abstract storage contract, PermissionControllerStorage is designed to be extended by an implementation contract that will provide the actual logic to: - Add and remove admins - Manage the pending admin acceptance flow - Grant and revoke specific permissions to appointees - Check permissions during function execution</p> <p>The contract also includes a storage gap (<code>__gap</code>), which is a common pattern in upgradeable contracts. This reserved space in storage allows future versions to add new variables without causing storage collisions with contracts that might inherit from this one.</p>"},{"location":"code/permissions/PermissionControllerStorage/#security-considerations","title":"Security Considerations","text":"<p>The contract implements several security best practices: 1. Separation of concerns: By isolating storage structures from logic, the contract follows a modular design that enhances security and upgradability 2. Bidirectional permission tracking: Makes it harder for permissions to get out of sync 3. Storage gap: Provides protection against storage collisions during upgrades 4. Two-step admin appointment: The pendingAdmins structure suggests a more secure admin management flow that requires acceptance</p> <p>This carefully designed storage structure provides the foundation for a robust permission system that can manage complex access control requirements in decentralized applications.</p>"},{"location":"code/pods/EigenPod/","title":"EigenPod","text":""},{"location":"code/pods/EigenPod/#contract-overview","title":"Contract Overview","text":"<p>EigenPod is a critical component of the EigenLayer restaking ecosystem, designed to enable users to restake their ETH that is staked in Ethereum's Proof of Stake (PoS) consensus mechanism. It serves as a personal vault that allows Ethereum validators to prove their balances on the beacon chain and have them \"recognized\" by EigenLayer without moving the actual funds.</p> <p>The contract's primary purpose is to: 1. Verify validator withdrawal credentials pointing to itself 2. Track validator balances through periodic checkpoints 3. Handle validator exits and withdrawals 4. Make these beacon chain balances available for restaking on EigenLayer</p> <p>Within the EigenLayer system architecture, each user who wants to restake their ETH validators will have their own EigenPod contract. These pods interact with the EigenPodManager, which coordinates with the broader EigenLayer system. The contract follows the beacon proxy pattern, which allows all EigenPods to share the same implementation while maintaining individual state.</p> <p>Key design patterns used include: - Upgradeable proxy pattern - Modular verification system for beacon chain proofs - Role-based access control (pod owner, proof submitter) - Pausable functionality (inherited from EigenPodManager) - Checkpoint-based accounting system</p>"},{"location":"code/pods/EigenPod/#contract-interface","title":"Contract Interface","text":""},{"location":"code/pods/EigenPod/#key-state-variables","title":"Key State Variables","text":"<ul> <li><code>podOwner</code>: The address of the pod's owner who can control pod operations</li> <li><code>proofSubmitter</code>: Optional designated address allowed to submit proofs on behalf of the owner</li> <li><code>activeValidatorCount</code>: Number of active validators whose withdrawals are directed to this pod</li> <li><code>restakedExecutionLayerGwei</code>: Total ETH (in Gwei) that has been restaked and is withdrawable</li> <li><code>_validatorPubkeyHashToInfo</code>: Mapping from validator public key hash to validator information</li> <li><code>_currentCheckpoint</code>: The currently active checkpoint, if any</li> <li><code>currentCheckpointTimestamp</code>: Timestamp of the current checkpoint, or 0 if no active checkpoint</li> <li><code>lastCheckpointTimestamp</code>: Timestamp of the last completed checkpoint</li> </ul>"},{"location":"code/pods/EigenPod/#external-functions","title":"External Functions","text":"<ul> <li><code>initialize(address _podOwner)</code>: Sets up the pod with its owner (called by EigenPodManager on creation)</li> <li><code>startCheckpoint(bool revertIfNoBalance)</code>: Begins a new checkpoint process to update balances</li> <li><code>verifyCheckpointProofs(...)</code>: Submits proofs of validators' current balances to update the checkpoint</li> <li><code>verifyWithdrawalCredentials(...)</code>: Verifies validators have withdrawal credentials pointing to this pod</li> <li><code>verifyStaleBalance(...)</code>: Allows initiating a checkpoint when a validator has been slashed</li> <li><code>recoverTokens(...)</code>: Allows pod owner to withdraw any ERC20 tokens from the pod</li> <li><code>setProofSubmitter(address newProofSubmitter)</code>: Updates who can submit proofs for the pod</li> <li><code>stake(...)</code>: Called by EigenPodManager to create a new validator through the Eth deposit contract</li> <li><code>withdrawRestakedBeaconChainETH(address recipient, uint256 amountWei)</code>: Transfers ETH to recipient</li> </ul>"},{"location":"code/pods/EigenPod/#important-events","title":"Important Events","text":"<ul> <li><code>CheckpointCreated</code>: Emitted when a new checkpoint is started</li> <li><code>CheckpointFinalized</code>: Emitted when a checkpoint is completed</li> <li><code>ValidatorRestaked</code>: Emitted when a validator's withdrawal credentials are verified</li> <li><code>ValidatorCheckpointed</code>: Emitted when a validator's balance is updated in a checkpoint</li> <li><code>ValidatorWithdrawn</code>: Emitted when a validator is marked as withdrawn</li> <li><code>ValidatorBalanceUpdated</code>: Emitted when a validator's balance changes</li> <li><code>ProofSubmitterUpdated</code>: Emitted when the proof submitter address is changed</li> <li><code>EigenPodStaked</code>: Emitted when the pod stakes a new validator</li> <li><code>RestakedBeaconChainETHWithdrawn</code>: Emitted when restaked ETH is withdrawn</li> <li><code>NonBeaconChainETHReceived</code>: Emitted when the pod receives ETH outside of withdrawal proofs</li> </ul>"},{"location":"code/pods/EigenPod/#logic-flow","title":"Logic Flow","text":""},{"location":"code/pods/EigenPod/#restaking-workflow","title":"Restaking Workflow","text":"<ol> <li>Pod Creation: A user deploys an EigenPod through the EigenPodManager.</li> <li>Validator Credential Verification:</li> <li>User or their proof submitter calls <code>verifyWithdrawalCredentials</code> with proofs from the beacon chain.</li> <li>Contract verifies withdrawal credentials point to the pod address.</li> <li> <p>Valid validators are marked as ACTIVE and their balances are tracked.</p> </li> <li> <p>Checkpoint Process:</p> </li> <li>Periodically, <code>startCheckpoint</code> is called to initialize a checkpoint.</li> <li>The current pod balance and Ethereum block root are recorded.</li> <li>For each active validator, proofs are submitted via <code>verifyCheckpointProofs</code>.</li> <li>When all required proofs are submitted, the checkpoint finalizes.</li> <li> <p>The pod's balances are updated and the EigenPodManager is notified.</p> </li> <li> <p>Withdrawals:</p> </li> <li>When validators exit the beacon chain, their balances are updated in checkpoints.</li> <li>The EigenPodManager can call <code>withdrawRestakedBeaconChainETH</code> to transfer ETH to a recipient.</li> </ol>"},{"location":"code/pods/EigenPod/#balance-tracking-mechanism","title":"Balance Tracking Mechanism","text":"<p>The contract carefully tracks three types of balances: 1. Validator Balances: Individual balances of each active validator. 2. Pod ETH Balance: Native ETH held by the pod contract. 3. Restaked Execution Layer Balance: The portion of pod balance that has been \"checkpointed\" and is eligible for withdrawal.</p> <p>During checkpoints, the contract: - Tracks changes in active validator balances on the beacon chain - Incorporates the pod's native ETH balance into the restaked amount - Identifies validators that have exited (balance = 0) - Updates the restaked balance that the broader EigenLayer system can recognize</p>"},{"location":"code/pods/EigenPod/#security-mechanisms","title":"Security Mechanisms","text":"<ol> <li>Access Controls:</li> <li><code>onlyEigenPodOwner</code> modifier restricts functions to the pod owner</li> <li><code>onlyEigenPodManager</code> limits certain functions to the EigenPodManager contract</li> <li> <p><code>onlyOwnerOrProofSubmitter</code> allows designated proof submitters to help manage the pod</p> </li> <li> <p>Checkpoint Integrity:</p> </li> <li>Only one checkpoint can be active at a time</li> <li>Validators cannot be proven twice in the same checkpoint</li> <li> <p>Timestamp constraints ensure proofs are chronologically valid</p> </li> <li> <p>Withdrawal Security:</p> </li> <li>Clear accounting of withdrawable amounts</li> <li>Verification of beacon chain proofs</li> <li> <p>Integration with EigenLayer's slashing management</p> </li> <li> <p>Pause Functionality:</p> </li> <li>Critical functions can be paused by the EigenPodManager</li> <li>Different pause switches for different functionalities</li> </ol>"},{"location":"code/pods/EigenPod/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    User[\"Pod Owner\"] --&gt; |\"Creates Pod\"| EPM[\"EigenPodManager\"]\n    EPM --&gt; |\"Deploys\"| EP[\"EigenPod\"]\n\n    EP --&gt; |\"Initialize(podOwner)\"| Initialize[\"Set Pod Owner\"]\n    User --&gt; |\"verifyWithdrawalCredentials\"| VC[\"Verify Validator Credentials\"]\n    VC --&gt; |\"If valid\"| AV[\"Mark Validator as ACTIVE\"]\n    AV --&gt; |\"Track balance\"| VB[\"Validator Balance\"]\n\n    User --&gt; |\"startCheckpoint\"| SC[\"Start Checkpoint\"]\n    SC --&gt; CP[\"Create Checkpoint\"]\n    CP --&gt; |\"Record pod balance &amp; block root\"| CB[\"Checkpoint Balances\"]\n\n    User --&gt; |\"verifyCheckpointProofs\"| VP[\"Verify Proofs\"]\n    VP --&gt; |\"For each active validator\"| UB[\"Update Balances\"]\n    UB --&gt; |\"If all proofs verified\"| FC[\"Finalize Checkpoint\"]\n    FC --&gt; |\"recordBeaconChainETHBalanceUpdate\"| EPM\n\n    EPM --&gt; |\"withdrawRestakedBeaconChainETH\"| WD[\"Withdraw ETH\"]\n    WD --&gt; |\"Transfer to recipient\"| User\n\n    EPM --&gt; |\"stake\"| ST[\"Stake New Validator\"]\n    ST --&gt; |\"deposit to ETH PoS contract\"| ETHPOS[\"ETH PoS Deposit Contract\"]\n\n    subgraph \"Beacon Chain Interactions\"\n        VC &lt;--&gt; |\"Verify against\"| BC[\"Beacon Chain\"]\n        VP &lt;--&gt; |\"Verify against\"| BC\n    end</code></pre>"},{"location":"code/pods/EigenPod/#dependencies-and-interactions","title":"Dependencies and Interactions","text":""},{"location":"code/pods/EigenPod/#contract-dependencies","title":"Contract Dependencies","text":"<ol> <li>EigenPodManager: Coordinates all EigenPods and integrates with DelegationManager</li> <li>Deploys new EigenPods</li> <li>Records balance updates</li> <li> <p>Facilitates withdrawals</p> </li> <li> <p>ETH PoS Deposit Contract: Used when staking new validators</p> </li> <li>Receives 32 ETH deposits for new validators</li> <li> <p>Registers validator credentials with the beacon chain</p> </li> <li> <p>EIP-4788 Beacon Block Root Oracle: Provides access to historical beacon chain block roots</p> </li> <li>Used to verify proofs against specific beacon chain blocks</li> <li> <p>Located at a predefined address (<code>0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02</code>)</p> </li> <li> <p>BeaconChainProofs Library: Handles verification of beacon chain proofs</p> </li> <li>Validates withdrawal credentials</li> <li>Verifies validator balances and states</li> </ol>"},{"location":"code/pods/EigenPod/#external-contract-interactions","title":"External Contract Interactions","text":"<ol> <li>EigenPod \u2194 EigenPodManager:</li> <li>EigenPod calls <code>recordBeaconChainETHBalanceUpdate</code> to update balances after checkpoints</li> <li>EigenPodManager calls <code>withdrawRestakedBeaconChainETH</code> to withdraw funds</li> <li> <p>EigenPodManager calls <code>stake</code> to create new validators</p> </li> <li> <p>EigenPod \u2194 ETH PoS Deposit Contract:</p> </li> <li> <p>EigenPod calls <code>deposit</code> to create new validators</p> </li> <li> <p>EigenPod \u2194 EIP-4788 Oracle:</p> </li> <li>EigenPod static calls the oracle to get historical beacon chain block roots</li> </ol>"},{"location":"code/pods/EigenPod/#system-data-flow","title":"System Data Flow","text":"<ol> <li>Withdrawal credentials are verified from beacon chain to EigenPod</li> <li>Checkpoint proofs flow from the beacon chain through the EigenPod </li> <li>Balance updates flow from EigenPod to EigenPodManager</li> <li>ETH withdrawals flow from EigenPod to users through the EigenPodManager and DelegationManager</li> </ol> <p>The EigenPod serves as the critical bridge between a user's ETH staked on the beacon chain and the EigenLayer protocol, allowing ETH to be dual-purposed for both consensus security and restaking applications without requiring it to leave the beacon chain.</p>"},{"location":"code/pods/EigenPodManager/","title":"EigenPodManager","text":""},{"location":"code/pods/EigenPodManager/#contract-overview","title":"Contract Overview","text":"<p>EigenPodManager is a central contract in the EigenLayer protocol that manages the creation and operation of EigenPods. These EigenPods are the mechanism through which users can restake their Ethereum validator deposits into EigenLayer, enabling them to participate in the EigenLayer protocol while maintaining their validator role on Ethereum's beacon chain.</p> <p>The contract serves as a coordination layer between individual EigenPods and the broader EigenLayer system. It keeps track of each user's restaked ETH balances, handles the deployment of new EigenPods, facilitates staking operations, and manages the accounting of ETH shares that represent a user's restaked ETH.</p> <p>The design follows a hub-and-spoke architecture where the EigenPodManager is the hub that coordinates with individual EigenPods (the spokes) and other core components of the EigenLayer protocol like the DelegationManager. It uses the proxy pattern, enabling upgradability, and implements various security mechanisms including reentrancy protection, pausing functionality, and access control modifiers.</p>"},{"location":"code/pods/EigenPodManager/#contract-interface","title":"Contract Interface","text":""},{"location":"code/pods/EigenPodManager/#key-state-variables","title":"Key State Variables","text":"<ul> <li><code>ownerToPod</code>: Maps addresses to their corresponding EigenPod contracts</li> <li><code>podOwnerDepositShares</code>: Tracks how many beacon chain ETH shares each pod owner has delegated</li> <li><code>eigenPodBeacon</code>: The beacon contract for EigenPod proxy deployment</li> <li><code>delegationManager</code>: Reference to the DelegationManager contract that handles delegation relationships</li> <li><code>beaconChainETHStrategy</code>: The strategy contract representing beacon chain ETH deposits</li> <li><code>numPods</code>: Counter of how many pods have been deployed</li> <li><code>burnableETHShares</code>: Total amount of ETH shares that can be burned (used for protocol fee accounting)</li> </ul>"},{"location":"code/pods/EigenPodManager/#publicexternal-functions","title":"Public/External Functions","text":"<p>Pod Creation and Management: - <code>createPod()</code>: Deploys a new EigenPod for the caller - <code>stake(bytes pubkey, bytes signature, bytes32 depositDataRoot)</code>: Stakes ETH for a new validator on an EigenPod - <code>getPod(address podOwner)</code>: Returns the EigenPod for a given owner - <code>hasPod(address podOwner)</code>: Checks if an address has an EigenPod already</p> <p>Balance and Share Management: - <code>recordBeaconChainETHBalanceUpdate(address podOwner, uint256 prevRestakedBalanceWei, int256 balanceDeltaWei)</code>: Records updates to a pod owner's beacon chain balance - <code>removeDepositShares(address staker, IStrategy strategy, uint256 depositSharesToRemove)</code>: Removes shares when a staker queues a withdrawal - <code>addShares(address staker, IStrategy strategy, uint256 shares)</code>: Adds shares to a staker's balance - <code>withdrawSharesAsTokens(address staker, IStrategy strategy, IERC20, uint256 shares)</code>: Completes a withdrawal by sending tokens to the staker - <code>increaseBurnableShares(IStrategy, uint256 addedSharesToBurn)</code>: Increases the count of burnable shares</p> <p>View Functions: - <code>stakerDepositShares(address user, IStrategy strategy)</code>: Returns a staker's deposit shares - <code>beaconChainSlashingFactor(address podOwner)</code>: Returns a pod owner's beacon chain slashing factor</p>"},{"location":"code/pods/EigenPodManager/#key-events","title":"Key Events","text":"<ul> <li><code>PodDeployed(address pod, address owner)</code>: Emitted when a new pod is deployed</li> <li><code>PodSharesUpdated(address podOwner, int256 sharesDelta)</code>: Emitted when a pod owner's shares change</li> <li><code>NewTotalShares(address podOwner, int256 totalShares)</code>: Emitted when total shares are updated</li> <li><code>BeaconChainSlashingFactorDecreased(address podOwner, uint64 prevFactor, uint64 newFactor)</code>: Emitted when a slashing factor is decreased</li> <li><code>BurnableETHSharesIncreased(uint256 addedSharesToBurn)</code>: Emitted when burnable shares increase</li> </ul>"},{"location":"code/pods/EigenPodManager/#logic-flow","title":"Logic Flow","text":""},{"location":"code/pods/EigenPodManager/#eigenpod-creation-process","title":"EigenPod Creation Process","text":"<ol> <li>A user calls <code>createPod()</code> or <code>stake()</code> without having a pod</li> <li>The contract verifies the user doesn't already have a pod</li> <li><code>_deployPod()</code> is called, which:</li> <li>Increments the pod counter</li> <li>Computes a deterministic address using Create2 with the user's address as salt</li> <li>Deploys a new EigenPod proxy at that address</li> <li>Initializes the pod with the user as the owner</li> <li>Stores the pod-owner relationship</li> <li>Emits a <code>PodDeployed</code> event</li> </ol>"},{"location":"code/pods/EigenPodManager/#staking-process","title":"Staking Process","text":"<ol> <li>User calls <code>stake()</code> with validator credentials and ETH value</li> <li>If the user doesn't have a pod, one is deployed</li> <li>The contract forwards the credentials and ETH to the user's pod</li> <li>The pod handles the actual staking by calling the ETH deposit contract</li> </ol>"},{"location":"code/pods/EigenPodManager/#balance-update-mechanism","title":"Balance Update Mechanism","text":"<ol> <li>An EigenPod calls <code>recordBeaconChainETHBalanceUpdate</code> when a validator's balance changes</li> <li>If the balance delta is positive:</li> <li>Shares are added to the pod owner's account using <code>_addShares</code></li> <li>The DelegationManager is notified to increase delegated shares</li> <li>If the balance delta is negative:</li> <li>The pod owner's slashing factor is reduced proportionally using <code>_reduceSlashingFactor</code></li> <li>The DelegationManager is notified to decrease delegated shares</li> </ol>"},{"location":"code/pods/EigenPodManager/#withdrawal-process","title":"Withdrawal Process","text":"<ol> <li>When a user wants to withdraw, the DelegationManager first calls <code>removeDepositShares</code></li> <li>Later, to complete the withdrawal, it calls <code>withdrawSharesAsTokens</code></li> <li>If the user has a negative share balance (legacy condition), these shares are first paid off</li> <li>Any remaining shares are withdrawn as ETH from the user's EigenPod</li> </ol>"},{"location":"code/pods/EigenPodManager/#share-accounting","title":"Share Accounting","text":"<p>The contract uses a sophisticated share accounting system to track user deposits: - Positive shares represent real restaked ETH - Historically, negative shares could exist (legacy cases), representing a share deficit - The contract handles both cases, prioritizing paying off share deficits</p>"},{"location":"code/pods/EigenPodManager/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    User[User/Staker] --&gt; |\"createPod()\"|EPM[EigenPodManager]\n    User --&gt; |\"stake(credentials, ETH)\"|EPM\n    EPM --&gt; |\"deploy &amp; initialize\"|EP[EigenPod]\n    EP --&gt; |\"depositToEth2(ETH)\"|DC[ETH Deposit Contract]\n    EP --&gt; |\"recordBalanceUpdate()\"|EPM\n    EPM --&gt; |\"increaseDelegatedShares()\"|DM[DelegationManager]\n    DM --&gt; |\"removeDepositShares()\"|EPM\n    DM --&gt; |\"withdrawSharesAsTokens()\"|EPM\n    EPM --&gt; |\"withdrawRestakedETH()\"|EP\n    EP --&gt; |send ETH|User\n\n    subgraph EigenLayer Core\n        DM\n        EPM\n    end\n\n    subgraph Ethereum Staking\n        EP\n        DC\n    end</code></pre>"},{"location":"code/pods/EigenPodManager/#dependencies-and-interactions","title":"Dependencies and Interactions","text":""},{"location":"code/pods/EigenPodManager/#external-dependencies","title":"External Dependencies","text":"<ul> <li>OpenZeppelin Contracts: For secure implementations of standard patterns such as <code>Create2</code>, upgradeable contracts, and reentrancy guards</li> <li>ETH2 Deposit Contract: Interfaced through <code>IETHPOSDeposit</code> to stake ETH on the beacon chain</li> <li>BeaconProxy Pattern: Used for creating upgradeable EigenPods</li> </ul>"},{"location":"code/pods/EigenPodManager/#internal-contract-interactions","title":"Internal Contract Interactions","text":"<ul> <li>EigenPod: Individual user pods that interface directly with the ETH2 deposit contract and manage validator operations</li> <li>DelegationManager: Manages delegation relationships between stakers and operators</li> <li>BeaconChainETHStrategy: Represents the strategy for beacon chain ETH in the EigenLayer system</li> </ul> <p>The EigenPodManager acts as a crucial bridge between individual EigenPods (which handle direct beacon chain interactions) and the broader EigenLayer system (represented by the DelegationManager). It coordinates share accounting, deployment of new pods, and ensures that all restaked ETH is properly tracked and represented within the EigenLayer protocol.</p> <p>The contract implements a sophisticated slashing mechanism that allows for partial slashings by tracking a slashing factor for each pod owner. When a negative balance delta is reported (indicating a reduction in a validator's balance), the pod owner's slashing factor is decreased proportionally, devaluing their shares instead of directly removing them.</p> <p>Overall, the EigenPodManager serves as the central coordination point for Ethereum validators who want to participate in EigenLayer while maintaining their validator operations.</p>"},{"location":"code/pods/EigenPodManagerStorage/","title":"EigenPodManagerStorage","text":""},{"location":"code/pods/EigenPodManagerStorage/#1-contract-overview","title":"1. Contract Overview","text":"<p>The <code>EigenPodManagerStorage</code> is a foundational abstract storage contract for EigenLayer's pod management system. It serves as the base storage layer for the EigenPodManager contract, which is responsible for managing individual EigenPods - smart contracts that interface with Ethereum's consensus layer staking system.</p>"},{"location":"code/pods/EigenPodManagerStorage/#purpose-and-main-functionality","title":"Purpose and Main Functionality","text":"<p>This contract defines the essential storage variables and constants that are required for managing EigenPods across the EigenLayer protocol. In the EigenLayer ecosystem, EigenPods enable users to \"restake\" their Ethereum validator deposits, allowing them to participate in both Ethereum consensus and EigenLayer's security provision without moving their ETH from the beacon chain.</p>"},{"location":"code/pods/EigenPodManagerStorage/#system-architecture-context","title":"System Architecture Context","text":"<p>The <code>EigenPodManagerStorage</code> sits at a crucial position in the EigenLayer architecture: - It forms the storage foundation for EigenPodManager - It maintains references to individual EigenPods (one per staker) - It interacts with core EigenLayer contracts like DelegationManager - It connects to Ethereum's consensus layer via the ETH2 deposit contract</p>"},{"location":"code/pods/EigenPodManagerStorage/#key-design-patterns","title":"Key Design Patterns","text":"<ol> <li>Proxy Pattern - Uses a beacon proxy pattern for upgradeability</li> <li>Storage Inheritance - Serves as a storage base for derived contracts</li> <li>Immutability where possible - Critical addresses and bytecode are immutable</li> <li>Storage Gap - Implements the OpenZeppelin storage gap pattern to enable safe upgrades</li> </ol>"},{"location":"code/pods/EigenPodManagerStorage/#2-contract-interface","title":"2. Contract Interface","text":""},{"location":"code/pods/EigenPodManagerStorage/#key-state-variables","title":"Key State Variables","text":"<ol> <li>ethPOS (immutable): Interface to the ETH2 deposit contract, allowing stakers to deposit ETH to become validators</li> <li>eigenPodBeacon (immutable): The beacon contract that points to the current implementation of EigenPod</li> <li>delegationManager (immutable): EigenLayer's delegation management contract</li> <li>beaconProxyBytecode (constant): Pre-stored bytecode for creating beacon proxies, ensuring address consistency</li> <li>beaconChainETHStrategy (constant): Virtual strategy representing ETH staked in the beacon chain</li> <li>ownerToPod: Mapping from an owner's address to their deployed EigenPod</li> <li>numPods: Counter for the total number of deployed EigenPods</li> <li>podOwnerDepositShares: Tracks each pod owner's shares in the virtual beacon chain ETH strategy</li> <li>_beaconChainSlashingFactor: Records slashing factors applied to stakers for the beacon chain ETH strategy</li> <li>burnableETHShares: Tracks the amount of shares slashed but not yet burned</li> </ol>"},{"location":"code/pods/EigenPodManagerStorage/#important-events","title":"Important Events","text":"<p>The contract inherits from <code>IEigenPodManager</code> which would define related events, though none are directly implemented in this storage contract.</p>"},{"location":"code/pods/EigenPodManagerStorage/#3-logic-flow","title":"3. Logic Flow","text":"<p>The <code>EigenPodManagerStorage</code> contract primarily serves as a storage layer, so it doesn't implement extensive logic beyond its constructor. However, it establishes the key structures that will drive these main workflows:</p>"},{"location":"code/pods/EigenPodManagerStorage/#eigenpod-deployment-and-management","title":"EigenPod Deployment and Management","text":"<ol> <li>The contract tracks mappings from pod owners to their respective EigenPods</li> <li>It maintains a count of deployed pods through the <code>numPods</code> variable</li> </ol>"},{"location":"code/pods/EigenPodManagerStorage/#deposit-share-management","title":"Deposit Share Management","text":"<ol> <li>The contract stores deposit shares for pod owners via <code>podOwnerDepositShares</code></li> <li>These shares represent a staker's portion of the virtual beacon chain ETH strategy</li> <li>Importantly, shares increase when a balance increases, but do not decrease on balance decreases</li> <li>Instead, a slashing factor is recorded when balances decrease, impacting future withdrawals</li> </ol>"},{"location":"code/pods/EigenPodManagerStorage/#slashing-mechanism","title":"Slashing Mechanism","text":"<ol> <li>The contract tracks slashing factors per staker in <code>_beaconChainSlashingFactor</code></li> <li>It maintains a count of burnable ETH shares through <code>burnableETHShares</code></li> <li>When validators are slashed on Ethereum, this system allows EigenLayer to enforce corresponding penalties</li> </ol>"},{"location":"code/pods/EigenPodManagerStorage/#historical-context","title":"Historical Context","text":"<p>The contract includes several deprecated variables (marked with <code>__deprecated_</code> prefix), showing its evolution over time: - The beacon chain oracle was replaced with direct EIP-4788 integration - Maximum pod limitations were removed - The Deneb fork timestamp is no longer directly tracked here</p>"},{"location":"code/pods/EigenPodManagerStorage/#4-visual-representation","title":"4. Visual Representation","text":"<pre><code>flowchart TD\n    User[User/Staker] --&gt;|Deploys| EPM[EigenPodManager]\n    EPM --&gt;|Creates &amp; Manages| EP[EigenPod]\n    EP --&gt;|Stakes ETH via| ETHPOS[ETH POS Deposit Contract]\n    EP --&gt;|Interfaces with| BeaconChain[Ethereum Beacon Chain]\n\n    EPM --&gt;|Inherits storage from| EPMS[EigenPodManagerStorage]\n    EPMS --&gt;|References| DM[DelegationManager]\n    EPMS --&gt;|Uses| EB[EigenPodBeacon]\n\n    EB --&gt;|Points to implementation of| EP\n\n    EPMS --&gt;|Tracks| VS[Virtual Beacon Chain ETH Strategy]\n    VS --&gt;|Represents| BeaconStake[ETH Staked on Beacon Chain]\n\n    EPMS --&gt;|Records| Shares[Pod Owner Shares]\n    EPMS --&gt;|Maintains| SF[Slashing Factors]</code></pre>"},{"location":"code/pods/EigenPodManagerStorage/#5-dependencies-and-interactions","title":"5. Dependencies and Interactions","text":""},{"location":"code/pods/EigenPodManagerStorage/#external-contracts","title":"External Contracts","text":"<ol> <li>IETHPOSDeposit (ethPOS)</li> <li>Official Ethereum Deposit Contract interface</li> <li>Enables deposits of 32 ETH to create validators on Ethereum's consensus layer</li> <li> <p>Critical for allowing EigenPods to register with the beacon chain</p> </li> <li> <p>IBeacon (eigenPodBeacon)</p> </li> <li>OpenZeppelin's beacon contract interface</li> <li>Points to the current implementation of EigenPod</li> <li> <p>Enables upgradeability of EigenPods without changing their addresses</p> </li> <li> <p>IDelegationManager (delegationManager)</p> </li> <li>Core EigenLayer contract for managing delegations</li> <li>Handles the accounting logic for deposits, withdrawals, and delegations</li> <li>Essential for coordinating between stakers and operators</li> </ol>"},{"location":"code/pods/EigenPodManagerStorage/#other-eigenlayer-interfaces","title":"Other EigenLayer Interfaces","text":"<p>The contract imports several other interfaces: - IStrategy: Interface for EigenLayer strategy contracts - IEigenPodManager: Interface for the EigenPodManager contract - IStrategyManager: Interface for managing strategies in EigenLayer - IEigenPod: Interface for individual EigenPod instances</p>"},{"location":"code/pods/EigenPodManagerStorage/#key-interactions","title":"Key Interactions","text":"<ul> <li>EigenPodManager creates EigenPods for stakers using the beacon proxy pattern</li> <li>Each EigenPod interacts with ETH2 deposit contract to manage validator stakes</li> <li>DelegationManager coordinates with EigenPodManager for delegation accounting</li> <li>EigenPods report balance changes back to EigenPodManager, which updates shares and slashing factors</li> </ul> <p>The <code>EigenPodManagerStorage</code> contract establishes a critical foundation for EigenLayer's restaking functionality, enabling Ethereum validators to provide security to multiple networks simultaneously without moving their staked ETH from the beacon chain. This represents a significant innovation in the \"restaking\" concept at the heart of EigenLayer's design.</p>"},{"location":"code/pods/EigenPodPausingConstants/","title":"EigenPodPausingConstants","text":""},{"location":"code/pods/EigenPodPausingConstants/#contract-overview","title":"Contract Overview","text":"<p><code>EigenPodPausingConstants</code> is a foundational abstract contract that defines a set of standardized constants used to control various pausing mechanisms throughout the EigenLayer protocol's pod system. Its primary purpose is to centralize the definition of pause flags that control the operational states of EigenPods and the EigenPodManager.</p> <p>This contract fits into the EigenLayer architecture as a base component that enables consistent governance-controlled pause functionality across the pod system. EigenLayer is a protocol that allows ETH stakers to restake their assets and provide security to other applications, and the pausing mechanisms defined here are critical for managing risk in this system.</p> <p>The contract employs a simple but effective design pattern for pausing functionality using uint8 constants as bit flags. This approach allows for granular control over different aspects of the system, enabling selective pausing of specific functions rather than shutting down the entire protocol during maintenance or emergencies.</p>"},{"location":"code/pods/EigenPodPausingConstants/#contract-interface","title":"Contract Interface","text":""},{"location":"code/pods/EigenPodPausingConstants/#key-state-variables","title":"Key State Variables","text":"<p>The contract contains no state variables, only constants. These constants are integer indices representing different pause flags:</p> <ul> <li><code>PAUSED_NEW_EIGENPODS (0)</code>: Controls the creation of new EigenPods</li> <li><code>PAUSED_WITHDRAW_RESTAKED_ETH (1)</code>: Controls withdrawal functionality in EigenPodManager</li> <li><code>PAUSED_EIGENPODS_VERIFY_CREDENTIALS (2)</code>: Controls deposit-related functions in EigenPods</li> <li><code>PAUSED_NON_PROOF_WITHDRAWALS (5)</code>: Controls \"accidental transfer\" withdrawal methods</li> <li><code>PAUSED_START_CHECKPOINT (6)</code>: Controls checkpoint initialization</li> <li><code>PAUSED_EIGENPODS_VERIFY_CHECKPOINT_PROOFS (7)</code>: Controls the verification of checkpoint proofs</li> <li><code>PAUSED_VERIFY_STALE_BALANCE (8)</code>: Controls stale balance verification</li> </ul> <p>There are also deprecated flags (indices 3 and 4) that were previously used but have been removed from active use.</p> <p>The contract contains no functions or events as it serves purely as a constants repository.</p>"},{"location":"code/pods/EigenPodPausingConstants/#logic-flow","title":"Logic Flow","text":"<p>This contract doesn't implement any logic flows directly. Instead, it provides a standardized set of constants that are used by other contracts (EigenPod and EigenPodManager) to implement their pausing logic. </p> <p>The pausing mechanism likely works as follows:</p> <ol> <li>The system maintains a bitmap where each bit position corresponds to one of these constants</li> <li>When a specific bit is set to 1, the corresponding functionality is paused</li> <li>Before executing sensitive operations, the inheriting contracts check these flags</li> <li>If the relevant flag is set, the operation is rejected</li> </ol> <p>This approach allows for precise control over system functionality, enabling administrators to pause specific features without disrupting the entire system, which is crucial for a protocol managing staked ETH.</p>"},{"location":"code/pods/EigenPodPausingConstants/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[EigenPodPausingConstants] --&gt;|Inherited by| B[EigenPodManager]\n    A --&gt;|Inherited by| C[EigenPod]\n\n    D[Governance] --&gt;|Controls pause flags in| B\n\n    B --&gt;|Uses PAUSED_NEW_EIGENPODS| E[Pod Creation]\n    B --&gt;|Uses PAUSED_WITHDRAW_RESTAKED_ETH| F[ETH Withdrawals]\n\n    C --&gt;|Uses PAUSED_EIGENPODS_VERIFY_CREDENTIALS| G[Deposit Verification]\n    C --&gt;|Uses PAUSED_NON_PROOF_WITHDRAWALS| H[Emergency Withdrawals]\n    C --&gt;|Uses PAUSED_START_CHECKPOINT| I[Checkpoint Initialization]\n    C --&gt;|Uses PAUSED_EIGENPODS_VERIFY_CHECKPOINT_PROOFS| J[Proof Verification]\n    C --&gt;|Uses PAUSED_VERIFY_STALE_BALANCE| K[Stale Balance Checks]</code></pre>"},{"location":"code/pods/EigenPodPausingConstants/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p><code>EigenPodPausingConstants</code> does not interact directly with other contracts. Instead, it is designed to be inherited by both the EigenPod and EigenPodManager contracts, which then use these constants to implement consistent pausing behavior.</p> <p>The inheriting contracts would typically:</p> <ol> <li>Maintain a bitmap of currently active pause flags</li> <li>Provide administrative functions to set or clear specific flags</li> <li>Include modifiers that check these flags before executing sensitive operations</li> <li>Revert transactions that attempt to execute paused functionality</li> </ol> <p>The pausing system appears to be particularly focused on risk management for ETH staking operations, including deposit verification, withdrawal processes, and proof verification - all critical aspects of a secure staking system.</p> <p>This contract represents an elegant solution for centralizing pause constants, ensuring that both the pod manager and individual pods operate with consistent understanding of what each pause flag means, which is essential for maintaining system integrity during upgrades or when responding to potential security incidents.</p>"},{"location":"code/pods/EigenPodStorage/","title":"EigenPodStorage","text":""},{"location":"code/pods/EigenPodStorage/#contract-overview","title":"Contract Overview","text":"<p>EigenPodStorage is an abstract smart contract that serves as the foundational storage layer for EigenPods in the EigenLayer protocol. An EigenPod is a specialized contract that enables Ethereum validators to restake their ETH into EigenLayer while maintaining their validator operations on the Beacon Chain. This contract specifically handles the storage aspects of an EigenPod without implementing the logic functions.</p> <p>The primary purpose of this storage contract is to maintain the state of a validator's participation in EigenLayer, tracking information such as the pod owner, active validators, checkpoint data, and balances. It acts as a bridge between the Ethereum consensus layer (Beacon Chain) and EigenLayer's restaking ecosystem.</p> <p>EigenPodStorage utilizes the inheritance pattern for organizing contract code, providing a clean separation between storage variables and implementation logic. This design pattern helps with upgradeability and maintaining a clear contract structure.</p>"},{"location":"code/pods/EigenPodStorage/#contract-interface","title":"Contract Interface","text":""},{"location":"code/pods/EigenPodStorage/#key-state-variables","title":"Key State Variables","text":"<ul> <li> <p>podOwner: The address of the EigenPod owner, who has primary control over the pod and its associated validators.</p> </li> <li> <p>restakedExecutionLayerGwei: Tracks the amount of ETH (in Gwei) that has been withdrawn from the Beacon Chain but remains staked in EigenLayer.</p> </li> <li> <p>_validatorPubkeyHashToInfo: A mapping that stores validator information indexed by the hash of their public key. This mapping is central to tracking the status of validators associated with this pod.</p> </li> <li> <p>activeValidatorCount: The number of validators with proven withdrawal credentials who have not yet fully withdrawn. This helps track the size and activity of the pod.</p> </li> <li> <p>lastCheckpointTimestamp and currentCheckpointTimestamp: Track the timing of checkpoints, which are snapshots of validator statuses and balances.</p> </li> <li> <p>checkpointBalanceExitedGwei: A mapping that records the total balance attributed to exited validators (in Gwei) for each checkpoint.</p> </li> <li> <p>_currentCheckpoint: Stores data about the current active checkpoint, if there is one.</p> </li> <li> <p>proofSubmitter: An address designated by the pod owner with permissions to submit proofs on behalf of the owner, allowing the actual owner to remain a cold wallet.</p> </li> </ul> <p>Many deprecated variables are noted in the contract with the <code>__deprecated_</code> prefix, indicating the evolution of the contract's design over time.</p>"},{"location":"code/pods/EigenPodStorage/#publicexternal-functions","title":"Public/External Functions","text":"<p>While this is primarily a storage contract, it inherits from IEigenPod interface which would define functions to be implemented by the concrete EigenPod contract. The storage contract itself doesn't implement these functions but sets up the state variables they will use.</p>"},{"location":"code/pods/EigenPodStorage/#events","title":"Events","text":"<p>The contract itself doesn't define events, but as an implementation of IEigenPod, it would be expected to emit events defined in that interface when state changes occur.</p>"},{"location":"code/pods/EigenPodStorage/#logic-flow","title":"Logic Flow","text":"<p>Since EigenPodStorage is an abstract storage contract, it doesn't implement the logic flow directly. However, we can infer the intended flow from the state variables:</p> <ol> <li> <p>Pod Creation and Ownership: A pod is created for a specific owner (podOwner), who can designate a separate address (proofSubmitter) for certain operational tasks.</p> </li> <li> <p>Validator Registration: Validators are registered with the pod, with their information stored in the _validatorPubkeyHashToInfo mapping.</p> </li> <li> <p>Checkpoint Management: The system periodically creates checkpoints to track validator balances and status changes:</p> </li> <li>A checkpoint is started (setting currentCheckpointTimestamp)</li> <li>Proofs are submitted for validators</li> <li> <p>The checkpoint is processed and finalized (updating lastCheckpointTimestamp)</p> </li> <li> <p>Exit Tracking: When validators exit the Beacon Chain, their exited balances are tracked in checkpointBalanceExitedGwei, which helps account for ETH that should be withdrawable.</p> </li> <li> <p>Restaking Management: The contract tracks ETH that has been withdrawn from the Beacon Chain but remains staked in EigenLayer (restakedExecutionLayerGwei).</p> </li> </ol> <p>The contract includes detailed comments explaining important edge cases in the exit tracking logic, noting that the exited balance calculations might not always perfectly capture what is typically considered a \"full exit\" due to timing of deposits and withdrawals.</p>"},{"location":"code/pods/EigenPodStorage/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[Pod Owner] --&gt;|Creates| B[EigenPod]\n    A --&gt;|Designates| C[Proof Submitter]\n    C --&gt;|Submits Proofs| B\n    D[Validator] --&gt;|Registers with| B\n    B --&gt;|Tracks| E[Validator Info]\n    B --&gt;|Manages| F[Checkpoints]\n    F --&gt;|Records| G[Exit Balances]\n    H[Beacon Chain] --&gt;|Withdrawals| B\n    B --&gt;|Restakes in| I[EigenLayer]\n\n    subgraph EigenPod Storage\n        E\n        F\n        G\n        J[Restaked ETH]\n    end</code></pre>"},{"location":"code/pods/EigenPodStorage/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>EigenPodStorage depends on:</p> <ol> <li> <p>IEigenPod Interface: The contract implements this interface, which defines the expected API for an EigenPod.</p> </li> <li> <p>External Systems:</p> </li> <li>Beacon Chain: While not directly referenced in the code, the contract is designed to interact with the Ethereum Beacon Chain, tracking validator statuses and withdrawals.</li> <li> <p>EigenLayer Protocol: The contract serves as a component in the broader EigenLayer ecosystem, enabling ETH restaking.</p> </li> <li> <p>Implementation Contracts: As an abstract storage contract, EigenPodStorage is meant to be inherited by concrete implementation contracts that provide the actual logic for operations like verifying withdrawal credentials, processing checkpoints, and managing withdrawals.</p> </li> </ol> <p>The storage contract includes a storage gap (<code>__gap</code>) with 35 reserved slots to allow for future upgrades without disrupting the storage layout, which is a best practice for upgradeable contracts.</p> <p>The extensive use of deprecated variables indicates that this contract has evolved significantly, likely in response to changes in the Ethereum protocol (particularly around withdrawals) and improvements to the EigenLayer design.</p>"},{"location":"code/strategies/EigenStrategy/","title":"EigenStrategy","text":""},{"location":"code/strategies/EigenStrategy/#1-contract-overview","title":"1. Contract Overview","text":""},{"location":"code/strategies/EigenStrategy/#purpose-and-main-functionality","title":"Purpose and Main Functionality","text":"<p>The <code>EigenStrategy</code> smart contract is a specialized implementation of Ethereum's EigenLayer protocol that serves as a strategy for managing both EIGEN and bEIGEN tokens. It functions similarly to an ERC4626 tokenized vault but without issuing a token. The contract's primary purpose is to enable users to deposit either EIGEN or bEIGEN tokens and automatically handle the conversion between these two token types when necessary.</p>"},{"location":"code/strategies/EigenStrategy/#system-architecture-position","title":"System Architecture Position","text":"<p>This contract inherits from <code>StrategyBase</code> and implements functionality specific to the EIGEN token ecosystem. It acts as an intermediary layer between token holders and the broader EigenLayer staking system. In the EigenLayer architecture, this contract serves as a specialized strategy that the StrategyManager can interact with for handling EIGEN-specific tokenomics.</p>"},{"location":"code/strategies/EigenStrategy/#key-design-patterns","title":"Key Design Patterns","text":"<ol> <li> <p>Proxy Pattern: The contract is designed to be initializable rather than having constructor-initialized storage, indicating it's meant to be deployed behind a proxy.</p> </li> <li> <p>Hook Pattern: Implements hook functions (<code>_beforeDeposit</code>, <code>_beforeWithdrawal</code>, <code>_afterWithdrawal</code>) that are called during key operations and can be overridden by derived contracts.</p> </li> <li> <p>Virtual Shares Mitigation: Addresses the \"inflation attack\" vulnerability common in tokenized vault designs by using share and balance offsets.</p> </li> <li> <p>Storage Gap Pattern: Includes a storage gap (<code>__gap</code>) to allow for future version upgrades without storage collision issues.</p> </li> </ol>"},{"location":"code/strategies/EigenStrategy/#2-contract-interface","title":"2. Contract Interface","text":""},{"location":"code/strategies/EigenStrategy/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li><code>initialize(IEigen _EIGEN, IERC20 _bEIGEN)</code>: Initializes the contract with addresses for EIGEN and bEIGEN tokens.</li> <li>Inherits functions from <code>StrategyBase</code> including deposit and withdrawal functionality.</li> </ul>"},{"location":"code/strategies/EigenStrategy/#important-state-variables","title":"Important State Variables","text":"<ul> <li><code>EIGEN</code>: Interface to the EIGEN token contract, which allows wrapping/unwrapping between EIGEN and bEIGEN.</li> <li>Inherits <code>underlyingToken</code> from <code>StrategyBase</code>, which represents the bEIGEN token.</li> </ul>"},{"location":"code/strategies/EigenStrategy/#3-logic-flow","title":"3. Logic Flow","text":""},{"location":"code/strategies/EigenStrategy/#deposit-flow","title":"Deposit Flow","text":"<ol> <li>When a user deposits tokens, <code>_beforeDeposit</code> is called to check if the token is either EIGEN or bEIGEN.</li> <li>If the user is depositing EIGEN tokens:</li> <li>The contract unwraps EIGEN into bEIGEN at a 1:1 ratio</li> <li>This bEIGEN is then used for the actual deposit</li> <li>If the user is depositing bEIGEN directly:</li> <li>The deposit proceeds normally as in the base strategy</li> <li>Shares are calculated for the deposited amount using the StrategyBase logic which includes protections against inflation attacks</li> </ol>"},{"location":"code/strategies/EigenStrategy/#withdrawal-flow","title":"Withdrawal Flow","text":"<ol> <li>When a user withdraws tokens, <code>_beforeWithdrawal</code> verifies the requested token type (EIGEN or bEIGEN)</li> <li>The contract calculates the appropriate number of shares to burn based on the requested withdrawal amount</li> <li>In <code>_afterWithdrawal</code>:</li> <li>If the user wants to withdraw as EIGEN:<ul> <li>The contract wraps bEIGEN into EIGEN at a 1:1 ratio</li> <li>The resulting EIGEN tokens are transferred to the recipient</li> </ul> </li> <li>If the user wants to withdraw as bEIGEN:<ul> <li>The bEIGEN tokens are transferred directly to the recipient</li> </ul> </li> </ol>"},{"location":"code/strategies/EigenStrategy/#security-mechanisms","title":"Security Mechanisms","text":"<ul> <li>Inflation Attack Protection: Uses virtual shares mitigation to prevent manipulation of share price during initial deposits.</li> <li>Token Verification: Validates token types in deposit and withdrawal operations.</li> <li>Pausability: Inherits pause functionality from StrategyBase, allowing emergency halting of operations.</li> </ul>"},{"location":"code/strategies/EigenStrategy/#4-visual-representation","title":"4. Visual Representation","text":"<pre><code>flowchart TD\n    User[User] --&gt; |Deposit EIGEN/bEIGEN| EigenStrategy\n    EigenStrategy --&gt; |If EIGEN| A[Unwrap to bEIGEN]\n    A --&gt; B[Calculate shares]\n    EigenStrategy --&gt; |If bEIGEN| B\n\n    User --&gt; |Withdraw to EIGEN/bEIGEN| C[Request Withdrawal]\n    C --&gt; D[Calculate bEIGEN amount]\n    D --&gt; |If withdraw as EIGEN| E[Wrap bEIGEN to EIGEN]\n    E --&gt; F[Transfer EIGEN to user]\n    D --&gt; |If withdraw as bEIGEN| G[Transfer bEIGEN to user]\n\n    EigenStrategy --&gt; |Reports balances| StrategyManager[Strategy Manager]</code></pre>"},{"location":"code/strategies/EigenStrategy/#5-dependencies-and-interactions","title":"5. Dependencies and Interactions","text":""},{"location":"code/strategies/EigenStrategy/#external-contract-dependencies","title":"External Contract Dependencies","text":"<ul> <li>IStrategyManager: The contract interacts with the Strategy Manager to register deposits and withdrawals.</li> <li>IEigen: Interface for the EIGEN token that allows wrapping and unwrapping between EIGEN and bEIGEN.</li> <li>IERC20: Standard interface for ERC20 tokens, used for bEIGEN interactions.</li> <li>IPauserRegistry: Registry of addresses that can pause the contract's functionality in emergency situations.</li> </ul>"},{"location":"code/strategies/EigenStrategy/#libraries-used","title":"Libraries Used","text":"<ul> <li>SafeERC20: Provides safe methods for interacting with ERC20 tokens, preventing common pitfalls like tokens that don't return boolean values.</li> </ul>"},{"location":"code/strategies/EigenStrategy/#key-interactions","title":"Key Interactions","text":"<ol> <li>Wrapping/Unwrapping: The strategy interacts with the EIGEN token contract to wrap bEIGEN into EIGEN and unwrap EIGEN into bEIGEN as needed during deposits and withdrawals.</li> <li>Token Transfers: Uses SafeERC20 to handle token transfers securely.</li> <li>Strategy Management: Implicitly interacts with StrategyManager through the inherited StrategyBase functionality to manage user deposits.</li> </ol> <p>The EigenStrategy serves as a bridge between the EIGEN and bEIGEN token ecosystems in the EigenLayer protocol, enabling users to seamlessly deposit and withdraw either token type while the strategy itself maintains accounting in terms of bEIGEN.</p>"},{"location":"code/strategies/StrategyBase/","title":"StrategyBase","text":""},{"location":"code/strategies/StrategyBase/#contract-overview","title":"Contract Overview","text":"<p>StrategyBase is a foundational smart contract in the EigenLayer ecosystem that implements the IStrategy interface. It serves as a base layer for more complex investment strategies, providing essential functionality for managing deposits and withdrawals of tokens within the EigenLayer protocol.</p> <p>The primary purpose of this contract is to provide a secure and standardized way to handle token deposits that can be staked in EigenLayer, while implementing key security mechanisms to prevent common DeFi vulnerabilities like share inflation attacks. In essence, it works similarly to an ERC4626 tokenized vault, but without issuing its own token.</p> <p>This contract fits into the EigenLayer architecture as the base implementation for all strategies that users can deposit into. The StrategyManager contract (which is referenced as an immutable variable) maintains the accounting of each user's shares within strategies, while the strategies themselves handle the tokens and implement the actual investment logic.</p> <p>Key design patterns used include: - Proxy pattern (through Initializable) for upgradability - Security mechanisms against share inflation attacks - Hook pattern for extensibility (_beforeDeposit, _beforeWithdrawal, etc.) - Access control pattern (onlyStrategyManager modifier)</p>"},{"location":"code/strategies/StrategyBase/#contract-interface","title":"Contract Interface","text":""},{"location":"code/strategies/StrategyBase/#key-state-variables","title":"Key State Variables","text":"<ul> <li><code>strategyManager</code>: Immutable reference to EigenLayer's StrategyManager contract</li> <li><code>underlyingToken</code>: The ERC20 token that this strategy accepts and manages</li> <li><code>totalShares</code>: The total number of shares issued by this strategy</li> <li><code>SHARES_OFFSET</code> and <code>BALANCE_OFFSET</code>: Constants used to mitigate share inflation attacks</li> </ul>"},{"location":"code/strategies/StrategyBase/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li><code>initialize(IERC20 _underlyingToken)</code>: Sets up the strategy with its underlying token</li> <li><code>deposit(IERC20 token, uint256 amount)</code>: Accepts token deposits and issues shares in return</li> <li><code>withdraw(address recipient, IERC20 token, uint256 amountShares)</code>: Burns shares and returns underlying tokens</li> <li><code>sharesToUnderlying(uint256 amountShares)</code>: Converts a share amount to its underlying token value</li> <li><code>underlyingToShares(uint256 amountUnderlying)</code>: Converts an underlying token amount to shares</li> <li><code>userUnderlying(address user)</code>: Returns the underlying token value of a user's shares</li> <li><code>shares(address user)</code>: Returns the number of shares owned by a user</li> </ul>"},{"location":"code/strategies/StrategyBase/#events-emitted","title":"Events Emitted","text":"<ul> <li><code>StrategyTokenSet</code>: Emitted when the underlying token is set during initialization</li> <li><code>ExchangeRateEmitted</code>: Records the current exchange rate between shares and underlying tokens</li> </ul>"},{"location":"code/strategies/StrategyBase/#logic-flow","title":"Logic Flow","text":""},{"location":"code/strategies/StrategyBase/#initialization-flow","title":"Initialization Flow","text":"<ol> <li>The contract is deployed with an immutable reference to the StrategyManager</li> <li>The <code>initialize</code> function is called to set the underlying token for the strategy</li> <li>The contract is now ready to accept deposits</li> </ol>"},{"location":"code/strategies/StrategyBase/#deposit-flow","title":"Deposit Flow","text":"<ol> <li>The StrategyManager transfers tokens to the strategy contract</li> <li>The StrategyManager calls the strategy's <code>deposit</code> function</li> <li><code>_beforeDeposit</code> hook is executed to verify the token and perform any pre-deposit checks</li> <li>New shares are calculated based on the current exchange rate, taking into account virtual shares and balance offsets</li> <li>The total share count is updated and exchange rate is emitted</li> <li>The new shares amount is returned to StrategyManager for accounting</li> </ol>"},{"location":"code/strategies/StrategyBase/#withdrawal-flow","title":"Withdrawal Flow","text":"<ol> <li>StrategyManager calls the strategy's <code>withdraw</code> function with shares to burn</li> <li><code>_beforeWithdrawal</code> hook is executed for validation and any custom logic</li> <li>The amount of underlying tokens to send is calculated based on share value</li> <li>Total shares are reduced</li> <li>The exchange rate is emitted</li> <li><code>_afterWithdrawal</code> hook is called, which transfers tokens to the recipient</li> </ol>"},{"location":"code/strategies/StrategyBase/#security-mechanisms","title":"Security Mechanisms","text":"<p>The contract uses two key mechanisms to prevent share inflation attacks: 1. Virtual shares (<code>SHARES_OFFSET = 1e3</code>): An offset added to totalShares for calculations 2. Virtual balance (<code>BALANCE_OFFSET = 1e3</code>): An offset added to token balance for calculations</p> <p>These mechanisms protect against first-depositor attacks where they could manipulate the share price by depositing and withdrawing with carefully chosen amounts.</p> <p>Additionally, the contract implements pausable functionality for both deposits and withdrawals, allowing emergency response in case of discovered vulnerabilities.</p>"},{"location":"code/strategies/StrategyBase/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    User--&gt;|\"deposit()\"|StrategyManager\n    StrategyManager--&gt;|\"transfer tokens\"|StrategyBase\n    StrategyManager--&gt;|\"deposit()\"|StrategyBase\n    StrategyBase--&gt;|\"_beforeDeposit()\"|StrategyBase\n    StrategyBase--&gt;|\"calculate shares\"|StrategyBase\n    StrategyBase--&gt;|\"update totalShares\"|StrategyBase\n    StrategyBase--&gt;|\"return new shares\"|StrategyManager\n    StrategyManager--&gt;|\"record shares\"|StrategyManager\n\n    User--&gt;|\"withdraw()\"|StrategyManager\n    StrategyManager--&gt;|\"withdraw()\"|StrategyBase\n    StrategyBase--&gt;|\"_beforeWithdrawal()\"|StrategyBase\n    StrategyBase--&gt;|\"calculate tokens\"|StrategyBase\n    StrategyBase--&gt;|\"update totalShares\"|StrategyBase\n    StrategyBase--&gt;|\"_afterWithdrawal()\"|StrategyBase\n    StrategyBase--&gt;|\"transfer tokens\"|User\n    StrategyBase--&gt;|\"return\"|StrategyManager\n    StrategyManager--&gt;|\"update shares\"|StrategyManager</code></pre>"},{"location":"code/strategies/StrategyBase/#dependencies-and-interactions","title":"Dependencies and Interactions","text":""},{"location":"code/strategies/StrategyBase/#contract-dependencies","title":"Contract Dependencies","text":"<ul> <li><code>IStrategyManager</code>: Interface for interacting with EigenLayer's StrategyManager</li> <li><code>Pausable</code>: Provides functions to pause/unpause contract functionality</li> <li><code>SemVerMixin</code>: Adds semantic versioning capability to track contract versions</li> <li><code>Initializable</code>: OpenZeppelin's upgradable contract functionality</li> <li><code>IERC20</code> and <code>SafeERC20</code>: Standard interfaces and utilities for ERC20 token interactions</li> </ul>"},{"location":"code/strategies/StrategyBase/#external-interactions","title":"External Interactions","text":"<ul> <li>StrategyManager: The primary interaction point which:</li> <li>Tracks user deposits and withdrawals</li> <li>Manages user share balances across strategies</li> <li> <p>Calls deposit/withdraw functions on strategies after transferring tokens</p> </li> <li> <p>Tokens: The contract interacts with the underlying ERC20 token to:</p> </li> <li>Check balances</li> <li>Transfer tokens during withdrawals</li> </ul>"},{"location":"code/strategies/StrategyBase/#child-contract-expectations","title":"Child Contract Expectations","text":"<p>This contract is designed to be inherited by more complex strategies which can override: - <code>_beforeDeposit</code>: For custom validation or logic before deposits - <code>_beforeWithdrawal</code>: For custom validation or logic before withdrawals - <code>_afterWithdrawal</code>: To customize how underlying tokens are returned - <code>_tokenBalance</code>: In case a more complex strategy needs custom balance calculation</p> <p>The contract explicitly notes that it's not intended for use with fee-on-transfer tokens, as this would break the accounting assumptions within the deposit and withdrawal logic.</p>"},{"location":"code/strategies/StrategyBaseTVLLimits/","title":"StrategyBaseTVLLimits","text":""},{"location":"code/strategies/StrategyBaseTVLLimits/#contract-overview","title":"Contract Overview","text":"<p>StrategyBaseTVLLimits is a specialized implementation of the StrategyBase contract that introduces maximum deposit limits to control the total value locked (TVL) within the strategy. This contract serves two primary purposes:</p> <ol> <li>It limits the maximum amount of tokens that can be deposited in a single transaction</li> <li>It caps the total amount of deposits that the strategy will accept overall</li> </ol> <p>The contract is designed as part of the EigenLayer protocol's strategy architecture, providing a way to implement prudent risk management for strategies that might need to control their exposure or growth rate. This approach is common in DeFi protocols that wish to limit risk during early stages or for specific asset classes.</p> <p>The contract uses the upgradeable proxy pattern, as evidenced by the <code>initializer</code> modifier and storage gap, allowing for future upgrades while preserving state. It also follows the inheritance pattern, extending StrategyBase while adding TVL limitation functionality.</p>"},{"location":"code/strategies/StrategyBaseTVLLimits/#contract-interface","title":"Contract Interface","text":""},{"location":"code/strategies/StrategyBaseTVLLimits/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li> <p>initialize(uint256 _maxPerDeposit, uint256 _maxTotalDeposits, IERC20 _underlyingToken): Initializes the strategy with TVL limits and underlying token, can only be called once due to the initializer modifier.</p> </li> <li> <p>setTVLLimits(uint256 newMaxPerDeposit, uint256 newMaxTotalDeposits): Allows the unpauser to update the maximum per-deposit and total deposit limits.</p> </li> <li> <p>getTVLLimits(): Returns the current maximum per-deposit and maximum total deposit values.</p> </li> </ul>"},{"location":"code/strategies/StrategyBaseTVLLimits/#important-events","title":"Important Events","text":"<ul> <li> <p>MaxPerDepositUpdated(uint256 previousValue, uint256 newValue): Emitted when the maximum per-deposit limit is changed.</p> </li> <li> <p>MaxTotalDepositsUpdated(uint256 previousValue, uint256 newValue): Emitted when the maximum total deposits limit is changed.</p> </li> </ul>"},{"location":"code/strategies/StrategyBaseTVLLimits/#key-state-variables","title":"Key State Variables","text":"<ul> <li> <p>maxPerDeposit: The maximum amount of underlying tokens that can be deposited in a single transaction.</p> </li> <li> <p>maxTotalDeposits: The maximum total amount of underlying tokens the strategy will accept across all deposits.</p> </li> </ul>"},{"location":"code/strategies/StrategyBaseTVLLimits/#logic-flow","title":"Logic Flow","text":"<p>The StrategyBaseTVLLimits contract implements a straightforward but effective approach to deposit limitations:</p> <ol> <li> <p>Initialization: When the strategy is first deployed, the <code>initialize</code> function is called to set up the TVL limits and the underlying token. This can only happen once due to the initializer modifier.</p> </li> <li> <p>Deposit Processing: </p> </li> <li>When a user attempts to deposit tokens, the contract's inherited <code>deposit</code> function from StrategyBase is called.</li> <li>Before processing the deposit, the contract calls the overridden <code>_beforeDeposit</code> hook to enforce TVL limits.</li> <li>The hook verifies that:<ul> <li>The deposit amount doesn't exceed <code>maxPerDeposit</code></li> <li>The current token balance doesn't exceed <code>maxTotalDeposits</code></li> </ul> </li> <li> <p>If either check fails, the transaction reverts</p> </li> <li> <p>Limits Management:</p> </li> <li>The unpauser (a privileged role) can adjust the TVL limits using <code>setTVLLimits</code></li> <li>The contract ensures that <code>maxPerDeposit</code> never exceeds <code>maxTotalDeposits</code></li> <li>Any changes to limits are logged via events</li> </ol> <p>A key design consideration is that the view functions for converting between shares and underlying tokens purposely do not take the TVL limits into account. This allows for accurate calculations even when deposits might be restricted.</p>"},{"location":"code/strategies/StrategyBaseTVLLimits/#security-mechanisms","title":"Security Mechanisms","text":"<p>The contract implements several security features:</p> <ol> <li> <p>Access Control: Only the unpauser can modify the TVL limits, using the <code>onlyUnpauser</code> modifier.</p> </li> <li> <p>Validation Checks: The contract ensures that <code>maxPerDeposit</code> is always less than or equal to <code>maxTotalDeposits</code>.</p> </li> <li> <p>Race Condition Awareness: The contract's documentation explicitly acknowledges potential race conditions that could occur with concurrent deposit attempts or direct token transfers that might push the balance close to the maximum.</p> </li> <li> <p>Upgradeable Pattern: The contract includes a storage gap (<code>__gap</code>) to allow for future upgrades without disrupting the storage layout.</p> </li> </ol>"},{"location":"code/strategies/StrategyBaseTVLLimits/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[User] --&gt;|deposit| B[StrategyManager]\n    B --&gt;|calls deposit| C[StrategyBaseTVLLimits]\n    C --&gt;|_beforeDeposit| D{Check Limits}\n    D --&gt;|amount &gt; maxPerDeposit| E[Revert: MaxPerDepositExceedsMax]\n    D --&gt;|balance &gt; maxTotalDeposits| F[Revert: BalanceExceedsMaxTotalDeposits]\n    D --&gt;|Limits OK| G[Continue with deposit]\n\n    H[Unpauser] --&gt;|setTVLLimits| I[Update maxPerDeposit and maxTotalDeposits]\n    I --&gt;|Emit events| J[MaxPerDepositUpdated &amp; MaxTotalDepositsUpdated]\n\n    K[Anyone] --&gt;|getTVLLimits| L[Return current limits]</code></pre>"},{"location":"code/strategies/StrategyBaseTVLLimits/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The StrategyBaseTVLLimits contract has several key dependencies and interactions:</p> <ol> <li> <p>StrategyBase: This contract inherits from StrategyBase, extending its functionality to include TVL limits. It retains all the base strategy behavior while adding deposit limitations.</p> </li> <li> <p>IStrategyManager: The contract interacts with the StrategyManager contract, which is responsible for coordinating deposits and withdrawals across the EigenLayer system.</p> </li> <li> <p>IPauserRegistry: The contract utilizes a pauser registry to implement access control functionality, particularly for the unpauser role that can modify TVL limits.</p> </li> <li> <p>IERC20: The contract interacts with the underlying ERC20 token that it accepts for deposits.</p> </li> </ol> <p>The primary interaction flow involves users depositing tokens through the StrategyManager, which then calls into this strategy. The strategy applies its TVL limit checks before accepting the deposit. The unpauser role has the ability to adjust these limits as needed, perhaps in response to market conditions or risk management requirements.</p> <p>Note that while the contract implements deposit limitations, it does not modify the share calculation logic from the base strategy. This means that even when deposits are limited, share value calculations remain consistent with the unlimited version of the strategy.</p>"},{"location":"code/strategies/StrategyFactory/","title":"StrategyFactory","text":""},{"location":"code/strategies/StrategyFactory/#contract-overview","title":"Contract Overview","text":"<p>The <code>StrategyFactory</code> is a crucial component in the EigenLayer ecosystem that enables the deployment of standardized strategy contracts for arbitrary ERC20 tokens. Its primary purpose is to act as a factory for generating proxy instances of strategy contracts, which are then automatically whitelisted in the EigenLayer protocol.</p> <p>This factory follows the proxy pattern to create minimal, gas-efficient strategy instances that all share the same implementation logic via a beacon contract. The use of beacon proxies allows for upgrading all deployed strategies simultaneously by updating the single beacon implementation.</p> <p>The contract employs several key design patterns: - Proxy Pattern: Uses OpenZeppelin's BeaconProxy to deploy lightweight clones of the strategy implementation - Factory Pattern: Centralizes the creation of new strategy contracts - Upgradeable Pattern: Inherits from OwnableUpgradeable to support upgradeability - Pausability Pattern: Implements a custom pause mechanism to control strategy creation</p> <p>Within the EigenLayer system, this contract serves as a gateway for expanding the range of assets that can be staked and delegated, allowing for a more diverse and flexible platform.</p>"},{"location":"code/strategies/StrategyFactory/#contract-interface","title":"Contract Interface","text":""},{"location":"code/strategies/StrategyFactory/#state-variables","title":"State Variables","text":"<ul> <li><code>strategyManager</code> (immutable): Reference to EigenLayer's StrategyManager contract which manages the whitelisting of strategies</li> <li><code>strategyBeacon</code> (modifiable): Holds the reference to the beacon contract that contains the strategy implementation</li> <li><code>deployedStrategies</code>: Mapping of token addresses to their corresponding deployed strategy contracts</li> <li><code>isBlacklisted</code>: Mapping that tracks tokens that have been blacklisted from having strategies</li> </ul>"},{"location":"code/strategies/StrategyFactory/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li><code>initialize(address _initialOwner, uint256 _initialPausedStatus, IBeacon _strategyBeacon)</code>: Sets up the contract with initial values, can only be called once</li> <li><code>deployNewStrategy(IERC20 token)</code>: Deploys a new strategy contract for a specified ERC20 token and adds it to the whitelist</li> <li><code>blacklistTokens(IERC20[] calldata tokens)</code>: Owner-only function to prevent specific tokens from having strategies</li> <li><code>whitelistStrategies(IStrategy[] calldata strategiesToWhitelist)</code>: Allows the owner to whitelist existing strategy contracts</li> <li><code>removeStrategiesFromWhitelist(IStrategy[] calldata strategiesToRemoveFromWhitelist)</code>: Allows the owner to remove strategies from the whitelist</li> </ul>"},{"location":"code/strategies/StrategyFactory/#events","title":"Events","text":"<ul> <li><code>StrategySetForToken(IERC20 token, IStrategy strategy)</code>: Emitted when a new strategy is set for a token</li> <li><code>TokenBlacklisted(IERC20 token)</code>: Emitted when a token is blacklisted</li> <li><code>StrategyBeaconModified(IBeacon oldBeacon, IBeacon newBeacon)</code>: Emitted when the strategy beacon is updated</li> </ul>"},{"location":"code/strategies/StrategyFactory/#logic-flow","title":"Logic Flow","text":""},{"location":"code/strategies/StrategyFactory/#strategy-deployment-process","title":"Strategy Deployment Process","text":"<ol> <li>A user or the protocol owner calls <code>deployNewStrategy</code> with an ERC20 token address</li> <li>The contract verifies that:</li> <li>The contract is not in a paused state</li> <li>The specified token is not blacklisted</li> <li>A strategy for this token hasn't already been deployed</li> <li>A new BeaconProxy is created, pointing to the current <code>strategyBeacon</code></li> <li>The proxy is initialized with the token address via the <code>initialize</code> function</li> <li>The new strategy is recorded in the <code>deployedStrategies</code> mapping</li> <li>The strategy is automatically added to the whitelist in the StrategyManager</li> <li>The new strategy address is returned to the caller</li> </ol>"},{"location":"code/strategies/StrategyFactory/#token-blacklisting-process","title":"Token Blacklisting Process","text":"<ol> <li>The owner calls <code>blacklistTokens</code> with an array of token addresses</li> <li>For each token, the contract:</li> <li>Verifies it's not already blacklisted</li> <li>Marks it as blacklisted</li> <li>Emits a <code>TokenBlacklisted</code> event</li> <li>If a strategy exists for this token, adds it to a list for whitelist removal</li> <li>If any existing strategies were found for the blacklisted tokens, they're removed from the StrategyManager's whitelist</li> </ol>"},{"location":"code/strategies/StrategyFactory/#security-mechanisms","title":"Security Mechanisms","text":"<ul> <li>Pausability: The contract can be paused to prevent new strategies from being deployed during emergencies</li> <li>Ownership Controls: Only the contract owner can blacklist tokens or modify the whitelist</li> <li>Token Validation: Warns about potential risks with non-standard ERC20 tokens, particularly reentrant tokens like ERC777</li> <li>Implementation Separation: By using the beacon pattern, the implementation logic is separate from the deployed proxies, reducing the attack surface</li> </ul>"},{"location":"code/strategies/StrategyFactory/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[User/Owner] --&gt;|deployNewStrategy| B[StrategyFactory]\n    B --&gt;|create BeaconProxy| C[New Strategy Proxy]\n    D[Strategy Beacon] --&gt;|provides implementation| C\n    B --&gt;|addStrategiesToDepositWhitelist| E[StrategyManager]\n    A --&gt;|blacklistTokens| B\n    B --&gt;|removeStrategiesFromDepositWhitelist| E\n    A --&gt;|whitelistStrategies| B\n    B --&gt;|addStrategiesToDepositWhitelist| E\n    A --&gt;|removeStrategiesFromWhitelist| B\n    B --&gt;|removeStrategiesFromDepositWhitelist| E\n\n    subgraph EigenLayer Ecosystem\n        E\n        F[Other EigenLayer Components]\n    end\n\n    subgraph Strategy Implementation\n        D\n    end\n\n    subgraph Deployed Strategies\n        C\n        G[Other Strategy Proxies]\n    end</code></pre>"},{"location":"code/strategies/StrategyFactory/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The StrategyFactory interacts with several other contracts:</p> <ol> <li> <p>StrategyManager: The factory communicates with this core EigenLayer contract to whitelist or remove strategies. This ensures that only vetted strategy contracts can be used for deposits within the EigenLayer protocol.</p> </li> <li> <p>Strategy Beacon: This contract holds the implementation logic for all strategy proxies. When the beacon is updated, all deployed proxies will automatically use the new implementation, enabling efficient upgrades.</p> </li> <li> <p>Strategy Proxies: The factory deploys minimal proxy contracts that delegate calls to the implementation defined in the beacon. Each proxy handles a specific ERC20 token.</p> </li> <li> <p>PauserRegistry: Imported through the Pausable contract, it defines which addresses have permission to pause/unpause certain functions.</p> </li> </ol> <p>The factory relies on several external dependencies:</p> <ul> <li>OpenZeppelin Contracts: For the implementation of BeaconProxy and OwnableUpgradeable</li> <li>SemVerMixin: For contract versioning</li> <li>StrategyFactoryStorage: For persistent storage layout</li> <li>StrategyBase: The base implementation of strategies that proxies will delegate to</li> </ul> <p>The contract serves as a bridge between arbitrary ERC20 tokens and the EigenLayer protocol, enabling a flexible and expandable asset system while maintaining centralized control over which strategies are approved for use.</p>"},{"location":"code/strategies/StrategyFactoryStorage/","title":"StrategyFactoryStorage","text":""},{"location":"code/strategies/StrategyFactoryStorage/#contract-overview","title":"Contract Overview","text":"<p>The <code>StrategyFactoryStorage</code> contract serves as the storage layer for the StrategyFactory functionality within what appears to be the EigenLayer protocol. This abstract contract defines the core data structures that track deployed strategies and maintains the system's state without implementing the business logic itself.</p> <p>The primary purpose of this contract is to establish a well-organized storage layout for strategy management, particularly focusing on maintaining references to deployed strategies and their associated token relationships. By separating storage concerns from logic, the system follows a modular design pattern that enhances upgradeability and maintainability.</p> <p>Within the broader system architecture, this contract likely forms the foundation for a factory pattern implementation that standardizes the deployment and tracking of investment strategies. The use of an abstract contract with a storage gap indicates that this is part of an upgradeable contract system, likely using the proxy pattern common in complex DeFi protocols.</p>"},{"location":"code/strategies/StrategyFactoryStorage/#contract-interface","title":"Contract Interface","text":""},{"location":"code/strategies/StrategyFactoryStorage/#key-state-variables","title":"Key State Variables","text":"<ul> <li> <p><code>strategyBeacon</code>: An IBeacon interface reference that serves as the implementation pointer for all newly created strategies. Using the beacon pattern allows for all deployed strategies to be upgraded simultaneously by updating a single beacon contract.</p> </li> <li> <p><code>deployedStrategies</code>: A mapping from ERC20 token addresses to their corresponding Strategy implementations. This mapping tracks which tokens already have strategies deployed for them and provides a way to look up those strategy contracts.</p> </li> <li> <p><code>isBlacklisted</code>: A mapping that indicates which tokens are restricted from having new strategies deployed. This provides a security mechanism to prevent strategies from being created for problematic or vulnerable tokens.</p> </li> <li> <p><code>__gap</code>: A storage gap of 48 unused slots reserved for future contract extensions without causing storage collisions, following OpenZeppelin's upgradeability pattern.</p> </li> </ul>"},{"location":"code/strategies/StrategyFactoryStorage/#events-and-functions","title":"Events and Functions","text":"<p>The contract itself doesn't implement functions or emit events directly. As an abstract storage contract, it inherits from <code>IStrategyFactory</code> which would define the function signatures and events that concrete implementations must provide.</p>"},{"location":"code/strategies/StrategyFactoryStorage/#logic-flow","title":"Logic Flow","text":"<p>While the contract doesn't implement logic directly, we can infer the intended data flow:</p> <ol> <li>The system maintains a beacon contract that holds the implementation address for strategies</li> <li>When a new strategy is deployed (presumably by <code>deployNewStrategy</code> mentioned in comments):</li> <li>The system creates a new beacon proxy pointing to the strategy implementation</li> <li>The relationship between the token and its strategy is stored in <code>deployedStrategies</code></li> <li>The strategy is typically (but not always) whitelisted in a StrategyManager contract</li> <li>Before deploying a strategy, the system checks if the token is blacklisted</li> <li>The contract ensures only one strategy can be deployed per token through this factory, though comments indicate other strategies for the same token might be whitelisted separately</li> </ol>"},{"location":"code/strategies/StrategyFactoryStorage/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[StrategyFactory] --&gt; B[StrategyFactoryStorage]\n    B --&gt; C[strategyBeacon]\n    C --&gt; D[Strategy Implementation]\n    B --&gt; E[deployedStrategies mapping]\n    B --&gt; F[isBlacklisted mapping]\n    A -- deployNewStrategy --&gt; G[New Strategy Proxy]\n    G -- points to --&gt; C\n    E -- tracks --&gt; G\n    H[Token] -- mapped to --&gt; G</code></pre>"},{"location":"code/strategies/StrategyFactoryStorage/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The contract has the following key dependencies:</p> <ol> <li> <p>IStrategyFactory: The interface that defines the functions this storage contract will eventually support when implemented by a concrete factory.</p> </li> <li> <p>IBeacon: While not directly imported, this interface is used for the upgrade beacon that all deployed strategies reference.</p> </li> <li> <p>IERC20: Referenced in mappings to track tokens associated with strategies.</p> </li> <li> <p>IStrategy: The interface that deployed strategy contracts implement.</p> </li> <li> <p>StrategyManager: Mentioned in comments but not directly referenced in code. This appears to be a separate contract that maintains a whitelist of approved strategies.</p> </li> </ol> <p>The storage contract is designed to interact within a larger system where:</p> <ul> <li>A concrete <code>StrategyFactory</code> implementation would use this storage to deploy and manage strategies</li> <li>Each strategy is associated with a specific token</li> <li>The factory maintains a single-strategy-per-token constraint</li> <li>A separate manager component controls which strategies are whitelisted for use</li> <li>All strategies share the same implementation via the beacon pattern, allowing for mass upgrades</li> </ul> <p>This architecture provides a flexible framework for strategy deployment while maintaining system-wide coherence and upgradeability.</p>"},{"location":"code/token/BackingEigen/","title":"BackingEigen","text":""},{"location":"code/token/BackingEigen/#contract-overview","title":"Contract Overview","text":"<p>BackingEigen is a specialized ERC20 token contract that manages the \"bEIGEN\" token, which serves as a backing token for the EIGEN token. The main purpose of this contract is to create a controlled token environment with transfer restrictions, minting capabilities, and governance features.</p> <p>The contract fits into a broader ecosystem where it provides a backing mechanism for the EIGEN token, essentially creating a fully backed relationship between bEIGEN and EIGEN. This architecture enables a controlled token economy where certain addresses have special privileges in the ecosystem.</p> <p>Key design patterns used in this contract include: - Proxy pattern for upgradeability (using OpenZeppelin's upgradeable contracts) - Access control (Ownable pattern for administrative functions) - Token governance (using ERC20Votes extension) - Whitelisting mechanism for transfer controls</p>"},{"location":"code/token/BackingEigen/#contract-interface","title":"Contract Interface","text":""},{"location":"code/token/BackingEigen/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li>initialize(address initialOwner): Initializes the contract with the specified owner, setting up initial state including transfer restrictions and minting the entire supply to the EIGEN token contract.</li> <li>setAllowedFrom(address from, bool isAllowedFrom): Allows the owner to specify addresses that can send tokens to any recipient.</li> <li>setAllowedTo(address to, bool isAllowedTo): Allows the owner to specify addresses that can receive tokens from any sender.</li> <li>setIsMinter(address minterAddress, bool newStatus): Allows the owner to designate addresses that can mint new tokens.</li> <li>mint(address to, uint256 amount): Allows designated minters to create new tokens.</li> <li>burn(uint256 amount): Allows any token holder to burn their own tokens.</li> <li>disableTransferRestrictions(): Allows the owner to permanently disable all transfer restrictions.</li> </ul>"},{"location":"code/token/BackingEigen/#important-events","title":"Important Events","text":"<ul> <li>SetAllowedFrom: Emitted when an address's status in the <code>allowedFrom</code> mapping changes.</li> <li>SetAllowedTo: Emitted when an address's status in the <code>allowedTo</code> mapping changes.</li> <li>TransferRestrictionsDisabled: Emitted when transfer restrictions are permanently disabled.</li> <li>Backed: Emitted when the EIGEN token is fully backed with bEIGEN tokens.</li> <li>IsMinterModified: Emitted when an address's minting privileges are changed.</li> </ul>"},{"location":"code/token/BackingEigen/#key-state-variables","title":"Key State Variables","text":"<ul> <li>EIGEN: Immutable reference to the wrapped EIGEN token contract.</li> <li>transferRestrictionsDisabledAfter: Timestamp after which transfer restrictions no longer apply.</li> <li>allowedFrom: Mapping of addresses that can transfer tokens to any recipient.</li> <li>allowedTo: Mapping of addresses that can receive tokens from any sender.</li> <li>isMinter: Mapping of addresses that have permission to mint new tokens.</li> </ul>"},{"location":"code/token/BackingEigen/#logic-flow","title":"Logic Flow","text":"<p>The BackingEigen contract operates with the following main workflows:</p> <ol> <li>Initialization and Initial Backing:</li> <li>Upon initialization, the contract mints the entire supply of bEIGEN tokens to the EIGEN token contract.</li> <li>This one-time event establishes the backing relationship between bEIGEN and EIGEN.</li> <li> <p>The EIGEN address is whitelisted in both the <code>allowedFrom</code> and <code>allowedTo</code> mappings to facilitate wrapping and unwrapping operations.</p> </li> <li> <p>Transfer Control Mechanism:</p> </li> <li>By default, transfers are restricted to only occur between whitelisted addresses.</li> <li>The contract checks in <code>_beforeTokenTransfer</code> if either:      a) The sender is in the <code>allowedFrom</code> mapping      b) The recipient is in the <code>allowedTo</code> mapping       c) It's a minting operation (from is address(0))</li> <li>If none of these conditions are met, the transfer is rejected.</li> <li> <p>This restriction mechanism remains in place until the owner calls <code>disableTransferRestrictions()</code>.</p> </li> <li> <p>Minting and Burning:</p> </li> <li>Only designated minters (addresses with <code>isMinter[address] == true</code>) can mint new tokens.</li> <li>Any token holder can burn their own tokens using the <code>burn</code> function.</li> <li> <p>Minting and burning operate only after passing the transfer restriction checks.</p> </li> <li> <p>Governance Features:</p> </li> <li>The contract inherits from ERC20VotesUpgradeable, enabling token-based governance.</li> <li> <p>The contract overrides <code>clock()</code> and <code>CLOCK_MODE()</code> to use timestamps instead of block numbers for voting checkpoints.</p> </li> <li> <p>Security Mechanisms:</p> </li> <li>Transfer restrictions provide control over token movement until the ecosystem is ready for unrestricted transfers.</li> <li>Owner-only functions for critical operations like whitelisting and disabling transfer restrictions.</li> <li>Requirement checks to prevent unintended operations.</li> </ol>"},{"location":"code/token/BackingEigen/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[BackingEigen Contract] --&gt; B[Initialize]\n    B --&gt; C[Mint Initial Supply to EIGEN]\n    B --&gt; D[Set Transfer Restrictions]\n    B --&gt; E[Whitelist EIGEN Contract]\n\n    A --&gt; F[Transfer Control]\n    F --&gt; G{Transfer Restrictions Active?}\n    G --&gt;|Yes| H{Sender or Receiver Whitelisted?}\n    H --&gt;|Yes| I[Allow Transfer]\n    H --&gt;|No| J[Reject Transfer]\n    G --&gt;|No| I\n\n    A --&gt; K[Token Management]\n    K --&gt; L[Mint - Only by Authorized Minters]\n    K --&gt; M[Burn - By Token Holders]\n\n    A --&gt; N[Admin Functions]\n    N --&gt; O[Set Allowed From/To]\n    N --&gt; P[Set Minter Status]\n    N --&gt; Q[Disable Transfer Restrictions]\n\n    A --&gt; R[Governance]\n    R --&gt; S[Timestamp-based Voting]</code></pre>"},{"location":"code/token/BackingEigen/#dependencies-and-interactions","title":"Dependencies and Interactions","text":"<p>The BackingEigen contract has the following dependencies and interactions:</p> <ol> <li>OpenZeppelin Dependencies:</li> <li><code>OwnableUpgradeable</code>: Provides owner-based access control for administrative functions.</li> <li><code>ERC20VotesUpgradeable</code>: Extends the standard ERC20 with voting and delegation capabilities.</li> <li> <p><code>IERC20</code>: Interface for interacting with the EIGEN token.</p> </li> <li> <p>Interaction with EIGEN Token:</p> </li> <li>The contract is initialized with a reference to the EIGEN token.</li> <li>The entire supply of bEIGEN is minted to the EIGEN token contract during initialization.</li> <li> <p>Special transfer permissions are given to the EIGEN contract to facilitate wrapping and unwrapping operations.</p> </li> <li> <p>Expected Ecosystem Behavior:</p> </li> <li>The EIGEN contract likely allows users to wrap and unwrap between EIGEN and bEIGEN tokens.</li> <li>The governance features suggest that bEIGEN holders may have voting rights in a broader protocol governance system.</li> <li>The minting capability implies that the supply of bEIGEN might increase over time, potentially based on protocol-specific rules.</li> </ol> <p>This contract serves as a key component in what appears to be a token-based governance system where the EIGEN token is backed 1:1 by bEIGEN, with additional governance features and controlled distribution mechanisms.</p>"},{"location":"code/token/Eigen/","title":"Eigen","text":""},{"location":"code/token/Eigen/#contract-overview","title":"Contract Overview","text":"<p>Eigen.sol is a governance token contract for the Eigen ecosystem that combines ERC20 functionality with governance features. It's designed to serve as a wrapper around a backing token called bEIGEN, providing voting capabilities and controlled distribution through authorized minters.</p> <p>The primary purposes of this contract are to: 1. Enable controlled token distribution through authorized minters 2. Provide token holders with voting rights (via the ERC20Votes extension) 3. Allow wrapping and unwrapping between EIGEN and bEIGEN tokens 4. Control token transfers through a whitelist system until restrictions are lifted</p> <p>The contract implements several key design patterns: - Upgradeable contract pattern (using OpenZeppelin's upgradeable contracts) - Proxy pattern (implied by the use of initializer instead of constructor) - Ownership pattern for privileged operations - Whitelist pattern for controlling token transfers</p>"},{"location":"code/token/Eigen/#contract-interface","title":"Contract Interface","text":""},{"location":"code/token/Eigen/#key-state-variables","title":"Key State Variables","text":"<ul> <li><code>bEIGEN</code>: The immutable address of the backing token</li> <li><code>mintAllowedAfter</code>: Maps minter addresses to timestamps after which they can mint</li> <li><code>mintingAllowance</code>: Maps minter addresses to the amount they're allowed to mint</li> <li><code>transferRestrictionsDisabledAfter</code>: Timestamp after which transfer restrictions are lifted</li> <li><code>allowedFrom</code>: Addresses that can send tokens to anyone even during restrictions</li> <li><code>allowedTo</code>: Addresses that can receive tokens from anyone even during restrictions</li> </ul>"},{"location":"code/token/Eigen/#publicexternal-functions","title":"Public/External Functions","text":"<ul> <li><code>initialize(address initialOwner, address[] memory minters, uint256[] memory mintingAllowances, uint256[] memory mintAllowedAfters)</code>: Initializes the contract with minters and their allowances</li> <li><code>setAllowedFrom(address from, bool isAllowedFrom)</code>: Owner can add/remove addresses from the allowedFrom whitelist</li> <li><code>setAllowedTo(address to, bool isAllowedTo)</code>: Owner can add/remove addresses from the allowedTo whitelist</li> <li><code>disableTransferRestrictions()</code>: Owner can permanently remove transfer restrictions</li> <li><code>mint()</code>: Authorized minters can mint their allotted tokens when allowed</li> <li><code>wrap(uint256 amount)</code>: Users can wrap bEIGEN tokens into EIGEN tokens</li> <li><code>unwrap(uint256 amount)</code>: Users can unwrap EIGEN tokens back to bEIGEN</li> <li><code>multisend(address[] calldata receivers, uint256[] calldata amounts)</code>: Allows batch token transfers</li> <li><code>totalSupply()</code>: Overridden to return the total supply of the backing bEIGEN token</li> </ul>"},{"location":"code/token/Eigen/#important-events","title":"Important Events","text":"<ul> <li><code>SetAllowedFrom(address indexed from, bool isAllowedFrom)</code>: Emitted when an address's allowedFrom status changes</li> <li><code>SetAllowedTo(address indexed to, bool isAllowedTo)</code>: Emitted when an address's allowedTo status changes</li> <li><code>Mint(address indexed minter, uint256 amount)</code>: Emitted when a minter mints tokens</li> <li><code>TransferRestrictionsDisabled()</code>: Emitted when transfer restrictions are disabled</li> </ul>"},{"location":"code/token/Eigen/#logic-flow","title":"Logic Flow","text":""},{"location":"code/token/Eigen/#initialization","title":"Initialization","text":"<ol> <li>When deployed, the constructor captures the address of the bEIGEN token and disables initializers to prevent re-initialization</li> <li>The <code>initialize</code> function must be called once to set up the contract:</li> <li>Sets the contract name and symbol</li> <li>Transfers ownership to the specified initial owner</li> <li>Configures authorized minters with their respective allowances and mint timing</li> <li>Sets transfer restrictions to be active (with a max uint256 value)</li> </ol>"},{"location":"code/token/Eigen/#token-minting-process","title":"Token Minting Process","text":"<ol> <li>Authorized minters (set during initialization) can call the <code>mint()</code> function</li> <li>The contract checks if:</li> <li>The minter has a remaining allowance greater than zero</li> <li>The current time is past the minter's allowed start time</li> <li>If conditions are met, the contract mints the allowed amount to the minter and resets their allowance to zero</li> </ol>"},{"location":"code/token/Eigen/#wrapping-and-unwrapping","title":"Wrapping and Unwrapping","text":"<ol> <li>Wrapping: Users with bEIGEN tokens can call <code>wrap(amount)</code> to:</li> <li>Transfer their bEIGEN tokens to the contract</li> <li>Receive an equal amount of EIGEN tokens</li> <li>Unwrapping: EIGEN holders can call <code>unwrap(amount)</code> to:</li> <li>Burn their EIGEN tokens</li> <li>Receive an equal amount of bEIGEN tokens</li> </ol>"},{"location":"code/token/Eigen/#transfer-restrictions","title":"Transfer Restrictions","text":"<ol> <li>The contract implements transfer restrictions through the <code>_beforeTokenTransfer</code> hook</li> <li>If the current timestamp is before <code>transferRestrictionsDisabledAfter</code>:</li> <li>Transfers are only allowed if either the sender is in <code>allowedFrom</code> or the receiver is in <code>allowedTo</code></li> <li>Minting (from address(0)) and burning (to address(0)) are always allowed</li> <li>The owner can disable these restrictions permanently by calling <code>disableTransferRestrictions()</code></li> </ol>"},{"location":"code/token/Eigen/#governance-functionality","title":"Governance Functionality","text":"<ol> <li>The contract inherits from ERC20VotesUpgradeable, providing token holders with voting capabilities</li> <li>The clock functionality is overridden to use timestamps instead of block numbers for voting checkpoints</li> <li>This enables token holders to participate in on-chain governance proposals</li> </ol>"},{"location":"code/token/Eigen/#visual-representation","title":"Visual Representation","text":"<pre><code>flowchart TD\n    A[User with bEIGEN] --&gt;|wrap| B[Eigen Contract]\n    B --&gt;|mint| C[Authorized Minters]\n    B --&gt;|unwrap| A\n    B --&gt;|transfer with restrictions| D[Transfer Restrictions]\n    D --&gt;|Allowed only if| E{from in allowedFrom OR to in allowedTo}\n    E --&gt;|Yes| F[Transfer Proceeds]\n    E --&gt;|No| G[Transfer Reverts]\n    H[Contract Owner] --&gt;|disable restrictions| I[Unrestricted Transfers]\n    H --&gt;|set allowed addresses| D\n    J[Governance] &lt;--&gt;|vote with EIGEN tokens| B</code></pre>"},{"location":"code/token/Eigen/#dependencies-and-interactions","title":"Dependencies and Interactions","text":""},{"location":"code/token/Eigen/#external-dependencies","title":"External Dependencies","text":"<ol> <li>OpenZeppelin Contracts:</li> <li><code>IERC20</code>: Interface for interacting with the bEIGEN token</li> <li><code>ERC20VotesUpgradeable</code>: Provides the base token functionality plus voting capabilities</li> <li><code>OwnableUpgradeable</code>: Provides ownership functionality for restricted operations</li> </ol>"},{"location":"code/token/Eigen/#contract-interactions","title":"Contract Interactions","text":"<ol> <li>bEIGEN Token: </li> <li>The Eigen contract interacts with the bEIGEN token contract for wrapping and unwrapping</li> <li>It calls <code>transferFrom</code> when users wrap tokens and <code>transfer</code> when they unwrap</li> <li> <p>It queries the bEIGEN token for <code>totalSupply</code> to ensure consistency</p> </li> <li> <p>Governance System:</p> </li> <li>While not explicitly shown in this contract, the ERC20Votes functionality enables integration with governance systems</li> <li>The EIGEN token holders can use their tokens to vote on proposals in a compatible governance contract</li> </ol>"},{"location":"code/token/Eigen/#security-mechanisms","title":"Security Mechanisms","text":"<ol> <li>Controlled Distribution: Only authorized minters can create new tokens and only up to their allowed amount</li> <li>Time-locked Minting: Minters can only mint after specific timestamps, allowing for scheduled token distribution</li> <li>Transfer Restrictions: Initially, transfers are restricted to a whitelist system until the owner disables restrictions</li> <li>Owner Controls: Only the owner can modify the whitelist or disable transfer restrictions</li> <li>Immutable bEIGEN: The address of the backing token is immutable, preventing changes to the underlying token</li> </ol> <p>The design of Eigen.sol prioritizes controlled token distribution and governance capabilities while providing flexibility through the owner-controlled whitelist system. The wrapping/unwrapping mechanism maintains a direct relationship with the backing bEIGEN token.</p>"},{"location":"docs/core/AVSDirectory/","title":"AVSDirectory","text":""},{"location":"docs/core/AVSDirectory/#avsdirectory","title":"AVSDirectory","text":"File Type Proxy <code>AVSDirectory.sol</code> Singleton Transparent proxy <p>Note: The AVSDirectory is deprecated as of the slashing release. This documentation is kept for historical purposes. AVSs are recommended to use the AllocationManager for the new operatorSet and slashing model.</p> <p>The <code>AVSDirectory</code> once handled interactions between AVSs and the EigenLayer core contracts. Once registered as an Operator in EigenLayer core (via the <code>DelegationManager</code>), Operators can register with one or more AVSs (via the AVS's contracts) to begin providing services to them offchain. As a part of registering with an AVS, the AVS will record this registration in the core contracts by calling into the <code>AVSDirectory</code>.</p> <p>For more information on AVS contracts, see the middleware repo.</p> <p>Currently, the only interactions between AVSs and the core contracts is to track whether Operators are currently registered for the AVS. This is handled by two methods:</p> <ul> <li><code>AVSDirectory.registerOperatorToAVS</code></li> <li><code>AVSDirectory.deregisterOperatorFromAVS</code></li> </ul>"},{"location":"docs/core/AVSDirectory/#registeroperatortoavs","title":"<code>registerOperatorToAVS</code>","text":"<pre><code>function registerOperatorToAVS(\n    address operator,\n    ISignatureUtils.SignatureWithSaltAndExpiry memory operatorSignature\n) \n    external \n    onlyWhenNotPaused(PAUSED_OPERATOR_REGISTER_DEREGISTER_TO_AVS)\n</code></pre> <p>Allows the caller (an AVS) to register an <code>operator</code> with itself, given the provided signature is valid.</p> <p>Effects: * Sets the <code>operator</code>'s status to <code>REGISTERED</code> for the AVS</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_OPERATOR_REGISTER_DEREGISTER_TO_AVS</code> * <code>operator</code> MUST already be a registered Operator (via the <code>DelegationManager</code>) * <code>operator</code> MUST NOT already be registered with the AVS * <code>operatorSignature</code> must be a valid, unused, unexpired signature from the <code>operator</code>. The signature is an ECDSA signature by the operator over the <code>OPERATOR_AVS_REGISTRATION_TYPEHASH</code>. Expiry is a utc timestamp in seconds. Salt is used only once per signature to prevent replay attacks.</p> <p>As of M2: * Operator registration/deregistration in the AVSDirectory does not have any sort of consequences for the Operator or its shares. The AllocationManager handles with operator sets, tying in rewards for services and slashing for misbehavior.</p>"},{"location":"docs/core/AVSDirectory/#deregisteroperatorfromavs","title":"<code>deregisterOperatorFromAVS</code>","text":"<pre><code>function deregisterOperatorFromAVS(\n    address operator\n) \n    external \n    onlyWhenNotPaused(PAUSED_OPERATOR_REGISTER_DEREGISTER_TO_AVS)\n</code></pre> <p>Allows the caller (an AVS) to deregister an <code>operator</code> with itself</p> <p>Effects: * Sets the <code>operator's</code> status to <code>UNREGISTERED</code> for the AVS</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_OPERATOR_REGISTER_DEREGISTER_TO_AVS</code> * <code>operator</code> MUST already be registered with the AVS</p> <p>As of M2: * Operator registration/deregistration in the AVSDirectory does not have any sort of consequences for the Operator or its shares. The AllocationManager handles this with operator sets, tying in rewards for services and slashing for misbehavior.</p>"},{"location":"docs/core/AVSDirectory/#cancelsalt","title":"<code>cancelSalt</code>","text":"<pre><code>function cancelSalt(bytes32 salt) external\n</code></pre> <p>Allows the caller (an Operator) to cancel a signature salt before it is used to register for an AVS.</p> <p>Effects: * Sets <code>operatorSaltIsSpent[msg.sender][salt]</code> to <code>true</code></p> <p>Requirements: * Salt MUST NOT already be cancelled</p>"},{"location":"docs/core/AllocationManager/","title":"AllocationManager","text":"File Notes <code>AllocationManager.sol</code> <code>AllocationManagerStorage.sol</code> state variables <code>IAllocationManager.sol</code> interface <p>Libraries and Mixins:</p> File Notes <code>PermissionControllerMixin.sol</code> account delegation <code>Pausable.sol</code> <code>SlashingLib.sol</code> slashing math <code>OperatorSetLib.sol</code> encode/decode operator sets <code>Snapshots.sol</code> historical state"},{"location":"docs/core/AllocationManager/#prior-reading","title":"Prior Reading","text":"<ul> <li>ELIP-002: Slashing via Unique Stake and Operator Sets</li> </ul>"},{"location":"docs/core/AllocationManager/#overview","title":"Overview","text":"<p>The <code>AllocationManager</code> manages AVS metadata registration, registration and deregistration of operators to operator sets, handles allocation and slashing of operators' slashable stake, and is the entry point an AVS uses to slash an operator. The <code>AllocationManager's</code> responsibilities are broken down into the following concepts:</p> <ul> <li>AVS Metadata</li> <li>Operator Sets</li> <li>Allocations and Slashing</li> <li>Config</li> </ul>"},{"location":"docs/core/AllocationManager/#parameterization","title":"Parameterization","text":"<ul> <li><code>ALLOCATION_CONFIGURATION_DELAY</code>: The delay in blocks before allocations take effect.<ul> <li>Mainnet: <code>126000 blocks</code> (17.5 days).</li> <li>Testnet: <code>75 blocks</code> (15 minutes).</li> </ul> </li> <li><code>DEALLOCATION_DELAY</code>: The delay in blocks before deallocations take effect.<ul> <li>Mainnet: <code>100800 blocks</code> (14 days).</li> <li>Testnet: <code>50 blocks</code> (10 minutes).</li> </ul> </li> </ul>"},{"location":"docs/core/AllocationManager/#avs-metadata","title":"AVS Metadata","text":"<p>AVSs must register their metadata to declare themselves who they are as the first step, before they can create operator sets or register operators into operator sets. <code>AllocationManager</code> keeps track of AVSs that have registered metadata.</p> <p>Methods: * <code>updateAVSMetadataURI</code></p>"},{"location":"docs/core/AllocationManager/#updateavsmetadatauri","title":"<code>updateAVSMetadataURI</code>","text":"<pre><code>/**\n *  @notice Called by an AVS to emit an `AVSMetadataURIUpdated` event indicating the information has updated.\n *\n *  @param metadataURI The URI for metadata associated with an AVS.\n *\n *  @dev Note that the `metadataURI` is *never stored* and is only emitted in the `AVSMetadataURIUpdated` event.\n */\nfunction updateAVSMetadataURI(\n    address avs, \n    string calldata metadataURI\n) \n    external\n    checkCanCall(avs)\n</code></pre> <p>Note: this method can be called directly by an AVS, or by a caller authorized by the AVS. See <code>PermissionController.md</code> for details.</p> <p>Below is the format AVSs should use when updating their metadata URI initially. This is not validated onchain.</p> <pre><code>{\n    \"name\": \"AVS\",\n    \"website\": \"https.avs.xyz/\",\n    \"description\": \"Some description about\",\n    \"logo\": \"http://github.com/logo.png\",\n    \"twitter\": \"https://twitter.com/avs\",\n}\n</code></pre> <p>Later on, once AVSs have created operator sets, content in their metadata URI can be updated subsequently.</p> <pre><code>{\n    \"name\": \"AVS\",\n    \"website\": \"https.avs.xyz/\",\n    \"description\": \"Some description about\",\n    \"logo\": \"http://github.com/logo.png\",\n    \"twitter\": \"https://twitter.com/avs\",\n    \"operatorSets\": [\n        {\n            \"name\": \"ETH Set\",\n            \"id\": \"1\", // Note: we use this param to match the opSet id in the Allocation Manager\n            \"description\": \"The ETH operatorSet for AVS\",\n            \"software\": [\n                {\n                    \"name\": \"NetworkMonitor\",\n                    \"description\": \"\",\n                    \"url\": \"https://link-to-binary-or-github.com\"\n                },\n                {\n                    \"name\": \"ValidatorClient\",\n                    \"description\": \"\",\n                    \"url\": \"https://link-to-binary-or-github.com\"\n                }\n            ],\n            \"slashingConditions\": [\"Condition A\", \"Condition B\"]\n        },\n        {\n            \"name\": \"EIGEN Set\",\n            \"id\": \"2\", // Note: we use this param to match the opSet id in the Allocation Manager\n            \"description\": \"The EIGEN operatorSet for AVS\",\n            \"software\": [\n                {\n                    \"name\": \"NetworkMonitor\",\n                    \"description\": \"\",\n                    \"url\": \"https://link-to-binary-or-github.com\"\n                },\n                {\n                    \"name\": \"ValidatorClient\",\n                    \"description\": \"\",\n                    \"url\": \"https://link-to-binary-or-github.com\"\n                }\n            ],\n            \"slashingConditions\": [\"Condition A\", \"Condition B\"]\n        }\n    ]\n}\n</code></pre> <p>Effects: * Emits an <code>AVSMetadataURIUpdated</code> event for use in offchain services</p> <p>Requirements: * Caller MUST be authorized, either as the AVS itself or an admin/appointee (see <code>PermissionController.md</code>)</p>"},{"location":"docs/core/AllocationManager/#operator-sets","title":"Operator Sets","text":"<p>Operator sets, as described in ELIP-002, are useful for AVSs to configure operator groupings which can be assigned different tasks, rewarded based on their strategy allocations, and slashed according to different rules. Operator sets are defined in <code>libraries/OperatorSetLib.sol</code>:</p> <pre><code>/**\n * @notice An operator set identified by the AVS address and an identifier\n * @param avs The address of the AVS this operator set belongs to\n * @param id The unique identifier for the operator set\n */\nstruct OperatorSet {\n    address avs;\n    uint32 id;\n}\n</code></pre> <p>The <code>AllocationManager</code> tracks operator sets and members of operator sets in the following mappings:</p> <pre><code>/// @dev Lists the operator set ids an AVS has created\nmapping(address avs =&gt; EnumerableSet.UintSet) internal _operatorSets;\n\n/// @dev Lists the members of an AVS's operator set\nmapping(bytes32 operatorSetKey =&gt; EnumerableSet.AddressSet) internal _operatorSetMembers;\n</code></pre> <p>Every <code>OperatorSet</code> corresponds to a single AVS, as indicated by the <code>avs</code> parameter. On creation, the AVS provides an <code>id</code> (unique to that AVS), as well as a list of <code>strategies</code> the <code>OperatorSet</code> includes. Together, the <code>avs</code> and <code>id</code> form the <code>key</code> that uniquely identifies a given <code>OperatorSet</code>. Operators can register to and deregister from operator sets. In combination with allocating slashable magnitude, operator set registration forms the basis of operator slashability (discussed further in Allocations and Slashing).</p> <p>Concepts: * Registration Status</p> <p>Methods: * <code>createOperatorSets</code> * <code>addStrategiesToOperatorSet</code> * <code>removeStrategiesFromOperatorSet</code> * <code>registerForOperatorSets</code> * <code>deregisterFromOperatorSets</code></p>"},{"location":"docs/core/AllocationManager/#registration-status","title":"Registration Status","text":"<p>Operator registration and deregistration is tracked in the following state variables:</p> <pre><code>/// @dev Lists the operator sets the operator is registered for. Note that an operator\n/// can be registered without allocated stake. Likewise, an operator can allocate\n/// without being registered.\nmapping(address operator =&gt; EnumerableSet.Bytes32Set) internal registeredSets;\n\n/**\n * @notice Contains registration details for an operator pertaining to an operator set\n * @param registered Whether the operator is currently registered for the operator set\n * @param slashableUntil If the operator is not registered, they are still slashable until\n * this block is reached.\n */\nstruct RegistrationStatus {\n    bool registered;\n    uint32 slashableUntil;\n}\n\n/// @dev Contains the operator's registration status for an operator set.\nmapping(address operator =&gt; mapping(bytes32 operatorSetKey =&gt; RegistrationStatus)) internal registrationStatus;\n</code></pre> <p>For each operator, <code>registeredSets</code> keeps a list of <code>OperatorSet</code> <code>keys</code> for which the operator is currently registered. Each operator registration and deregistration respectively adds and removes the relevant <code>key</code> for a given operator. An additional factor in registration is the operator's <code>RegistrationStatus</code>.</p> <p>The <code>RegistrationStatus.slashableUntil</code> value is used to ensure an operator remains slashable for a period of time after they initiate deregistration. This is to prevent an operator from committing a slashable offence and immediately deregistering to avoid penalty. This means that when an operator deregisters from an operator set, their <code>RegistrationStatus.slashableUntil</code> value is set to <code>block.number + DEALLOCATION_DELAY</code>.</p>"},{"location":"docs/core/AllocationManager/#createoperatorsets","title":"<code>createOperatorSets</code>","text":"<pre><code>/**\n * @notice Parameters used by an AVS to create new operator sets\n * @param operatorSetId the id of the operator set to create\n * @param strategies the strategies to add as slashable to the operator set\n */\nstruct CreateSetParams {\n    uint32 operatorSetId;\n    IStrategy[] strategies;\n}\n\n/**\n * @notice Allows an AVS to create new operator sets, defining strategies that the operator set uses\n */\nfunction createOperatorSets(\n    address avs,\n    CreateSetParams[] calldata params\n)\n    external\n    checkCanCall(avs)\n</code></pre> <p>Note: this method can be called directly by an AVS, or by a caller authorized by the AVS. See <code>PermissionController.md</code> for details.</p> <p>AVSs use this method to create new operator sets. An AVS can create as many operator sets as they desire, depending on their needs. Once created, operators can allocate slashable stake to and register for these operator sets.</p> <p>On creation, the <code>avs</code> specifies an <code>operatorSetId</code> unique to the AVS. Together, the <code>avs</code> address and <code>operatorSetId</code> create a <code>key</code> that uniquely identifies this operator set throughout the <code>AllocationManager</code>.</p> <p>Optionally, the <code>avs</code> can provide a list of <code>strategies</code>, specifying which strategies will be slashable for the new operator set. AVSs may create operator sets with various strategies based on their needs - and strategies may be added to more than one operator set.</p> <p>Effects: * For each <code>CreateSetParams</code> element:     * For each <code>params.strategies</code> element:         * Add <code>strategy</code> to <code>_operatorSetStrategies[operatorSetKey]</code>         * Emits <code>StrategyAddedToOperatorSet</code> event</p> <p>Requirements: * Caller MUST be authorized, either as the AVS itself or an admin/appointee (see <code>PermissionController.md</code>) * AVS MUST have registered metadata via calling <code>updateAVSMetadataURI</code> * For each <code>CreateSetParams</code> element:     * Each <code>params.operatorSetId</code> MUST NOT already exist in <code>_operatorSets[avs]</code></p>"},{"location":"docs/core/AllocationManager/#addstrategiestooperatorset","title":"<code>addStrategiesToOperatorSet</code>","text":"<pre><code>/**\n * @notice Allows an AVS to add strategies to an operator set\n * @dev Strategies MUST NOT already exist in the operator set\n * @param avs the avs to set strategies for\n * @param operatorSetId the operator set to add strategies to\n * @param strategies the strategies to add\n */\nfunction addStrategiesToOperatorSet(\n    address avs,\n    uint32 operatorSetId,\n    IStrategy[] calldata strategies\n)\n    external\n    checkCanCall(avs)\n</code></pre> <p>Note: this method can be called directly by an AVS, or by a caller authorized by the AVS. See <code>PermissionController.md</code> for details.</p> <p>This function allows an AVS to add slashable strategies to a given operator set. If any strategy is already registered for the given operator set, the entire call will fail.</p> <p>Effects: * For each <code>strategies</code> element:     * Adds the strategy to <code>_operatorSetStrategies[operatorSetKey]</code>     * Emits a <code>StrategyAddedToOperatorSet</code> event</p> <p>Requirements: * Caller MUST be authorized, either as the AVS itself or an admin/appointee (see <code>PermissionController.md</code>) * The operator set MUST be registered for the AVS * Each proposed strategy MUST NOT be registered for the operator set</p>"},{"location":"docs/core/AllocationManager/#removestrategiesfromoperatorset","title":"<code>removeStrategiesFromOperatorSet</code>","text":"<pre><code>/**\n * @notice Allows an AVS to remove strategies from an operator set\n * @dev Strategies MUST already exist in the operator set\n * @param avs the avs to remove strategies for\n * @param operatorSetId the operator set to remove strategies from\n * @param strategies the strategies to remove\n */\nfunction removeStrategiesFromOperatorSet(\n    address avs,\n    uint32 operatorSetId,\n    IStrategy[] calldata strategies\n)\n    external\n    checkCanCall(avs)\n</code></pre> <p>Note: this method can be called directly by an AVS, or by a caller authorized by the AVS. See <code>PermissionController.md</code> for details.</p> <p>This function allows an AVS to remove slashable strategies from a given operator set. If any strategy is not registered for the given operator set, the entire call will fail.</p> <p>Effects: * For each <code>strategies</code> element:     * Removes the strategy from <code>_operatorSetStrategies[operatorSetKey]</code>     * Emits a <code>StrategyRemovedFromOperatorSet</code> event</p> <p>Requirements: * Caller MUST be authorized, either as the AVS itself or an admin/appointee (see <code>PermissionController.md</code>) * The operator set MUST be registered for the AVS * Each proposed strategy MUST be registered for the operator set</p>"},{"location":"docs/core/AllocationManager/#registerforoperatorsets","title":"<code>registerForOperatorSets</code>","text":"<pre><code>/**\n * @notice Parameters used to register for an AVS's operator sets\n * @param avs the AVS being registered for\n * @param operatorSetIds the operator sets within the AVS to register for\n * @param data extra data to be passed to the AVS to complete registration\n */\nstruct RegisterParams {\n    address avs;\n    uint32[] operatorSetIds;\n    bytes data;\n}\n\n/**\n * @notice Allows an operator to register for one or more operator sets for an AVS. If the operator\n * has any stake allocated to these operator sets, it immediately becomes slashable.\n * @dev After registering within the ALM, this method calls the AVS Registrar's `IAVSRegistrar.\n * registerOperator` method to complete registration. This call MUST succeed in order for \n * registration to be successful.\n */\nfunction registerForOperatorSets(\n    address operator,\n    RegisterParams calldata params\n)\n    external\n    onlyWhenNotPaused(PAUSED_OPERATOR_SET_REGISTRATION_AND_DEREGISTRATION)\n    checkCanCall(operator)\n</code></pre> <p>Note: this method can be called directly by an operator, or by a caller authorized by the operator. See <code>PermissionController.md</code> for details.</p> <p>An operator may call this function to register for any number of operator sets of a given AVS at once. There are two very important details to know about this method: 1. As part of registration, each operator set is added to the operator's <code>registeredSets</code>. Note that for each newly-registered set, any stake allocations to the operator set become immediately slashable. 2. Once all sets have been added, the AVS's configured <code>IAVSRegistrar</code> is called to confirm and complete registration. This call MUST NOT revert, as AVSs are expected to use this call to reject ineligible operators (according to their own custom logic). Note that if the AVS has not configured a registrar, the <code>avs</code> itself is called.</p> <p>This method makes an external call to the <code>IAVSRegistrar.registerOperator</code> method, passing in the registering <code>operator</code>, the <code>operatorSetIds</code> being registered for, and the input <code>params.data</code> provided during registration. From <code>IAVSRegistrar.sol</code>:</p> <pre><code>/**\n * @notice Called by the AllocationManager when an operator wants to register\n * for one or more operator sets. This method should revert if registration\n * is unsuccessful.\n * @param operator the registering operator\n * @param operatorSetIds the list of operator set ids being registered for\n * @param data arbitrary data the operator can provide as part of registration\n */\nfunction registerOperator(address operator, uint32[] calldata operatorSetIds, bytes calldata data) external;\n</code></pre> <p>Effects: * Adds the proposed operator sets to the operator's list of registered sets (<code>registeredSets</code>) * Adds the operator to <code>_operatorSetMembers</code> for each operator set * Marks the operator as registered for the given operator sets (in <code>registrationStatus</code>) * Passes the <code>params</code> for registration to the AVS's <code>AVSRegistrar</code>, which can arbitrarily handle the registration request * Emits an <code>OperatorAddedToOperatorSet</code> event for each operator</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_OPERATOR_SET_REGISTRATION_AND_DEREGISTRATION</code> * <code>operator</code> MUST be registered as an operator in the <code>DelegationManager</code> * Caller MUST be authorized, either the operator themselves, or an admin/appointee (see <code>PermissionController.md</code>) * Each <code>operatorSetId</code> MUST exist for the given AVS * Operator MUST NOT already be registered for any proposed operator sets * If operator has deregistered, operator MUST NOT be slashable anymore (i.e. the <code>DEALLOCATION_DELAY</code> must have passed) * The call to the AVS's configured <code>IAVSRegistrar</code> MUST NOT revert</p>"},{"location":"docs/core/AllocationManager/#deregisterfromoperatorsets","title":"<code>deregisterFromOperatorSets</code>","text":"<pre><code>/**\n * @notice Parameters used to deregister from an AVS's operator sets\n * @param operator the operator being deregistered\n * @param avs the avs being deregistered from\n * @param operatorSetIds the operator sets within the AVS being deregistered from\n */\nstruct DeregisterParams {\n    address operator;\n    address avs;\n    uint32[] operatorSetIds;\n}\n\n/**\n * @notice Allows an operator or AVS to deregister the operator from one or more of the AVS's operator sets.\n * If the operator has any slashable stake allocated to the AVS, it remains slashable until the\n * DEALLOCATION_DELAY has passed.\n * @dev After deregistering within the ALM, this method calls the AVS Registrar's `IAVSRegistrar.\n * deregisterOperator` method to complete deregistration. This call MUST succeed in order for\n * deregistration to be successful.\n */\nfunction deregisterFromOperatorSets(\n    DeregisterParams calldata params\n)\n    external\n    onlyWhenNotPaused(PAUSED_OPERATOR_SET_REGISTRATION_AND_DEREGISTRATION)\n</code></pre> <p>Note: this method can be called directly by an operator/AVS, or by a caller authorized by the operator/AVS. See <code>PermissionController.md</code> for details.</p> <p>This method may be called by EITHER an operator OR an AVS to which an operator is registered; it is intended to allow deregistration to be triggered by EITHER party. This method generally inverts the effects of <code>registerForOperatorSets</code>, with two specific exceptions: 1. As part of deregistration, each operator set is removed from the operator's <code>registeredSets</code>. HOWEVER, any stake allocations to that operator set will remain slashable for <code>DEALLOCATION_DELAY</code> blocks. The operator will not be allowed to register for the operator set again until this slashable window has passed. 2. Once all sets have been removed, the AVS's configured <code>IAVSRegistrar</code> is called to complete deregistration on the AVS side.</p> <p>This method makes an external call to the <code>IAVSRegistrar.deregisterOperator</code> method, passing in the deregistering <code>operator</code> and the <code>operatorSetIds</code> being deregistered from. From <code>IAVSRegistrar.sol</code>:</p> <pre><code>/**\n * @notice Called by the AllocationManager when an operator is deregistered from\n * one or more operator sets. If this method reverts, it is ignored.\n * @param operator the deregistering operator\n * @param operatorSetIds the list of operator set ids being deregistered from\n */\nfunction deregisterOperator(address operator, uint32[] calldata operatorSetIds) external;\n</code></pre> <p>Effects: * Removes the proposed operator sets from the operator's list of registered sets (<code>registeredSets</code>) * Removes the operator from <code>_operatorSetMembers</code> for each operator set * Updates the operator's <code>registrationStatus</code> with:     * <code>registered: false</code>     * <code>slashableUntil: block.number + DEALLOCATION_DELAY</code>         * As mentioned above, this allows for AVSs to slash deregistered operators until <code>block.number == slashableUntil</code> * Emits an <code>OperatorRemovedFromOperatorSet</code> event for each operator * Passes the <code>operator</code> and <code>operatorSetIds</code> to the AVS's <code>AVSRegistrar</code>, which can arbitrarily handle the deregistration request</p> <p>Requirements:</p> <ul> <li>Pause status MUST NOT be set: <code>PAUSED_OPERATOR_SET_REGISTRATION_AND_DEREGISTRATION</code></li> <li>Caller MUST be authorized, either the operator/AVS themselves, or an admin/appointee (see <code>PermissionController.md</code>)</li> <li>Each operator set ID MUST exist for the given AVS</li> <li>Operator MUST be registered for the given operator sets</li> <li>Note that, unlike <code>registerForOperatorSets</code>, the AVS's <code>AVSRegistrar</code> MAY revert and the deregistration will still succeed</li> </ul>"},{"location":"docs/core/AllocationManager/#allocations-and-slashing","title":"Allocations and Slashing","text":"<p>Operator set registration is one step of preparing to participate in an AVS. When an operator successfully registers for an operator set, it is because the AVS in question is ready to assign them tasks. However, it follows that before assigning tasks to an operator, an AVS will expect operators to allocate slashable stake to the operator set such that the AVS has some economic security.</p> <p>For this reason, it is expected that many AVSs will require operators to allocate slashable stake BEFORE registering for an operator set. This is due to <code>registerForOperatorSets</code> serving in part as an AVS's \"consent mechanism,\" as calling <code>IAVSRegsitrar.registerOperator</code> allows the AVS to query the amount of slashable stake the operator can provide when assigned tasks.</p> <p>It is only once an operator is both registered for an operator set and has an active allocation to that operator set that the associated AVS can slash actual stake from an operator.</p> <p>See ELIP-002#Unique Stake Allocation &amp; Deallocation for additional context.</p> <p>Concepts: * Max vs Encumbered Magnitude * Evaluating the \"Current\" Allocation * Evaluating Whether an Allocation is \"Slashable\"</p> <p>Methods: * <code>modifyAllocations</code> * <code>clearDeallocationQueue</code> * <code>slashOperator</code></p>"},{"location":"docs/core/AllocationManager/#max-vs-encumbered-magnitude","title":"Max vs Encumbered Magnitude","text":"<p>Operators allocate magnitude, which represents a proportion of their total stake. For a given strategy, the <code>AllocationManager</code> tracks two quantities, max magnitude and encumbered magnitude:</p> <pre><code>/**\n * @notice Contains allocation info for a specific strategy\n * @param maxMagnitude the maximum magnitude that can be allocated between all operator sets\n * @param encumberedMagnitude the currently-allocated magnitude for the strategy\n */\nstruct StrategyInfo {\n    uint64 maxMagnitude;\n    uint64 encumberedMagnitude;\n}\n\n/// @dev Contains a history of the operator's maximum magnitude for a given strategy\nmapping(address operator =&gt; mapping(IStrategy strategy =&gt; Snapshots.DefaultWadHistory)) internal _maxMagnitudeHistory;\n\n/// @dev For a strategy, contains the amount of magnitude an operator has allocated to operator sets\n/// @dev This value should be read with caution, as deallocations that are completable but not\n///      popped off the queue are still included in the encumbered magnitude\nmapping(address operator =&gt; mapping(IStrategy strategy =&gt; uint64)) public encumberedMagnitude;\n</code></pre> <p>An operator's max magnitude starts at <code>1 WAD</code> (<code>1e18</code>), and is decreased when they are slashed. Max magnitude represents \"100%\" of allocatable magnitude. When an operator allocates magnitude from a strategy to an operator set, their encumbered magnitude for that strategy increases. An operator cannot allocate &gt; 100%; therefore, a strategy's encumbered magnitude can never exceed that strategy's max magnitude.</p>"},{"location":"docs/core/AllocationManager/#evaluating-the-current-allocation","title":"Evaluating the \"Current\" Allocation","text":"<p>As mentioned in the previous section, allocations and deallocations take place on a delay, and as such the <code>Allocation</code> struct has both a <code>currentMagnitude</code>, and <code>pendingDiff</code> / <code>effectBlock</code> fields:</p> <pre><code>/**\n * @notice Defines allocation information from a strategy to an operator set, for an operator\n * @param currentMagnitude the current magnitude allocated from the strategy to the operator set\n * @param pendingDiff a pending change in magnitude, if it exists (0 otherwise)\n * @param effectBlock the block at which the pending magnitude diff will take effect\n */\nstruct Allocation {\n    uint64 currentMagnitude;\n    int128 pendingDiff;\n    uint32 effectBlock;\n}\n</code></pre> <p>Although the <code>allocations</code> mapping can be used to fetch an <code>Allocation</code> directly, you'll notice a convention in the <code>AllocationManager</code> of using the <code>_getUpdatedAllocation</code> helper, instead. This helper reads an existing <code>Allocation</code>, then evaluates <code>block.number</code> against <code>Allocation.effectBlock</code> to determine whether or not to apply the <code>pendingDiff</code>.  * If the diff can be applied, the helper returns an <code>Allocation</code> with an updated <code>currentMagnitude</code> and zeroed out <code>pendingDiff</code> and <code>effectBlock</code> fields -- as if the modification has already been completed. * Otherwise, the <code>Allocation</code> is returned from storage unmodified.</p> <p>Generally, when an <code>Allocation</code> is mentioned in this doc (or used within the <code>AllocationManager.sol</code> contract), we are referring to the \"Current\" <code>Allocation</code> as defined above.</p>"},{"location":"docs/core/AllocationManager/#evaluating-whether-an-allocation-is-slashable","title":"Evaluating Whether an Allocation is \"Slashable\"","text":"<p>Given an <code>operator</code> and an <code>Allocation</code> from a <code>strategy</code> to an AVS's <code>OperatorSet</code>, the <code>AllocationManager</code> uses the following criteria to determine whether the operator's allocation is slashable: 1. The <code>operator</code> must be registered for the operator set, or if they are deregistered, they must still be slashable (See Registration Status). 2. The AVS must have added the <code>strategy</code> to the operator set (See <code>addStrategiesToOperatorSet</code> and <code>removeStrategiesFromOperatorSet</code>) 3. The existing <code>Allocation</code> must have a nonzero <code>Allocation.currentMagnitude</code></p> <p>If ALL of these are true, the <code>AllocationManager</code> will allow the AVS to slash the <code>operator's</code> <code>Allocation</code>.</p>"},{"location":"docs/core/AllocationManager/#evaluating-how-much-of-the-allocation-is-slashable","title":"Evaluating How Much of the Allocation is \"Slashable\"","text":"<p>The <code>getMinimumSlashableStake</code> calculates the minimum amount of stake that will be slashable at a specified future block. This computation accounts for each operator\u2019s allocated stake from different strategies within an operator set. The function considers pending allocation changes that could reduce the slashable stake over time, ensuring a minimum guaranteed value. Because this is a forecast, the slashable stake at any given moment is a discrete value, but when looking ahead to a future block, the function provides the lowest possible amount, factoring in any planned allocation adjustments that will take effect within the specified timeframe.</p> <p>Please see IAllocationManager.sol:getMinimumSlashableStake for more detail.</p>"},{"location":"docs/core/AllocationManager/#modifyallocations","title":"<code>modifyAllocations</code>","text":"<pre><code>/**\n * @notice struct used to modify the allocation of slashable magnitude to an operator set\n * @param operatorSet the operator set to modify the allocation for\n * @param strategies the strategies to modify allocations for\n * @param newMagnitudes the new magnitude to allocate for each strategy to this operator set\n */\nstruct AllocateParams {\n    OperatorSet operatorSet;\n    IStrategy[] strategies;\n    uint64[] newMagnitudes;\n}\n\n/**\n * @notice Modifies the proportions of slashable stake allocated to an operator set from a list of strategies\n * Note that deallocations remain slashable for DEALLOCATION_DELAY blocks therefore when they are cleared they may\n * free up less allocatable magnitude than initially deallocated.\n * @param operator the operator to modify allocations for\n * @param params array of magnitude adjustments for one or more operator sets\n * @dev Updates encumberedMagnitude for the updated strategies\n */\nfunction modifyAllocations(\n    address operator, \n    AllocateParams[] calldata params\n) \n    external\n    onlyWhenNotPaused(PAUSED_MODIFY_ALLOCATIONS)\n</code></pre> <p>Note: this method can be called directly by an operator, or by a caller authorized by the operator. See <code>PermissionController.md</code> for details.</p> <p>This function is called by an operator to EITHER increase OR decrease the slashable magnitude allocated from a strategy to an operator set. As input, the operator provides an operator set as the target, and a list of strategies and corresponding <code>newMagnitudes</code> to allocate. The <code>newMagnitude</code> value is compared against the operator's current <code>Allocation</code> for that operator set/strategy: * If <code>newMagnitude</code> is greater than <code>Allocation.currentMagnitude</code>, this is an allocation * If <code>newMagnitude</code> is less than <code>Allocation.currentMagnitude</code>, this is a deallocation * If <code>newMagnitude</code> is equal to <code>Allocation.currentMagnitude</code>, this is invalid (revert)</p> <p>Allocation modifications play by different rules depending on a few factors. Recall that at all times, the <code>encumberedMagnitude</code> for a strategy may not exceed that strategy's <code>maxMagnitude</code>. Additionally, note that before processing a modification for a strategy, the <code>deallocationQueue</code> for that strategy is first cleared. This ensures any completable deallocations are processed first, freeing up magnitude for allocation. This process is further explained in <code>clearDeallocationQueue</code>. </p> <p>Finally, <code>modifyAllocations</code> does NOT require an allocation to consider whether its corresponding strategy is relevant to the operator set in question. This is primarily to cut down on complexity. Because <code>removeStrategiesFromOperatorSet</code> always allows an AVS to remove strategies from consideration, we always need to be sure an operator can initiate a deallocation for such strategies. Although there's not a clear usecase for allocating when a strategy is not included in an operator set, we elected not to check for this. It's possible some AVSs may announce a strategy is being added ahead of time specifically to encourage allocations in advance. It is expected behavior that an AVS adding a strategy to an operator set makes any existing allocations to that strategy instantly slashable.</p> <p>If we are handling an increase in magnitude (allocation):</p> <ul> <li>The increase in magnitude is immediately added to the strategy's <code>encumberedMagnitude</code>. This ensures that subsequent allocations to other operator sets from the same strategy will not go above the strategy's <code>maxMagnitude</code>.</li> <li>The <code>allocation.pendingDiff</code> is set, with an <code>allocation.effectBlock</code> equal to the current block plus the operator's configured allocation delay.</li> </ul> <p>If we are handling a decrease in magnitude (deallocation):</p> <p>First, evaluate whether the operator's existing allocation is currently slashable by the AVS. This is important because the AVS might be using the existing allocation to secure a task given to this operator. See Evaluating Whether an Allocation is \"Slashable\" for details.</p> <p>Next, if the existing allocation IS slashable:</p> <ul> <li>The <code>allocation.pendingDiff</code> is set, with an <code>allocation.effectBlock</code> equal to the current block plus <code>DEALLOCATION_DELAY + 1</code>. This means the existing allocation remains slashable for <code>DEALLOCATION_DELAY</code> blocks.</li> <li>The operator set is pushed to the operator's <code>deallocationQueue</code> for that strategy, denoting that there is a pending deallocation for this <code>(operatorSet, strategy)</code>. This is an ordered queue that enforces deallocations are processed sequentially and is used both in this method and in <code>clearDeallocationQueue</code>.</li> </ul> <p>Alternatively, if the existing allocation IS NOT slashable, the deallocated amount is immediately freed. It is subtracted from the strategy's encumbered magnitude and can be used for subsequent allocations. This is the only type of update that does not result in a \"pending modification.\" The rationale here is that if the existing allocation is not slashable, the AVS does not need it to secure tasks, and therefore does not need to enforce a deallocation delay.</p> <p>Another point of consideration are race conditions involving a slashing event and a deallocation occurring for an operator. Consider the following scenario with an operator having an allocation of 500 magnitude and trying to deallocate setting it to 250. However in the same block right before calling <code>modifyAllocations</code> the operator is slashed 100% by the OperatorSet, setting the current magnitude to 0. Now the operator's deallocation is considered an allocation and ends up allocating 250 magnitude when they were trying to deallocate. This is a potential griefing vector by malicious AVSs and a known shortcoming. In such scenarios, the operator should simply deallocate all their allocations to 0 so that they don't accidentally allocate more slashable stake. In general for non malicious AVSs, slashing is deemed to be a very occasional occurrence and this race condition to not be impacting to operators.</p> <p>Effects: * For each <code>AllocateParams</code> element:     * Complete any existing deallocations (See <code>clearDeallocationQueue</code>)     * Update the operator's <code>encumberedMagnitude</code>, <code>allocations</code>, and <code>deallocationQueue</code> according to the rules described above. Additionally:         * If <code>encumberedMagnitude</code> is updated, emits <code>EncumberedMagnitudeUpdated</code>         * If a pending modification is created:             * Adds the <code>strategy</code> to <code>allocatedStrategies[operator][operatorSetKey]</code> (if not present)             * Adds the <code>operatorSetKey</code> to <code>allocatedSets[operator]</code> (if not present)         * If the allocation now has a <code>currentMagnitude</code> of 0:             * Removes <code>strategy</code> from the <code>allocatedStrategies[operator][operatorSetKey]</code> list             * If this list now has a length of 0, remove <code>operatorSetKey</code> from <code>allocatedSets[operator]</code>     * Emits an <code>AllocationUpdated</code> event</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_MODIFY_ALLOCATIONS</code> * Caller MUST be authorized, either as the operator themselves or an admin/appointee (see <code>PermissionController.md</code>) * Operator MUST have already set an allocation delay (See <code>setAllocationDelay</code>) * For each <code>AllocationParams</code> element:     * Provided strategies MUST be of equal length to provided magnitudes for a given <code>AllocateParams</code> object     * Operator set MUST exist for each specified AVS     * Operator MUST NOT have pending, non-completable modifications for any given strategy     * New magnitudes MUST NOT match existing ones     * New encumbered magnitude MUST NOT exceed the operator's max magnitude for the given strategy</p>"},{"location":"docs/core/AllocationManager/#cleardeallocationqueue","title":"<code>clearDeallocationQueue</code>","text":"<pre><code>/**\n * @notice This function takes a list of strategies and for each strategy, removes from the deallocationQueue\n * all clearable deallocations up to max `numToClear` number of deallocations, updating the encumberedMagnitude\n * of the operator as needed.\n *\n * @param operator address to clear deallocations for\n * @param strategies a list of strategies to clear deallocations for\n * @param numToClear a list of number of pending deallocations to clear for each strategy\n *\n * @dev can be called permissionlessly by anyone\n */\nfunction clearDeallocationQueue(\n    address operator,\n    IStrategy[] calldata strategies,\n    uint16[] calldata numToClear\n)\n    external\n    onlyWhenNotPaused(PAUSED_MODIFY_ALLOCATIONS)\n</code></pre> <p>This function is used to complete any eligible pending deallocations for an operator. The function takes an operator, a list of strategies, and a corresponding number of pending deallocations to complete. </p> <p>Clearing pending deallocations plays an important role in <code>modifyAllocations</code>, as completable deallocations represent magnitude that can be freed for re-allocation to a different operator set. This method exists as a convenience for operators that want to complete pending deallocations as a standalone operation. However, <code>modifyAllocations</code> will automatically clear any eligible deallocations when processing an allocation modification for a given strategy.</p> <p>For each strategy, the method iterates over <code>deallocationQueue[operator][strategy]</code>:</p> <pre><code>/// @dev For a strategy, keeps an ordered queue of operator sets that have pending deallocations\n/// These must be completed in order to free up magnitude for future allocation\nmapping(address operator =&gt; mapping(IStrategy strategy =&gt; DoubleEndedQueue.Bytes32Deque)) internal deallocationQueue;\n</code></pre> <p>This queue contains a per-strategy ordered list of operator sets that, due to prior calls by the <code>operator</code> to <code>modifyAllocations</code>, have a pending decrease in slashable magnitude. For each operator set in the queue, the corresponding allocation for that operator set is evaluated. If its <code>effectBlock</code> has been reached, the deallocation is completed, freeing up the deallocated magnitude by subtracting it from <code>encumberedMagnitude[operator][strategy]</code>. The corresponding entry is then popped from the front of the queue.</p> <p>This method stops iterating when: the queue is empty, a deallocation is reached that cannot be completed yet, or when it has cleared <code>numToClear</code> entries from the queue.</p> <p>Effects: * For each <code>strategy</code> and completable deallocation in <code>deallocationQueue[operator][strategy]</code>:     * Pops the corresponding operator set from the <code>deallocationQueue</code>     * Reduces <code>allocation.currentMagnitude</code> by the deallocated amount     * Sets <code>allocation.pendingDiff</code> and <code>allocation.effectBlock</code> to 0     * Adds the deallocated amount to the strategy's <code>encumberedMagnitude</code>     * Emits <code>EncumberedMagnitudeUpdated</code>     * Additionally, if the deallocation leaves <code>allocation.currentMagnitude</code> equal to zero:         * Removes <code>strategy</code> from the <code>allocatedStrategies[operator][operatorSetKey]</code> list         * If this list now has a length of 0, remove <code>operatorSetKey</code> from <code>allocatedSets[operator]</code></p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_MODIFY_ALLOCATIONS</code> * Strategy list MUST be equal length of <code>numToClear</code> list</p>"},{"location":"docs/core/AllocationManager/#slashoperator","title":"<code>slashOperator</code>","text":"<pre><code>/**\n * @notice Struct containing parameters to slashing\n * @param operator the address to slash\n * @param operatorSetId the ID of the operatorSet the operator is being slashed on behalf of\n * @param strategies the set of strategies to slash\n * @param wadsToSlash the parts in 1e18 to slash, this will be proportional to the operator's\n * slashable stake allocation for the operatorSet\n * @param description the description of the slashing provided by the AVS for legibility\n */\nstruct SlashingParams {\n    address operator;\n    uint32 operatorSetId;\n    IStrategy[] strategies;\n    uint256[] wadsToSlash;\n    string description;\n}\n\n/**\n * @notice Called by an AVS to slash an operator in a given operator set. The operator must be registered\n * and have slashable stake allocated to the operator set.\n *\n * @param avs The AVS address initiating the slash.\n * @param params The slashing parameters, containing:\n *  - operator: The operator to slash.\n *  - operatorSetId: The ID of the operator set the operator is being slashed from.\n *  - strategies: Array of strategies to slash allocations from (must be in ascending order).\n *  - wadsToSlash: Array of proportions to slash from each strategy (must be between 0 and 1e18).\n *  - description: Description of why the operator was slashed.\n *\n * @dev For each strategy:\n *      1. Reduces the operator's current allocation magnitude by wadToSlash proportion.\n *      2. Reduces the strategy's max and encumbered magnitudes proportionally.\n *      3. If there is a pending deallocation, reduces it proportionally.\n *      4. Updates the operator's shares in the DelegationManager.\n *\n * @dev Small slashing amounts may not result in actual token burns due to\n *      rounding, which will result in small amounts of tokens locked in the contract\n *      rather than fully burning through the burn mechanism.\n */\nfunction slashOperator(\n    address avs,\n    SlashingParams calldata params\n)\n    external\n    onlyWhenNotPaused(PAUSED_OPERATOR_SLASHING)\n    checkCanCall(avs)\n</code></pre> <p>Note: this method can be called directly by an AVS, or by a caller authorized by the AVS. See <code>PermissionController.md</code> for details.</p> <p>AVSs use slashing as a punitive disincentive for misbehavior. For details and examples of how slashing works, see ELIP-002#Slashing of Unique Stake. Note that whatever slashing criteria an AVS decides on, the only criteria enforced by the <code>AllocationManager</code> are those detailed above (see Evaluating Whether an Allocation is \"Slashable\").</p> <p>In order to slash an eligible operator, the AVS specifies which operator set the operator belongs to, the <code>strategies</code> the operator should be slashed for, and for each strategy, the proportion of the operator's allocated magnitude that should be slashed (given by <code>wadsToSlash</code>). An optional <code>description</code> string allows the AVS to add context to the slash.</p> <p>Once triggered in the <code>AllocationManager</code>, slashing is instant and irreversible. For each slashed strategy, the operator's <code>maxMagnitude</code> and <code>encumberedMagnitude</code> are decreased, and the allocation made to the given operator set has its <code>currentMagnitude</code> reduced. See TODO - Accounting Doc for details on how slashed amounts are calculated.</p> <p>There are two edge cases to note for this method: 1. In the process of slashing an <code>operator</code> for a given <code>strategy</code>, if the <code>Allocation</code> being slashed has a <code>currentMagnitude</code> of 0, the call will NOT revert. Instead, the <code>strategy</code> is skipped and slashing continues with the next <code>strategy</code> listed. This is to prevent an edge case where slashing occurs on or around a deallocation's <code>effectBlock</code> -- if the call reverted, the entire slash would fail. Skipping allows any valid slashes to be processed without requiring resubmission. 2. If the <code>operator</code> has a pending, non-completable deallocation, the deallocation's <code>pendingDiff</code> is reduced proportional to the slash. This ensures that when the deallocation is completed, less <code>encumberedMagnitude</code> is freed.</p> <p>Once slashing is processed for a strategy, slashed stake is burned via the <code>DelegationManager</code>.</p> <p>Effects: * Given an <code>operator</code> and <code>operatorSet</code>, then for each <code>params.strategies</code> element and its corresponding <code>allocation</code>:     * Calculates magnitude to slash by multiplying current magnitude by the provided <code>wadsToSlash</code>     * Reduce <code>allocation.currentMagnitude</code> by the slashed magnitude         * Emit an <code>AllocationUpdated</code> event     * Reduce the operator's <code>encumberedMagnitude</code> for this strategy by the slashed magnitude         * Emit an <code>EncumberedMagnitudeUpdated</code> event     * Push an entry to the operator's <code>maxMagnitudeHistory</code>, reducing their <code>maxMagnitude</code> by the slashed magnitude         * Emit a <code>MaxMagnitudeUpdated</code> event     * If the <code>allocation</code> has a pending, non-completable deallocation, additionally reduce <code>allocation.pendingDiff</code> by the same proportion and emit an <code>AllocationUpdated</code> event     * If the <code>allocation</code> now has a <code>currentMagnitude</code> of 0:         * Removes <code>strategy</code> from the <code>allocatedStrategies[operator][operatorSetKey]</code> list         * If this list now has a length of 0, remove <code>operatorSetKey</code> from <code>allocatedSets[operator]</code>     * Calls <code>DelegationManager.slashOperatorShares</code> * Emit an <code>OperatorSlashed</code> event</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_OPERATOR_SLASHING</code> * Caller MUST be authorized, either as the AVS itself or an admin/appointee (see <code>PermissionController.md</code>) * Operator set MUST be registered for the AVS * Operator MUST BE slashable, i.e.:     * Operator is registered for the operator set, OR     * The operator's <code>DEALLOCATION_DELAY</code> has not yet completed * <code>params.strategies</code> MUST be in ascending order (to ensure no duplicates) * <code>params.strategies.length</code> MUST be equal to <code>params.wadsToSlash.length</code> * For each <code>params.strategies</code> element:     * <code>wadsToSlash</code> MUST be within the bounds <code>(0, 1e18]</code>     * Operator set MUST contain the strategy</p>"},{"location":"docs/core/AllocationManager/#config","title":"Config","text":"<p>Methods: * <code>setAllocationDelay</code> * <code>setAVSRegistrar</code></p>"},{"location":"docs/core/AllocationManager/#setallocationdelay","title":"<code>setAllocationDelay</code>","text":"<pre><code>/**\n * @notice Called by the delegation manager OR an operator to set an operator's allocation delay.\n * This is set when the operator first registers, and is the number of blocks between an operator\n * allocating magnitude to an operator set, and the magnitude becoming slashable.\n * @param operator The operator to set the delay on behalf of.\n * @param delay the allocation delay in blocks\n */\nfunction setAllocationDelay(\n    address operator,\n    uint32 delay\n)\n    external\n</code></pre> <p>Note: IF NOT CALLED BY THE <code>DelegationManager</code>, this method can be called directly by an operator, or by a caller authorized by the operator. See <code>PermissionController.md</code> for details.</p> <p>This function sets an operator's allocation delay, in blocks. This delay can be updated by the operator once set. Both the initial setting of this value and any further updates take <code>ALLOCATION_CONFIGURATION_DELAY</code> blocks to take effect. Because having a delay is a requirement to allocating slashable stake, this effectively means that once the slashing release goes live, no one will be able to allocate slashable stake for at least <code>ALLOCATION_CONFIGURATION_DELAY</code> blocks.</p> <p>The <code>DelegationManager</code> calls this upon operator registration for all new operators created after the slashing release. For operators that existed in the <code>DelegationManager</code> prior to the slashing release, they will need to call this method to configure an allocation delay prior to allocating slashable stake to any AVS.</p> <p>The allocation delay's primary purpose is to give stakers delegated to an operator the chance to withdraw their stake before the operator can change the risk profile to something they're not comfortable with. However, operators can choose to configure this delay however they want - including setting it to 0.</p> <p>Effects: * Sets the operator's <code>pendingDelay</code> to the proposed <code>delay</code>, and save the <code>effectBlock</code> at which the <code>pendingDelay</code> can be activated     * <code>effectBlock = uint32(block.number) + ALLOCATION_CONFIGURATION_DELAY + 1</code> * If the operator has a <code>pendingDelay</code>, and if the <code>effectBlock</code> has passed, sets the operator's <code>delay</code> to the <code>pendingDelay</code> value     * This also sets the <code>isSet</code> boolean to <code>true</code> to indicate that the operator's <code>delay</code>, even if 0, was set intentionally * Emits an <code>AllocationDelaySet</code> event</p> <p>Requirements: * Caller MUST BE either the DelegationManager, or a registered operator     * An admin and/or appointee for the operator can also call this function (see <code>PermissionController.md</code>)</p>"},{"location":"docs/core/AllocationManager/#setavsregistrar","title":"<code>setAVSRegistrar</code>","text":"<pre><code>/**\n * @notice Called by an AVS to configure the address that is called when an operator registers\n * or is deregistered from the AVS's operator sets. If not set (or set to 0), defaults\n * to the AVS's address.\n * @param registrar the new registrar address\n */\nfunction setAVSRegistrar(\n    address avs,\n    IAVSRegistrar registrar\n)\n    external\n    checkCanCall(avs)\n</code></pre> <p>Note: this method can be called directly by an AVS, or by a caller authorized by the AVS. See <code>PermissionController.md</code> for details.</p> <p>Sets the <code>registrar</code> for a given <code>avs</code>. Note that if the registrar is set to 0, <code>getAVSRegistrar</code> will return the AVS's address.</p> <p>The avs registrar is called when operators register to or deregister from an operator set. From <code>IAVSRegistrar.sol</code>, the avs registrar should use the following interface:</p> <pre><code>interface IAVSRegistrar {\n    /**\n     * @notice Called by the AllocationManager when an operator wants to register\n     * for one or more operator sets. This method should revert if registration\n     * is unsuccessful.\n     * @param operator the registering operator\n     * @param operatorSetIds the list of operator set ids being registered for\n     * @param data arbitrary data the operator can provide as part of registration\n     */\n    function registerOperator(address operator, uint32[] calldata operatorSetIds, bytes calldata data) external;\n\n    /**\n     * @notice Called by the AllocationManager when an operator is deregistered from\n     * one or more operator sets. If this method reverts, it is ignored.\n     * @param operator the deregistering operator\n     * @param operatorSetIds the list of operator set ids being deregistered from\n     */\n    function deregisterOperator(address operator, uint32[] calldata operatorSetIds) external;\n}\n</code></pre> <p>Note that when an operator registers, registration will FAIL if the call to <code>IAVSRegistrar</code> reverts. However, when an operator deregisters, a revert in <code>deregisterOperator</code> is ignored.</p> <p>Effects: * Sets <code>_avsRegistrar[avs]</code> to <code>registrar</code> * Emits an <code>AVSRegistrarSet</code> event</p> <p>Requirements: * Caller MUST be authorized, either as the AVS itself or an admin/appointee (see <code>PermissionController.md</code>)</p>"},{"location":"docs/core/DelegationManager/","title":"DelegationManager","text":""},{"location":"docs/core/DelegationManager/#delegationmanager","title":"DelegationManager","text":"File Notes <code>DelegationManager.sol</code> <code>DelegationManagerStorage.sol</code> state variables <code>IDelegationManager.sol</code> interface <p>Libraries and Mixins:</p> File Notes <code>PermissionControllerMixin.sol</code> account delegation <code>SignatureUtils.sol</code> signature validation <code>Pausable.sol</code> <code>SlashingLib.sol</code> slashing math <code>Snapshots.sol</code> historical state"},{"location":"docs/core/DelegationManager/#prior-reading","title":"Prior Reading","text":"<ul> <li>ELIP-002: Slashing via Unique Stake and Operator Sets</li> <li>Shares Accounting</li> </ul>"},{"location":"docs/core/DelegationManager/#overview","title":"Overview","text":"<p>The <code>DelegationManager</code> is the intersection between the two sides of the protocol. It (i) allows stakers to delegate/undelegate to/from operators, (ii) handles withdrawals and withdrawal processing for assets in both the <code>StrategyManager</code> and <code>EigenPodManager</code>, and (iii) manages accounting around slashing for stakers and operators.</p> <p>When operators are slashed by AVSs, it receives share burning directives from the <code>AllocationManager</code>. When stakers deposit assets using the <code>StrategyManager/EigenPodManager</code>, it tracks share/delegation accounting changes. The <code>DelegationManager</code> combines inputs from both sides of the protocol into a staker's \"deposit scaling factor,\" which serves as the primary conversion vehicle between a staker's raw deposited assets and the amount they can withdraw.</p> <p>The <code>DelegationManager's</code> responsibilities can be broken down into the following concepts: * Becoming an Operator * Delegation and Withdrawals * Slashing and Accounting</p>"},{"location":"docs/core/DelegationManager/#parameterization","title":"Parameterization","text":"<ul> <li><code>MIN_WITHDRAWAL_DELAY_BLOCKS</code>: The delay in blocks before withdrawals can be completed.<ul> <li>Mainnet: <code>100800 blocks</code> (14 days).</li> <li>Testnet: <code>50 blocks</code> (10 minutes).</li> </ul> </li> <li><code>beaconChainETHStrategy</code>: a pseudo strategy used to represent beacon chain ETH internally. This is not a real contract!<ul> <li>Value: <code>0xbeaC0eeEeeeeEEeEeEEEEeeEEeEeeeEeeEEBEaC0</code></li> </ul> </li> </ul>"},{"location":"docs/core/DelegationManager/#becoming-an-operator","title":"Becoming an Operator","text":"<p>The <code>DelegationManager</code> tracks operator-related state in the following mappings:</p> <pre><code>/// @notice Returns the `operator` a `staker` is delegated to, or address(0) if not delegated.\n/// Note: operators are delegated to themselves\nmapping(address staker =&gt; address operator) public delegatedTo;\n\n/// @notice Returns the operator details for a given `operator`.\n/// Note: two of the `OperatorDetails` fields are deprecated. The only relevant field\n/// is `OperatorDetails.delegationApprover`.\nmapping(address operator =&gt; OperatorDetails) internal _operatorDetails;\n\n/**\n * @notice Tracks the current balance of shares an `operator` is delegated according to each `strategy`. \n * Updated by both the `StrategyManager` and `EigenPodManager` when a staker's delegatable balance changes,\n * and by the `AllocationManager` when the `operator` is slashed.\n *\n * @dev The following invariant should hold for each `strategy`:\n *\n * operatorShares[operator] = sum(withdrawable shares of all stakers delegated to operator)\n */\nmapping(address operator =&gt; mapping(IStrategy strategy =&gt; uint256 shares)) public operatorShares;\n</code></pre> <p>Methods: * <code>DelegationManager.registerAsOperator</code> * <code>DelegationManager.modifyOperatorDetails</code> * <code>DelegationManager.updateOperatorMetadataURI</code></p>"},{"location":"docs/core/DelegationManager/#registerasoperator","title":"<code>registerAsOperator</code>","text":"<pre><code>/**\n * @notice Registers the caller as an operator in EigenLayer.\n * @param initDelegationApprover is an address that, if set, must provide a signature when stakers delegate\n * to an operator.\n * @param allocationDelay The delay before allocations take effect.\n * @param metadataURI is a URI for the operator's metadata, i.e. a link providing more details on the operator.\n *\n * @dev Once an operator is registered, they cannot 'deregister' as an operator, and they will forever be considered \"delegated to themself\".\n * @dev This function will revert if the caller is already delegated to an operator.\n * @dev Note that the `metadataURI` is *never stored * and is only emitted in the `OperatorMetadataURIUpdated` event\n */\nfunction registerAsOperator(\n    address initDelegationApprover,\n    uint32 allocationDelay,\n    string calldata metadataURI\n) external nonReentrant;\n</code></pre> <p>Registers the caller as an operator in EigenLayer. The new operator provides the following input parameters: * <code>address initDelegationApprover</code>: (OPTIONAL) if set to a non-zero address, this address must sign and approve new delegation from stakers to this operator (See <code>delegateTo</code>) * <code>uint32 allocationDelay</code>: the delay (in blocks) before slashable stake allocations will take effect. This is passed to the <code>AllocationManager</code> (See <code>AllocationManager.md#setAllocationDelay</code>) * <code>string calldata metadataURI</code>: emits this input in the event <code>OperatorMetadataURIUpdated</code>. Does not store the value anywhere.</p> <p><code>registerAsOperator</code> cements the operator's delegation approver and allocation delay in storage, and self-delegates the operator to themselves - permanently marking the caller as an operator. They cannot \"deregister\" as an operator - however, if they have deposited funds, they can still withdraw them (See Delegation and Withdrawals).</p> <p>Effects: * Sets <code>_operatorDetails[operator].delegationApprover</code>. Note that the other <code>OperatorDetails</code> fields are deprecated; only the <code>delegationApprover</code> is used. * Delegates the operator to themselves     * Tabulates any deposited shares across the <code>EigenPodManager</code> and <code>StrategyManager</code>, and delegates these shares to themselves     * For each strategy in which the operator holds assets, updates the operator's <code>depositScalingFactor</code> for that strategy</p> <p>Requirements: * Caller MUST NOT already be delegated * Pause status MUST NOT be set: <code>PAUSED_NEW_DELEGATION</code> * For each strategy in which the operator holds assets, their <code>slashingFactor</code> for that strategy MUST be non-zero.</p>"},{"location":"docs/core/DelegationManager/#modifyoperatordetails","title":"<code>modifyOperatorDetails</code>","text":"<pre><code>/**\n * @notice Updates an operator's stored `delegationApprover`.\n * @param operator is the operator to update the delegationApprover for\n * @param newDelegationApprover is the new delegationApprover for the operator\n *\n * @dev The caller must have previously registered as an operator in EigenLayer.\n */\nfunction modifyOperatorDetails(\n    address operator, \n    address newDelegationApprover\n) \n    external \n    checkCanCall(operator)\n    nonReentrant\n</code></pre> <p>Note: this method can be called directly by an operator, or by a caller authorized by the operator. See <code>PermissionController.md</code> for details.</p> <p>Allows an operator to update their stored <code>delegationApprover</code>.</p> <p>Requirements: * <code>address operator</code> MUST already be an operator. * Caller MUST be authorized: either the operator themselves, or an admin/appointee (see <code>PermissionController.md</code>)</p>"},{"location":"docs/core/DelegationManager/#updateoperatormetadatauri","title":"<code>updateOperatorMetadataURI</code>","text":"<pre><code>/**\n * @notice Called by an operator to emit an `OperatorMetadataURIUpdated` event indicating the information has updated.\n * @param operator The operator to update metadata for\n * @param metadataURI The URI for metadata associated with an operator\n * @dev Note that the `metadataURI` is *never stored * and is only emitted in the `OperatorMetadataURIUpdated` event\n */\nfunction updateOperatorMetadataURI(\n    address operator, \n    string calldata metadataURI\n) \n    external \n    checkCanCall(operator)\n</code></pre> <p>Note: this method can be called directly by an operator, or by a caller authorized by the operator. See <code>PermissionController.md</code> for details.</p> <p>Allows an operator to emit an <code>OperatorMetadataURIUpdated</code> event. No other state changes occur.</p> <p>Requirements: * <code>address operator</code> MUST already be an operator. * Caller MUST be authorized: either the operator themselves, or an admin/appointee (see <code>PermissionController.md</code>)</p>"},{"location":"docs/core/DelegationManager/#delegation-and-withdrawals","title":"Delegation and Withdrawals","text":"<p>Concepts: * Shares Accounting * Legacy and Post-Slashing Withdrawals * Slashing Factors and Scaling Shares</p> <p>Methods: * <code>DelegationManager.delegateTo</code> * <code>DelegationManager.undelegate</code> * <code>DelegationManager.redelegate</code> * <code>DelegationManager.queueWithdrawals</code> * <code>DelegationManager.completeQueuedWithdrawal</code> * <code>DelegationManager.completeQueuedWithdrawals</code></p>"},{"location":"docs/core/DelegationManager/#legacy-and-post-slashing-withdrawals","title":"Legacy and Post-Slashing Withdrawals","text":"<p>The <code>DelegationManager</code> tracks withdrawal-related state in the following mappings:</p> <pre><code>/**\n * @dev A struct representing an existing queued withdrawal. After the withdrawal delay has elapsed, this withdrawal can be completed via `completeQueuedWithdrawal`.\n * A `Withdrawal` is created by the `DelegationManager` when `queueWithdrawals` is called. The `withdrawalRoots` hashes returned by `queueWithdrawals` can be used\n * to fetch the corresponding `Withdrawal` from storage (via `queuedWithdrawals`).\n *\n * @param staker The address that queued the withdrawal\n * @param delegatedTo The address that the staker was delegated to at the time the withdrawal was queued. Used to determine if additional slashing occurred before\n * this withdrawal became completable.\n * @param withdrawer The address that will call the contract to complete the withdrawal. Note that this will always equal `staker`; alternate withdrawers are not\n * supported at this time.\n * @param nonce The staker's `cumulativeWithdrawalsQueued` at time of queuing. Used to ensure withdrawals have unique hashes.\n * @param startBlock The block number when the withdrawal was queued.\n * @param strategies The strategies requested for withdrawal when the withdrawal was queued\n * @param scaledShares The staker's deposit shares requested for withdrawal, scaled by the staker's `depositScalingFactor`. Upon completion, these will be\n * scaled by the appropriate slashing factor as of the withdrawal's completable block. The result is what is actually withdrawable.\n */\nstruct Withdrawal {\n    address staker;\n    address delegatedTo;\n    address withdrawer;\n    uint256 nonce;\n    uint32 startBlock;\n    IStrategy[] strategies;\n    uint256[] scaledShares;\n}\n\n/// @dev Returns whether a withdrawal is pending for a given `withdrawalRoot`.\n/// @dev This variable will be deprecated in the future, values should only be read or deleted.\nmapping(bytes32 withdrawalRoot =&gt; bool pending) public pendingWithdrawals;\n\n/// @notice Returns the total number of withdrawals that have been queued for a given `staker`.\n/// @dev This only increments (doesn't decrement), and is used to help ensure that otherwise identical withdrawals have unique hashes.\nmapping(address staker =&gt; uint256 totalQueued) public cumulativeWithdrawalsQueued;\n\n/// @notice Returns a list of queued withdrawals for a given `staker`.\n/// @dev Entries are removed when the withdrawal is completed.\n/// @dev This variable only reflects withdrawals that were made after the slashing release.\nmapping(address staker =&gt; EnumerableSet.Bytes32Set withdrawalRoots) internal _stakerQueuedWithdrawalRoots;\n\n/// @notice Returns the details of a queued withdrawal given by `withdrawalRoot`.\n/// @dev This variable only reflects withdrawals that were made after the slashing release.\nmapping(bytes32 withdrawalRoot =&gt; Withdrawal withdrawal) public queuedWithdrawals;\n\n/// @notice Contains history of the total cumulative staker withdrawals for an operator and a given strategy.\n/// Used to calculate burned StrategyManager shares when an operator is slashed.\n/// @dev Stores scaledShares instead of total withdrawn shares to track current slashable shares, dependent on the maxMagnitude\nmapping(address operator =&gt; mapping(IStrategy strategy =&gt; Snapshots.DefaultZeroHistory)) internal\n    _cumulativeScaledSharesHistory;\n</code></pre> <p>Prior to the slashing release, withdrawals were only stored as hashes in the <code>pendingWithdrawals</code> mapping. </p> <p>With the slashing release, withdrawals are now stored entirely in state, and two new mappings have been added to support this: * <code>_stakedQueuedWithdrawalRoots</code>: a list of all the currently-queued withdrawal hashes belonging to a staker * <code>queuedWithdrawals</code>: maps queued withdrawal hash to <code>Withdrawal</code> struct</p> <p>Legacy withdrawals remain completable using the same methods as new withdrawals. The primary difference between the two is that it is not possible to query the corresponding <code>Withdrawal</code> struct for a legacy withdrawal hash. When determining what <code>Withdrawal</code> struct to supply to the contract to complete a legacy withdrawal, the caller will need to derive the original <code>Withdrawal</code> struct generated when the withdrawal was queued.</p>"},{"location":"docs/core/DelegationManager/#slashing-factors-and-scaling-shares","title":"Slashing Factors and Scaling Shares","text":"<p>See the Shares Accounting doc for a more thorough explanation with examples.</p> <p>Throughout the <code>DelegationManager</code>, a staker's deposit shares can be converted into their current withdrawable shares by applying two factors: the slashing factor and the deposit scaling factor. These two values are scaling factors that act as numerators when scaling shares. By default, these values start at <code>1 WAD</code> (<code>1e18</code>). <code>1 WAD</code> also acts as the denominator when scaling.</p> <pre><code>/// @dev All scaling factors have `1e18` as an initial/default value. This value is represented\n/// by the constant `WAD`, which is used to preserve precision with uint256 math.\n///\n/// When applying scaling factors, they are typically multiplied/divided by `WAD`, allowing this\n/// constant to act as a \"1\" in mathematical formulae.\nuint64 constant WAD = 1e18;\n</code></pre> <p>The deposit scaling factor is represented in <code>DelegationManager</code> storage, and can be thought of as a way to normalize newly-deposited shares using the current slashing factor, so that future withdrawals can be scaled appropriately if the slashing factor has changed:</p> <pre><code>/*\n * There are 2 types of shares:\n *      1. deposit shares\n *          - These can be converted to an amount of tokens given a strategy\n *              - by calling `sharesToUnderlying` on the strategy address (they're already tokens \n *              in the case of EigenPods)\n *          - These live in the storage of the EigenPodManager and individual StrategyManager strategies \n *      2. withdrawable shares\n *          - For a staker, this is the amount of shares that they can withdraw\n *          - For an operator, the shares delegated to them are equal to the sum of their stakers'\n *            withdrawable shares\n *\n * Along with a slashing factor, the DepositScalingFactor is used to convert between the two share types.\n */\nstruct DepositScalingFactor {\n    uint256 _scalingFactor;\n}\n\n/// @notice Returns the scaling factor applied to a `staker` for a given `strategy`\nmapping(address staker =&gt; mapping(IStrategy strategy =&gt; DepositScalingFactor)) internal _depositScalingFactor;\n</code></pre> <p>Calculating the slashing factor varies depending on the strategy in question. For all strategies, the slashing factor is the max magnitude of the staker's delegated <code>operator</code> in the <code>AllocationManager</code> (See Max vs Encumbered Magnitude). If the staker is NOT delegated, this is <code>WAD</code> (aka \"1\").</p> <p>For the <code>beaconChainETHStrategy</code>, the slashing factor also includes the staker's <code>beaconChainSlashingFactor</code>, which acts like the <code>operator's</code> max magnitude, but for a staker's beacon chain assets. This means that, for the <code>beaconChainETHStrategy</code> specifically, slashing factors can be applied because of EITHER/BOTH: * <code>operator</code> got slashed for this strategy by an AVS * <code>staker</code> got slashed on the beacon chain</p> <p>From <code>DelegationManager.sol</code>:</p> <pre><code>/// @dev Calculate the amount of slashing to apply to the staker's shares\nfunction _getSlashingFactor(\n    address staker,\n    IStrategy strategy,\n    uint64 operatorMaxMagnitude\n) internal view returns (uint256) {\n    if (strategy == beaconChainETHStrategy) {\n        uint64 beaconChainSlashingFactor = eigenPodManager.beaconChainSlashingFactor(staker);\n        return operatorMaxMagnitude.mulWad(beaconChainSlashingFactor);\n    }\n\n    return operatorMaxMagnitude;\n}\n</code></pre>"},{"location":"docs/core/DelegationManager/#delegateto","title":"<code>delegateTo</code>","text":"<pre><code>// @notice Struct that bundles together a signature and an expiration time for the signature. Used primarily for stack management.\nstruct SignatureWithExpiry {\n    // the signature itself, formatted as a single bytes object\n    bytes signature;\n    // the expiration timestamp (UTC) of the signature\n    uint256 expiry;\n}\n\n/**\n * @notice Caller delegates their stake to an operator.\n * @param operator The account (`msg.sender`) is delegating its assets to for use in serving applications built on EigenLayer.\n * @param approverSignatureAndExpiry (optional) Verifies the operator approves of this delegation\n * @param approverSalt (optional) A unique single use value tied to an individual signature.\n * @dev The signature/salt are used ONLY if the operator has configured a delegationApprover.\n * If they have not, these params can be left empty.\n */\nfunction delegateTo(\n    address operator, \n    SignatureWithExpiry memory approverSignatureAndExpiry, \n    bytes32 approverSalt\n) \n    external\n    nonReentrant\n</code></pre> <p>Allows a staker to delegate their assets to an operator. Delegation is all-or-nothing: when a staker delegates to an operator, they delegate ALL their assets. Stakers can only be delegated to one operator at a time.</p> <p>For each strategy the staker has deposit shares in, the <code>DelegationManager</code> will: * Query the staker's deposit shares from the <code>StrategyManager/EigenPodManager</code> * Get the slashing factor for this <code>(staker, operator, strategy)</code> and use it to update the staker's deposit scaling factor (See Slashing Factors and Scaling Shares) * Add the deposit shares to the operator's <code>operatorShares</code> directly. Note that the initial delegation to an operator is a special case where deposit shares == withdrawable shares.</p> <p>Effects: * Delegates the caller to the <code>operator</code>     * Tabulates any deposited shares across the <code>EigenPodManager</code> and <code>StrategyManager</code>, and delegates these shares to the <code>operator</code>     * For each strategy in which the caller holds assets, updates the caller's <code>depositScalingFactor</code> for that strategy</p> <p>Requirements: * The caller MUST NOT already be delegated to an operator * The <code>operator</code> MUST already be an operator * If the <code>operator</code> has a <code>delegationApprover</code>, the caller MUST provide a valid <code>approverSignatureAndExpiry</code> and <code>approverSalt</code> * Pause status MUST NOT be set: <code>PAUSED_NEW_DELEGATION</code> * For each strategy in which the staker holds assets, the <code>slashingFactor</code> for that strategy MUST be non-zero.</p>"},{"location":"docs/core/DelegationManager/#undelegate","title":"<code>undelegate</code>","text":"<pre><code>/**\n * @notice Undelegates the staker from their operator and queues a withdrawal for all of their shares\n * @param staker The account to be undelegated\n * @return withdrawalRoots The roots of the newly queued withdrawals, if a withdrawal was queued. Returns \n * an empty array if none was queued.\n *\n * @dev Reverts if the `staker` is also an operator, since operators are not allowed to undelegate from themselves.\n * @dev Reverts if the caller is not the staker, nor the operator who the staker is delegated to, nor the operator's specified \"delegationApprover\"\n * @dev Reverts if the `staker` is not delegated to an operator\n */\nfunction undelegate(\n    address staker\n) \n    external\n    nonReentrant\n    returns (bytes32[] memory withdrawalRoots);\n</code></pre> <p>Note: this method can be called directly by an operator, or by a caller authorized by the operator. See <code>PermissionController.md</code> for details.</p> <p><code>undelegate</code> can be called EITHER by a staker to undelegate themselves, OR by an operator to force-undelegate a staker from them. Force-undelegation is primarily useful if an operator has a <code>delegationApprover</code>, as this role is the only way to prevent a staker from delegating back to the operator once force-undelegated.</p> <p>Undelegation immediately sets the staker's delegated operator to 0, decreases the prior operator's delegated shares, and queues withdrawals for all of the staker's deposited assets. For UX reasons, one withdrawal is queued for each strategy in which the staker has deposited assets. Queued withdrawals mimic the behavior of the <code>queueWithdrawals</code> method; see that method's documentation for details.</p> <p>Just as with a normal queued withdrawal, these withdrawals can be completed by the staker after <code>MIN_WITHDRAWAL_DELAY_BLOCKS</code>. These withdrawals do not require the staker to \"fully exit\" from the system -- the staker may choose to keep their assets in the system once withdrawals are completed (See <code>completeQueuedWithdrawal</code> for details).</p> <p>Effects:  * The <code>staker</code> is undelegated from their operator * If the <code>staker</code> has no deposit shares, there is no withdrawal queued or further effects * For each strategy held by the <code>staker</code>, a <code>Withdrawal</code> is queued:     * Deposit shares are removed from the staker's deposit share balances         * See <code>EigenPodManager.removeDepositShares</code>         * See <code>StrategyManager.removeDepositShares</code>     * Deposit shares are converted to withdrawable shares (See Slashing Factors and Scaling Shares). These are decremented from the operator's delegated shares.     * Deposit shares are converted to scaled shares  (See Shares Accounting - Queue Withdrawals), which are stored in the <code>Withdrawal</code> struct     * Scaled shares are pushed to <code>_cumulativeScaledSharesHistory</code>, which is used for burning slashed shares     * The <code>Withdrawal</code> is saved to storage         * The hash of the <code>Withdrawal</code> is marked as \"pending\"         * The hash of the <code>Withdrawal</code> is set in a mapping to the <code>Withdrawal</code> struct itself         * The hash of the <code>Withdrawal</code> is pushed to <code>_stakerQueuedWithdrawalRoots</code>     * The staker's withdrawal nonce is increased by 1 for each <code>Withdrawal</code></p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_ENTER_WITHDRAWAL_QUEUE</code> * <code>staker</code> MUST be delegated to an operator * <code>staker</code> MUST NOT be an operator * <code>staker</code> parameter MUST NOT be zero * Caller MUST be authorized: either the <code>staker</code> themselves, their operator, their operator's <code>delegationApprover</code>, or their operator's admin/appointee (see <code>PermissionController.md</code>) * See <code>EigenPodManager.removeDepositShares</code> * See <code>StrategyManager.removeDepositShares</code></p>"},{"location":"docs/core/DelegationManager/#redelegate","title":"<code>redelegate</code>","text":"<pre><code>/**\n * @notice Undelegates the staker from their current operator, and redelegates to `newOperator`\n * Queues a withdrawal for all of the staker's withdrawable shares. These shares will only be\n * delegated to `newOperator` AFTER the withdrawal is completed.\n * @dev This method acts like a call to `undelegate`, then `delegateTo`\n * @param newOperator the new operator that will be delegated all assets\n * @dev NOTE: the following 2 params are ONLY checked if `newOperator` has a `delegationApprover`.\n * If not, they can be left empty.\n * @param newOperatorApproverSig A signature from the operator's `delegationApprover`\n * @param approverSalt A unique single use value tied to the approver's signature\n */\n function redelegate(\n    address newOperator,\n    SignatureWithExpiry memory newOperatorApproverSig,\n    bytes32 approverSalt\n) \n    external \n    returns (bytes32[] memory withdrawalRoots);\n</code></pre> <p><code>redelegate</code> is a convenience method that combines the effects of <code>undelegate</code> and <code>delegateTo</code>. <code>redelegate</code> allows a staker to switch their delegated operator to <code>newOperator</code> with a single call. Note, though, that the staker's assets will not be fully delegated to <code>newOperator</code> until the withdrawals queued during the undelegation portion of this method are completed.</p> <p>Effects:  * See <code>delegateTo</code> and <code>undelegate</code></p> <p>Requirements: * See <code>delegateTo</code> and <code>undelegate</code></p>"},{"location":"docs/core/DelegationManager/#queuewithdrawals","title":"<code>queueWithdrawals</code>","text":"<pre><code>/**\n * @param strategies The strategies to withdraw from\n * @param depositShares For each strategy, the number of deposit shares to withdraw. Deposit shares can\n * be queried via `getDepositedShares`.\n * NOTE: The number of shares ultimately received when a withdrawal is completed may be lower depositShares\n * if the staker or their delegated operator has experienced slashing.\n * @param __deprecated_withdrawer This field is ignored. The only party that may complete a withdrawal\n * is the staker that originally queued it. Alternate withdrawers are not supported.\n */\nstruct QueuedWithdrawalParams {\n    IStrategy[] strategies;\n    uint256[] depositShares;\n    address __deprecated_withdrawer;\n}\n\n/**\n * @notice Allows a staker to queue a withdrawal of their deposit shares. The withdrawal can be \n * completed after the MIN_WITHDRAWAL_DELAY_BLOCKS via either of the completeQueuedWithdrawal methods.\n * \n * While in the queue, these shares are removed from the staker's balance, as well as from their operator's\n * delegated share balance (if applicable). Note that while in the queue, deposit shares are still subject\n * to slashing. If any slashing has occurred, the shares received may be less than the queued deposit shares.\n *\n * @dev To view all the staker's strategies/deposit shares that can be queued for withdrawal, see `getDepositedShares`\n * @dev To view the current conversion between a staker's deposit shares and withdrawable shares, see `getWithdrawableShares`\n */\nfunction queueWithdrawals(\n    QueuedWithdrawalParams[] calldata queuedWithdrawalParams\n) \n    external \n    onlyWhenNotPaused(PAUSED_ENTER_WITHDRAWAL_QUEUE)\n    nonReentrant\n    returns (bytes32[] memory)\n</code></pre> <p>Allows the caller to queue their deposit shares for withdrawal across any strategy. Withdrawals can be completed after <code>MIN_WITHDRAWAL_DELAY_BLOCKS</code>, by calling <code>completeQueuedWithdrawal</code>. This method accepts deposit shares as input - however, the amounts received upon completion may be lower if the staker has experienced slashing (See Shares Accounting and Slashing Factors and Scaling Shares).</p> <p>For each <code>QueuedWithdrawalParams</code> passed as input, a <code>Withdrawal</code> is created in storage (See Legacy and Post-Slashing Withdrawals for details on structure and querying). Queueing a withdrawal involves multiple transformations to a staker's deposit shares, serving a few different purposes: * The raw deposit shares are removed from the staker's deposit share balance in the corresponding share manager (<code>EigenPodManager</code> or <code>StrategyManager</code>). * Scaled shares are calculated by applying the staker's deposit scaling factor to their deposit shares. Scaled shares:     * are stored in the <code>Withdrawal</code> itself and used during withdrawal completion     * are added to the operator's <code>cumulativeScaledSharesHistory</code>, where they can be burned if slashing occurs while the withdrawal is in the queue * Withdrawable shares are calculated by applying both the staker's deposit scaling factor AND any appropriate slashing factor to the staker's deposit shares. These \"currently withdrawable shares\" are removed from the operator's delegated shares (if applicable).</p> <p>Note that the <code>QueuedWithdrawalParams.__deprecated_withdrawer</code> field is ignored. Originally, this was used to create withdrawals that could be completed by a third party. This functionality was removed during the M2 release due to growing concerns over the phish risk this presented. Until the slashing release, this field was explicitly checked for equivalence with <code>msg.sender</code>; however, at present it is ignored. All <code>Withdrawals</code> are created with <code>withdrawer == staker</code> regardless of this field's value.</p> <p>Effects: * For each <code>QueuedWithdrawalParams</code> element:     * Deposit shares are removed from the staker's deposit share balances         * See <code>EigenPodManager.removeDepositShares</code>         * See <code>StrategyManager.removeDepositShares</code>     * Deposit shares are converted to withdrawable shares (See Slashing Factors and Scaling Deposits). These are decremented from their operator's delegated shares (if applicable)     * Deposit shares are converted to scaled shares  (See Shares Accounting - Queue Withdrawals), which are stored in the <code>Withdrawal</code> struct     * If the caller is delegated to an operator, scaled shares are pushed to that operator's <code>_cumulativeScaledSharesHistory</code>, which may be burned if slashing occurs.     * The <code>Withdrawal</code> is saved to storage         * The hash of the <code>Withdrawal</code> is marked as \"pending\"         * The hash of the <code>Withdrawal</code> is set in a mapping to the <code>Withdrawal</code> struct itself         * The hash of the <code>Withdrawal</code> is pushed to <code>_stakerQueuedWithdrawalRoots</code>     * The staker's withdrawal nonce is increased by 1</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_ENTER_WITHDRAWAL_QUEUE</code> * For each <code>QueuedWithdrawalParams</code> element:     * <code>strategies.length</code> MUST equal <code>depositShares.length</code>     * The <code>withdrawer</code> MUST equal <code>msg.sender</code>     * <code>strategies.length</code> MUST NOT be equal to 0     * See <code>EigenPodManager.removeDepositShares</code>     * See <code>StrategyManager.removeDepositShares</code></p>"},{"location":"docs/core/DelegationManager/#completequeuedwithdrawal","title":"<code>completeQueuedWithdrawal</code>","text":"<pre><code>/**\n * @dev A struct representing an existing queued withdrawal. After the withdrawal delay has elapsed, this withdrawal can be completed via `completeQueuedWithdrawal`.\n * A `Withdrawal` is created by the `DelegationManager` when `queueWithdrawals` is called. The `withdrawalRoots` hashes returned by `queueWithdrawals` can be used\n * to fetch the corresponding `Withdrawal` from storage (via `getQueuedWithdrawal`).\n *\n * @param staker The address that queued the withdrawal\n * @param delegatedTo The address that the staker was delegated to at the time the withdrawal was queued. Used to determine if additional slashing occurred before\n * this withdrawal became completable.\n * @param withdrawer The address that will call the contract to complete the withdrawal. Note that this will always equal `staker`; alternate withdrawers are not\n * supported at this time.\n * @param nonce The staker's `cumulativeWithdrawalsQueued` at time of queuing. Used to ensure withdrawals have unique hashes.\n * @param startBlock The block number when the withdrawal was queued.\n * @param strategies The strategies requested for withdrawal when the withdrawal was queued\n * @param scaledShares The staker's deposit shares requested for withdrawal, scaled by the staker's `depositScalingFactor`. Upon completion, these will be\n * scaled by the appropriate slashing factor as of the withdrawal's completable block. The result is what is actually withdrawable.\n */\nstruct Withdrawal {\n    address staker;\n    address delegatedTo;\n    address withdrawer;\n    uint256 nonce;\n    uint32 startBlock;\n    IStrategy[] strategies;\n    uint256[] scaledShares;\n}\n\n/**\n * @notice Used to complete a queued withdrawal\n * @param withdrawal The withdrawal to complete\n * @param tokens Array in which the i-th entry specifies the `token` input to the 'withdraw' function of the i-th Strategy in the `withdrawal.strategies` array.\n * @param tokens For each `withdrawal.strategies`, the underlying token of the strategy\n * NOTE: if `receiveAsTokens` is false, the `tokens` array is unused and can be filled with default values. However, `tokens.length` MUST still be equal to `withdrawal.strategies.length`.\n * NOTE: For the `beaconChainETHStrategy`, the corresponding `tokens` value is ignored (can be 0).\n * @param receiveAsTokens If true, withdrawn shares will be converted to tokens and sent to the caller. If false, the caller receives shares that can be delegated to an operator.\n * NOTE: if the caller receives shares and is currently delegated to an operator, the received shares are\n * automatically delegated to the caller's current operator.\n */\nfunction completeQueuedWithdrawal(\n    Withdrawal calldata withdrawal,\n    IERC20[] calldata tokens,\n    bool receiveAsTokens\n) \n    external \n    onlyWhenNotPaused(PAUSED_EXIT_WITHDRAWAL_QUEUE)\n    nonReentrant\n</code></pre> <p><code>MIN_WITHDRAWAL_DELAY_BLOCKS</code> after queueing, a staker can complete a <code>Withdrawal</code> by calling this method. The staker can elect to receive either tokens OR shares depending on the value of the <code>receiveAsTokens</code> parameter. </p> <p>Before processing a withdrawal, this method will calculate the slashing factor at the withdrawal's completion block (<code>withdrawal.startBlock + MIN_WITHDRAWAL_DELAY_BLOCKS</code>), according to the operator that was delegated to when the withdrawal was queued (<code>withdrawal.delegatedTo</code>). This slashing factor is used to determine if any additional slashing occurred while the withdrawal was in the queue. If so, this slashing is applied now.</p> <p>For each <code>Withdrawal</code>, <code>withdrawal.scaledShares</code> are converted into withdrawable shares, accounting for any slashing that occurred during the withdrawal period (See Shares Accounting - Complete Withdrawal).</p> <p>If the staker chooses to receive the withdrawal as tokens, the withdrawable shares are converted to tokens via the corresponding share manager (<code>EigenPodManager</code>/<code>StrategyManager</code>), and sent to the caller.</p> <p>If the staker chooses to receive the withdrawal as shares, the withdrawable shares are credited to the staker via the corresponding share manager (<code>EigenPodManager</code>/<code>StrategyManager</code>). Additionally, if the caller is delegated to an operator, the new slashing factor for the given <code>(staker, operator, strategy)</code> determines how many shares are awarded to the operator (and how the staker's deposit scaling factor is updated) (See Slashing Factors and Scaling Shares). In receiving the withdrawal as shares, this amount is credited as deposit shares for the staker. Due to known rounding error, the amount of withdrawable shares after completing the withdrawal may be slightly less than what was originally withdrawable.</p> <p>Note: if the staker (i) receives the withdrawal as shares, (ii) has <code>MAX_STAKER_STRATEGY_LIST_LENGTH</code> unique deposit strategies in the <code>StrategyManager</code>, and (iii) is withdrawing to a <code>StrategyManager</code> strategy in which they do not currently have shares, this will revert. The staker cannot withdraw such that their <code>stakerStrategyList</code> length exceeds the maximum; this withdrawal will have to be completed as tokens instead.</p> <p>Note: if the staker receives a <code>beaconChainETHStrategy</code> withdrawal as tokens, the staker's <code>EigenPod</code> MUST have sufficient <code>withdrawableExecutionLayerGwei</code> to honor the withdrawal.</p> <p>Effects: * The hash of the <code>Withdrawal</code> is removed from the pending withdrawals * The hash of the <code>Withdrawal</code> is removed from the enumerable set of staker queued withdrawals * The <code>Withdrawal</code> struct is removed from the queued withdrawals  * If <code>receiveAsTokens</code>:     * See <code>StrategyManager.withdrawSharesAsTokens</code>     * See <code>EigenPodManager.withdrawSharesAsTokens</code> * If <code>!receiveAsTokens</code>:     * Withdrawable shares are awarded to the caller and delegated to the caller's current operator if applicable     * See <code>StrategyManager.addShares</code>     * See <code>EigenPodManager.addShares</code></p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_EXIT_WITHDRAWAL_QUEUE</code> * <code>tokens.length</code> must equal <code>withdrawal.strategies.length</code> * Caller MUST be the <code>staker/withdrawer</code> specified in the <code>Withdrawal</code> * At least <code>MIN_WITHDRAWAL_DELAY_BLOCKS</code> MUST have passed before <code>completeQueuedWithdrawal</code> is called * The hash of the passed-in <code>Withdrawal</code> MUST correspond to a pending withdrawal * If <code>receiveAsTokens</code>:     * The caller MUST pass in the underlying <code>IERC20[] tokens</code> being withdrawn in the appropriate order according to the strategies in the <code>Withdrawal</code>.     * See <code>StrategyManager.withdrawSharesAsTokens</code>     * See <code>EigenPodManager.withdrawSharesAsTokens</code> * If <code>!receiveAsTokens</code>:     * See <code>StrategyManager.addShares</code>     * See <code>EigenPodManager.addShares</code></p>"},{"location":"docs/core/DelegationManager/#completequeuedwithdrawals","title":"<code>completeQueuedWithdrawals</code>","text":"<pre><code>/**\n * @notice Used to complete multiple queued withdrawals\n * @param withdrawals Array of Withdrawals to complete. See `completeQueuedWithdrawal` for the usage of a single Withdrawal.\n * @param tokens Array of tokens for each Withdrawal. See `completeQueuedWithdrawal` for the usage of a single array.\n * @param receiveAsTokens Whether or not to complete each withdrawal as tokens. See `completeQueuedWithdrawal` for the usage of a single boolean.\n * @dev See `completeQueuedWithdrawal` for relevant dev tags\n */\nfunction completeQueuedWithdrawals(\n    Withdrawal[] calldata withdrawals,\n    IERC20[][] calldata tokens,\n    bool[] calldata receiveAsTokens\n) \n    external \n    onlyWhenNotPaused(PAUSED_EXIT_WITHDRAWAL_QUEUE) \n    nonReentrant\n</code></pre> <p>This method is the plural version of <code>completeQueuedWithdrawal</code>.</p>"},{"location":"docs/core/DelegationManager/#slashing-and-accounting","title":"Slashing and Accounting","text":"<p>These methods are all called by other system contracts: the <code>AllocationManager</code> calls <code>slashOperatorShares</code> during slashing, and the <code>EigenPodManager/StrategyManager</code> call <code>increaseDelegatedShares/decreaseDelegatedShares</code> when stakers' deposit shares (or when beacon chain balance decreases occur).</p> <p>Methods: * <code>DelegationManager.slashOperatorShares</code> * <code>DelegationManager.increaseDelegatedShares</code> * <code>DelegationManager.decreaseDelegatedShares</code></p>"},{"location":"docs/core/DelegationManager/#slashoperatorshares","title":"<code>slashOperatorShares</code>","text":"<pre><code>/**\n * @notice Decreases the operators shares in storage after a slash and increases the burnable shares by calling\n * into either the StrategyManager or EigenPodManager (if the strategy is beaconChainETH).\n * @param operator The operator to decrease shares for\n * @param strategy The strategy to decrease shares for\n * @param prevMaxMagnitude the previous maxMagnitude of the operator\n * @param newMaxMagnitude the new maxMagnitude of the operator\n * @dev Callable only by the AllocationManager\n * @dev Note: Assumes `prevMaxMagnitude &lt;= newMaxMagnitude`. This invariant is maintained in\n * the AllocationManager.\n */\nfunction slashOperatorShares(\n    address operator,\n    IStrategy strategy,\n    uint64 prevMaxMagnitude,\n    uint64 newMaxMagnitude\n) \n    external\n    onlyAllocationManager\n    nonReentrant\n</code></pre> <p>See Shares Accounting - Slashing for a description of the accounting in this method.</p> <p>This method is called by the <code>AllocationManager</code> when processing an AVS's slash of an operator. Slashing occurs instantly, with this method directly reducing the operator's delegated shares proportional to the slash.</p> <p>Additionally, any slashable shares in the withdrawal queue are marked for burning according to the same slashing proportion (shares in the withdrawal queue remain slashable for <code>MIN_WITHDRAWAL_DELAY_BLOCKS</code>). For the slashed strategy, the corresponding share manager (<code>EigenPodManager/StrateyManager</code>) is called, increasing the burnable shares for that strategy.</p> <p>Note: native ETH does not currently possess a burning mechanism, as this requires Pectra to be able to force exit validators. Currently, slashing for the <code>beaconChainETHStrategy</code> is realized by modifying the amount stakers are able to withdraw.</p> <p>Effects: * The <code>operator's</code> <code>operatorShares</code> are reduced for the given <code>strategy</code>, according to the proportion given by <code>prevMaxMagnitude</code> and <code>newMaxMagnitude</code> * Any slashable shares in the withdrawal queue are marked for burning according to the same proportion * See <code>StrategyManager.increaseBurnableShares</code> * See <code>EigenPodManager.increaseBurnableShares</code></p> <p>Requirements: * The amount slashed from the operator must not result in underflow of their <code>operatorShares</code> for the given <code>strategy</code></p>"},{"location":"docs/core/DelegationManager/#increasedelegatedshares","title":"<code>increaseDelegatedShares</code>","text":"<pre><code>/**\n * @notice Called by a share manager when a staker's deposit share balance in a strategy increases.\n * This method delegates any new shares to an operator (if applicable), and updates the staker's \n * deposit scaling factor regardless.\n * @param staker The address whose deposit shares have increased\n * @param strategy The strategy in which shares have been deposited\n * @param prevDepositShares The number of deposit shares the staker had in the strategy prior to the increase\n * @param addedShares The number of deposit shares added by the staker\n *\n * @dev Note that if either the staker's current operator has been slashed 100% for `strategy`, OR the\n * staker has been slashed 100% on the beacon chain such that the calculated slashing factor is 0, this\n * method WILL REVERT.\n */\nfunction increaseDelegatedShares(\n    address staker,\n    IStrategy strategy,\n    uint256 prevDepositShares,\n    uint256 addedShares\n) \n    external\n    onlyStrategyManagerOrEigenPodManager\n    nonReentrant\n</code></pre> <p>Called by either the <code>StrategyManager</code> or <code>EigenPodManager</code> when a staker's deposit shares for one or more strategies increase.</p> <p>If the staker is delegated to an operator, the new deposit shares are directly added to that operator's <code>operatorShares</code>. Regardless of delegation status, the staker's deposit scaling factor is updated.</p> <p>Note that if either the staker's current operator has been slashed 100% for <code>strategy</code>, OR the staker has been slashed 100% on the beacon chain such that the calculated slashing factor is 0, this method WILL REVERT. See Shares Accounting - Fully Slashed for details. This doesn't block delegation to an operator if the staker has 0 deposit shares for a strategy which has a slashing factor of 0, but any subsequent deposits that call <code>increaseDelegatedShares</code> will revert from the Fully Slashed edge case.</p> <p>Effects: * If the staker is delegated to an operator, <code>addedShares</code> are added to the operator's shares * The staker's deposit scaling factor is updated</p> <p>Requirements: * Caller MUST be either the <code>StrategyManager</code> or <code>EigenPodManager</code></p>"},{"location":"docs/core/DelegationManager/#decreasedelegatedshares","title":"<code>decreaseDelegatedShares</code>","text":"<pre><code>/**\n * @notice If the staker is delegated, decreases its operator's shares in response to\n * a decrease in balance in the beaconChainETHStrategy\n * @param staker the staker whose operator's balance will be decreased\n * @param curDepositShares the current deposit shares held by the staker\n * @param beaconChainSlashingFactorDecrease the amount that the staker's beaconChainSlashingFactor has decreased by\n * @dev Note: `beaconChainSlashingFactorDecrease` are assumed to ALWAYS be &lt; 1 WAD.\n * These invariants are maintained in the EigenPodManager.\n */\nfunction decreaseDelegatedShares(\n    address staker,\n    uint256 curDepositShares,\n    uint64 beaconChainSlashingFactorDecrease\n) \n    external\n    onlyEigenPodManager\n    nonReentrant\n</code></pre> <p>Called by the <code>EigenPodManager</code> when a staker's shares decrease due to a checkpointed balance decrease on the beacon chain. If the staker is delegated to an operator, the operator's shares are decreased in return. Otherwise, this method does nothing.</p> <p>Effects: If the staker in question is delegated to an operator, the operator's shares for the <code>beaconChainETHStrategy</code> are decreased by the amount the staker's withdrawable shares have decreased by * This method is a no-op if the staker is not delegated to an operator.</p> <p>Requirements: * Caller MUST be the <code>EigenPodManager</code></p>"},{"location":"docs/core/EigenPod/","title":"EigenPod","text":""},{"location":"docs/core/EigenPod/#eigenpod","title":"EigenPod","text":"File Type Proxy <code>EigenPod.sol</code> Instanced, deployed per-user Beacon proxy <p>An <code>EigenPod</code> is deployed via the <code>EigenPodManager</code> by a Staker (referred to in this doc as the Pod Owner). <code>EigenPods</code> allow a Pod Owner to restake one or more beacon chain validators, earning shares which can be delegated to Operators to earn yield. When a Pod Owner begins running a validator on the beacon chain, they choose withdrawal credentials for that validator. Withdrawal credentials are the ETH address to which: * A validator's principal is sent when the validator exits the beacon chain * A validator's consensus rewards are sent as the validator proposes/attests to blocks on the beacon chain</p> <p>Additionally, when running validator node software, a validator is configured with a fee recipient. The fee recipient receives: * Execution layer rewards when the validator proposes a block * MEV rewards if the validator is running MEV-boost/other custom block proposer software</p> <p>An <code>EigenPod</code> may serve as EITHER/BOTH the withdrawal credentials OR the fee recipient for your validators. In prior releases, it was only possible to use an <code>EigenPod</code> for withdrawal credentials. However, this is no longer the case!</p> <p>The primary goal of the <code>EigenPod</code> system is to ensure that shares are backed 1:1 with ETH that is either already in the <code>EigenPod</code>, or will eventually flow through the <code>EigenPod</code>. To support this goal, <code>EigenPods</code>:  * serve as the withdrawal credentials for one or more beacon chain validators controlled by the Pod Owner * validate beacon chain state proofs * interpret these proofs to add or remove shares in the beacon chain ETH strategy</p> <p>Because beacon chain proofs are processed asynchronously from the beacon chain itself, there is an inherent lag between an event on the beacon chain and a corresponding share update in any affected <code>EigenPods</code>. Therefore, the secondary goals of the <code>EigenPod</code> system are to minimize lag where possible and to ensure various timing windows cannot (i) create unbacked shares or (ii) prevent the withdrawal of existing shares.</p>"},{"location":"docs/core/EigenPod/#high-level-concepts","title":"High-level Concepts","text":"<ul> <li>Restaking Beacon Chain ETH</li> <li>Checkpointing Validators</li> <li>Staleness Proofs</li> <li>Other Methods</li> </ul>"},{"location":"docs/core/EigenPod/#important-definitions","title":"Important Definitions","text":"<p>Pod Owner: A Staker who has deployed an <code>EigenPod</code> is a Pod Owner. The terms are used interchangeably in this document. * Pod Owners can only deploy a single <code>EigenPod</code>, but can restake any number of beacon chain validators from the same <code>EigenPod</code>. * Pod Owners can delegate their <code>EigenPodManager</code> shares to Operators (via <code>DelegationManager</code>). * These shares correspond to the amount of restaked beacon chain ETH held by the Pod Owner via their <code>EigenPod</code>.</p> <p>Proof Submitter: An address designated by the Pod Owner with permissions to call certain <code>EigenPod</code> methods. This role is provided to allow Pod Owners to manage their day-to-day <code>EigenPod</code> tasks via hot wallets, rather than the Pod Owner address which controls all funds. The Proof Submitter can call <code>verifyWithdrawalCredentials</code> and <code>startCheckpoint</code>. See <code>setProofSubmitter</code> docs for more details.</p> <p>Active validator set: This term is used frequently in this document to describe the set of validators whose withdrawal credentials have been verified to be pointed at an <code>EigenPod</code>. The active validator set is used to determine the number of proofs required to complete a checkpoint (see Checkpointing Validators). * A validator enters the active validator set when their withdrawal credentials are verified (see <code>verifyWithdrawalCredentials</code>) * A validator leaves the active validator set when a checkpoint proof shows they have 0 balance (see <code>verifyCheckpointProofs</code>)</p> <p>In the implementation, the active validator set is comprised of two state variables: * <code>uint256 activeValidatorCount</code>      * incremented by 1 when a validator enters the active validator set     * decremented by 1 when a validator leaves the active validator set * <code>mapping(bytes32 =&gt; ValidatorInfo) _validatorPubkeyHashToInfo</code> (specifically, the <code>status</code> field)     * <code>VALIDATOR_STATUS.INACTIVE -&gt; VALIDATOR_STATUS.ACTIVE</code> when entering the active validator set     * <code>VALIDATOR_STATUS.ACTIVE -&gt; VALIDATOR_STATUS.WITHDRAWN</code> when leaving the active validator set</p> <p>Checkpoint: A snapshot of <code>EigenPod</code> and beacon chain state used to update the Pod Owner's shares based on a combination of beacon chain balance and native ETH balance. Checkpoints allow an <code>EigenPod</code> to account for validator exits, partial withdrawals of consensus rewards, or execution layer fees earned by their validators. Completing a checkpoint will account for these amounts in the <code>EigenPod</code>, enabling the Pod Owner to compound their restaked shares or withdraw accumulated yield.</p> <p>Only one checkpoint can be active at a time in a given <code>EigenPod</code>. The pod's current checkpoint is represented by the following data structure:</p> <pre><code>struct Checkpoint {\n    bytes32 beaconBlockRoot;  // proofs are verified against a beacon block root\n    uint24 proofsRemaining;   // number of proofs remaining before the checkpoint is completed\n    uint64 podBalanceGwei;    // native ETH that will be awarded shares when the checkpoint is completed\n    int128 balanceDeltasGwei; // total change in beacon chain balance tracked across submitted proofs\n}\n</code></pre> <p>Checkpoints are completed by submitting one beacon chain proof per validator in the pod's active validator set. See Checkpointing Validators for details.</p>"},{"location":"docs/core/EigenPod/#restaking-beacon-chain-eth","title":"Restaking Beacon Chain ETH","text":"<p>If a Pod Owner has validators whose withdrawal credentials are an <code>EigenPod</code>, the Pod Owner can use <code>verifyWithdrawalCredentials</code> to begin restaking ETH while it is still on the beacon chain. Once a validator's withdrawal credentials are verified: * the Pod Owner receives delegatable shares via <code>EigenPodManager.podOwnerShares</code> * the validator enters the pod's active validator set, and must be included in future checkpoint proofs (see Checkpointing Validators)</p> <p>Methods: * <code>verifyWithdrawalCredentials</code></p>"},{"location":"docs/core/EigenPod/#verifywithdrawalcredentials","title":"<code>verifyWithdrawalCredentials</code>","text":"<pre><code>function verifyWithdrawalCredentials(\n    uint64 beaconTimestamp,\n    BeaconChainProofs.StateRootProof calldata stateRootProof,\n    uint40[] calldata validatorIndices,\n    bytes[] calldata validatorFieldsProofs,\n    bytes32[][] calldata validatorFields\n)\n    external\n    onlyOwnerOrProofSubmitter\n    onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_CREDENTIALS)\n\nstruct StateRootProof {\n    bytes32 beaconStateRoot;\n    bytes proof;\n}\n</code></pre> <p>This method first verifies a beacon state root against a beacon block root returned by the EIP-4788 oracle. Then, it verifies one or more withdrawal credential proofs against the beacon state root. Finally, the Pod Owner is awarded shares according to the sum of the effective balance of each verified validator (via <code>EigenPodManager.recordBeaconChainETHBalanceUpdate</code>).</p> <p>A withdrawal credential proof uses a validator's <code>ValidatorIndex</code> and a merkle proof to prove the existence of a <code>Validator</code> container at a given block. The beacon chain <code>Validator</code> container holds important information used in this method: * <code>pubkey</code>: A BLS pubkey hash, used to uniquely identify the validator within the <code>EigenPod</code> * <code>withdrawal_credentials</code>: Used to verify that the validator will withdraw its principal to this <code>EigenPod</code> if it exits the beacon chain * <code>effective_balance</code>: The balance of the validator, updated once per epoch and capped at 32 ETH. Used to award shares to the Pod Owner * <code>activation_epoch</code>: Initially set to <code>type(uint64).max</code>, this value is updated when a validator reaches a balance of at least 32 ETH, designating the validator is ready to become active on the beacon chain. This method requires that a validator is either already active, or in the process of activating on the beacon chain. * <code>exit_epoch</code>: Initially set to <code>type(uint64).max</code>, this value is updated when a validator initiates exit from the beacon chain. This method requires that a validator has not initiated an exit from the beacon chain.   * If a validator has been exited prior to calling <code>verifyWithdrawalCredentials</code>, their ETH can be accounted for, awarded shares, and/or withdrawn via the checkpoint system (see Checkpointing Validators).</p> <p>Note that it is not required to verify your validator's withdrawal credentials, unless you want to receive shares for ETH on the beacon chain. You may choose to use your <code>EigenPod</code> without verifying withdrawal credentials; you will still be able to withdraw yield (or receive shares for yield) via the checkpoint system.</p> <p>Effects: * For each set of unique verified withdrawal credentials:     * <code>activeValidatorCount</code> is increased by 1     * The validator's info is recorded in state (<code>_validatorPubkeyHashToInfo[pubkeyHash]</code>):         * <code>validatorIndex</code> is recorded from the passed-in <code>validatorIndices</code>         * <code>restakedBalanceGwei</code> is set to the validator's effective balance         * <code>lastCheckpointedAt</code> is set to either the <code>lastCheckpointTimestamp</code> or <code>currentCheckpointTimestamp</code>         * <code>VALIDATOR_STATUS</code> moves from <code>INACTIVE</code> to <code>ACTIVE</code> * The Pod Owner is awarded shares according to the sum of effective balances proven. See <code>EigenPodManager.recordBeaconChainETHBalanceUpdate</code></p> <p>Requirements: * Caller MUST be EITHER the Pod Owner or Proof Submitter * Pause status MUST NOT be set: <code>PAUSED_EIGENPODS_VERIFY_CREDENTIALS</code> * Input array lengths MUST be equal * <code>beaconTimestamp</code>:     * MUST be greater than <code>currentCheckpointTimestamp</code>     * MUST be queryable via the EIP-4788 oracle. Generally, this means <code>beaconTimestamp</code> corresponds to a valid beacon block created within the last 8192 blocks (~27 hours). * <code>stateRootProof</code> MUST verify a <code>beaconStateRoot</code> against the <code>beaconBlockRoot</code> returned from the EIP-4788 oracle * For each validator:     * The validator MUST NOT have been previously-verified (<code>VALIDATOR_STATUS</code> should be <code>INACTIVE</code>)     * The validator's <code>activation_epoch</code> MUST NOT equal <code>type(uint64).max</code> (aka <code>FAR_FUTURE_EPOCH</code>)     * The validator's <code>exit_epoch</code> MUST equal <code>type(uint64).max</code> (aka <code>FAR_FUTURE_EPOCH</code>)     * The validator's <code>withdrawal_credentials</code> MUST be pointed to the <code>EigenPod</code>     * <code>validatorFieldsProof</code> MUST be a valid merkle proof of the corresponding <code>validatorFields</code> under the <code>beaconStateRoot</code> at the given <code>validatorIndex</code> * See <code>EigenPodManager.recordBeaconChainETHBalanceUpdate</code></p>"},{"location":"docs/core/EigenPod/#checkpointing-validators","title":"Checkpointing Validators","text":"<p>Checkpoint proofs comprise the bulk of proofs submitted to an <code>EigenPod</code>. Completing a checkpoint means submitting one checkpoint proof for each validator in the pod's active validator set.</p> <p><code>EigenPods</code> use checkpoints to detect: * when validators have exited from the beacon chain, leaving the pod's active validator set * when the pod has accumulated fees / partial withdrawals from validators * whether any validators on the beacon chain have increased/decreased in balance</p> <p>When a checkpoint is completed, shares are updated accordingly for each of these events. OwnedShares can be withdrawn via the <code>DelegationManager</code> withdrawal queue (see DelegationManager: Undelegating and Withdrawing), which means an <code>EigenPod's</code> checkpoint proofs also play an important role in allowing Pod Owners to exit funds from the system.</p> <p>Important Notes: * <code>EigenPods</code> can only have one active checkpoint at a given time, and once started, checkpoints cannot be cancelled (only completed) * Checkpoint proofs are based entirely off of current balance proofs. Even though partial/full withdrawals are processed via checkpoint proofs, this system does NOT use withdrawal proofs.</p> <p>Methods: * <code>startCheckpoint</code> * <code>verifyCheckpointProofs</code></p>"},{"location":"docs/core/EigenPod/#startcheckpoint","title":"<code>startCheckpoint</code>","text":"<pre><code>function startCheckpoint(bool revertIfNoBalance)\n    external\n    onlyOwnerOrProofSubmitter() \n    onlyWhenNotPaused(PAUSED_START_CHECKPOINT) \n</code></pre> <p>This method allows a Pod Owner (or Proof Submitter) to start a checkpoint, beginning the process of proving a pod's active validator set. <code>startCheckpoint</code> takes a snapshot of three things: * <code>podBalanceGwei</code>: the <code>EigenPod's</code> native ETH balance, minus any balance already credited with shares through previous checkpoints     * Note: if <code>revertIfNoBalance == true</code>, this method will revert if <code>podBalanceGwei == 0</code>. This is to allow a Pod Owner to avoid creating a checkpoint unintentionally. * <code>activeValidatorCount</code>: the number of validators in the pod's active validator set, aka the number of validators with verified withdrawal credentials who have NOT been proven exited via a previous checkpoint     * This becomes the checkpoint's <code>proofsRemaining</code>, or the number of proofs that need to be submitted to <code>verifyCheckpointProofs</code> to complete the checkpoint * <code>beaconBlockRoot</code>: the beacon block root of the previous slot, fetched by querying the EIP-4788 oracle with the current <code>block.timestamp</code>     * This is used as the single source of truth for all proofs submitted for this checkpoint</p> <p><code>startCheckpoint</code> plays a very important role in the security of the checkpoint process: it guarantees that the pod's native ETH balance and any beacon balances proven in the checkpoint are 100% distinct. That is: if a partial/full exit is processed in the block before <code>startCheckpoint</code> is called, then: * The withdrawn ETH is already in the pod when <code>startCheckpoint</code> is called, and is factored into <code>podBalanceGwei</code> * A proof of the validator's current balance against <code>beaconBlockRoot</code> will NOT include the withdrawn ETH</p> <p>This guarantee means that, if we use the checkpoint to sum up the beacon chain balance of the pod's active validator set, we can award guaranteed-backed shares according to the sum of the pod's beacon chain balance and its native ETH balance.</p> <p>Effects: * Sets <code>currentCheckpointTimestamp</code> to <code>block.timestamp</code> * Creates a new <code>Checkpoint</code>:     * <code>beaconBlockRoot</code>: set to the current block's parent beacon block root, fetched by querying the EIP-4788 oracle using <code>block.timestamp</code> as input.     * <code>proofsRemaining</code>: set to the current value of <code>activeValidatorCount</code> (note that this value MAY be 0)     * <code>podBalanceGwei</code>: set to the pod's native ETH balance, minus any balance already accounted for in previous checkpoints     * <code>balanceDeltasGwei</code>: set to 0 initially * If <code>checkpoint.proofsRemaining == 0</code>, the new checkpoint is auto-completed:     * <code>withdrawableRestakedExecutionLayerGwei</code> is increased by <code>checkpoint.podBalanceGwei</code>     * <code>lastCheckpointTimestamp</code> is set to <code>currentCheckpointTimestamp</code>     * <code>currentCheckpointTimestamp</code> and <code>_currentCheckpoint</code> are deleted     * The Pod Owner's shares are updated (see <code>EigenPodManager.recordBeaconChainETHBalanceUpdate</code>)</p> <p>Requirements: * Caller MUST be EITHER the Pod Owner or Proof Submitter * Pause status MUST NOT be set: <code>PAUSED_START_CHECKPOINT</code> * A checkpoint MUST NOT be active (<code>currentCheckpointTimestamp == 0</code>) * The last checkpoint completed MUST NOT have been started in the current block (<code>lastCheckpointTimestamp != block.timestamp</code>) * If <code>revertIfNoBalance == true</code>, the pod's native ETH balance MUST contain some nonzero value not already accounted for in the Pod Owner's shares</p>"},{"location":"docs/core/EigenPod/#verifycheckpointproofs","title":"<code>verifyCheckpointProofs</code>","text":"<pre><code>function verifyCheckpointProofs(\n    BeaconChainProofs.BalanceContainerProof calldata balanceContainerProof,\n    BeaconChainProofs.BalanceProof[] calldata proofs\n)\n    external \n    onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_CHECKPOINT_PROOFS) \n\nstruct BalanceContainerProof {\n    bytes32 balanceContainerRoot;\n    bytes proof;\n}\n\nstruct BalanceProof {\n    bytes32 pubkeyHash;\n    bytes32 balanceRoot;\n    bytes proof;\n}\n</code></pre> <p><code>verifyCheckpointProofs</code> is used to make progress on (or complete) the pod's current checkpoint. This method accepts one or more merkle proofs of validators' current balances against a <code>balanceContainerRoot</code>. Additionally, a <code>balanceContainerProof</code> verifies this <code>balanceContainerRoot</code> against the current checkpoint's <code>beaconBlockRoot</code>.</p> <p>Proofs submitted to this method concern a validator's current balance, NOT their effective balance. The current balance is updated every slot, while effective balances are updated roughly once per epoch. Current balances are stored in the <code>BeaconState.balances</code> field.</p> <p>For each validator submitted via <code>proofs</code>: * The validator's <code>status</code> should be <code>ACTIVE</code>. That is, its withdrawal credentials are verified (see <code>verifyWithdrawalCredentials</code>), and it has a nonzero balance as of the last time it was seen in a checkpoint proof. * The validator's <code>lastCheckpointedAt</code> should be less than <code>currentCheckpointTimestamp</code>. This is to prevent a validator from counting towards a checkpoint's progression more than once.</p> <p>If either of these two conditions is not met, the proof will be skipped but execution will continue. Execution continues without reverting to prevent a potential griefing vector where anyone could frontrun a batch of proofs, submit one proof from the batch, and cause the batch to revert.</p> <p>Each valid proof submitted decreases the current checkpoint's <code>proofsRemaining</code> by 1. If <code>proofsRemaining</code> hits 0 the checkpoint is automatically completed, updating the Pod Owner's shares accordingly.</p> <p>Effects: * For each validator successfully checkpointed:     * The number of proofs remaining in the checkpoint is decreased (<code>checkpoint.proofsRemaining--</code>)     * A balance delta is calculated using the validator's previous <code>restakedBalanceGwei</code>. This delta is added to <code>checkpoint.balanceDeltasGwei</code> to track the total beacon chain balance delta.     * The validator's <code>restakedBalanceGwei</code> and <code>lastCheckpointedAt</code> fields are updated. Additionally, if the proof shows that the validator has a balance of 0, the validator's status is moved to <code>VALIDATOR_STATUS.WITHDRAWN</code> and the pod's <code>activeValidatorCount</code> is decreased. * If the checkpoint's <code>proofsRemaining</code> drops to 0, the checkpoint is automatically completed:     * <code>checkpoint.podBalanceGwei</code> is added to <code>withdrawableRestakedExecutionLayerGwei</code>, rendering it accounted for in future checkpoints     * <code>lastCheckpointTimestamp</code> is set to <code>currentCheckpointTimestamp</code>, and both <code>_currentCheckpoint</code> and <code>currentCheckpointTimestamp</code> are deleted.     * The Pod Owner's total share delta is calculated as the sum of <code>checkpoint.podBalanceGwei</code> and <code>checkpoint.balanceDeltasGwei</code>, and forwarded to the <code>EigenPodManager</code> (see <code>EigenPodManager.recordBeaconChainETHBalanceUpdate</code>)</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_EIGENPODS_VERIFY_CHECKPOINT_PROOFS</code> * A checkpoint MUST currently be active (<code>currentCheckpointTimestamp != 0</code>) * <code>balanceContainerProof</code> MUST contain a valid merkle proof of the beacon chain's balances container against <code>_currentCheckpoint.beaconBlockRoot</code> * Each <code>proof</code> in <code>proofs</code> MUST contain a valid merkle proof of the validator's <code>balanceRoot</code> against <code>balanceContainerProof.balanceContainerRoot</code></p>"},{"location":"docs/core/EigenPod/#staleness-proofs","title":"Staleness Proofs","text":"<p>Regular checkpointing of validators plays an important role in the health of the system, as a completed checkpoint ensures that the pod's shares and backing assets are up to date.</p> <p>Typically, checkpoints can only be started by the Pod Owner (see <code>startCheckpoint</code>). This is because completing a checkpoint with a lot of validators has the potential to be an expensive operation, so gating <code>startCheckpoint</code> to only be callable by the Pod Owner prevents a griefing vector where anyone can cheaply force the Pod Owner to perform a checkpoint.</p> <p>In most cases, Pod Owners are incentivized to perform their own regular checkpoints, as completing checkpoints is the only way to access yield sent to the pod. However, if beacon chain validators are slashed, it's possible that a Pod Owner no longer has an incentive to start/complete a checkpoint. After all, they would be losing shares equal to the slashed amount. Unless they have enough unclaimed yield in the pod to make up for this, they only stand to lose by completing a checkpoint.</p> <p>In this case, <code>verifyStaleBalance</code> can be used to allow a third party to start a checkpoint on the Pod Owner's behalf.</p> <p>Methods: * <code>verifyStaleBalance</code></p>"},{"location":"docs/core/EigenPod/#verifystalebalance","title":"<code>verifyStaleBalance</code>","text":"<pre><code>function verifyStaleBalance(\n    uint64 beaconTimestamp,\n    BeaconChainProofs.StateRootProof calldata stateRootProof,\n    BeaconChainProofs.ValidatorProof calldata proof\n)\n    external\n    onlyWhenNotPaused(PAUSED_START_CHECKPOINT) \n    onlyWhenNotPaused(PAUSED_VERIFY_STALE_BALANCE)\n</code></pre> <p>Allows anyone to prove that a validator in the pod's active validator set was slashed on the beacon chain. A successful proof allows the caller to start a checkpoint. Note that if the pod currently has an active checkpoint, the existing checkpoint needs to be completed before <code>verifyStaleBalance</code> can start a checkpoint.</p> <p>A valid proof has the following requirements: * The <code>beaconTimestamp</code> MUST be newer than the timestamp the validator was last checkpointed at * The validator in question MUST be in the active validator set (have the status <code>VALIDATOR_STATUS.ACTIVE</code>) * The proof MUST show that the validator has been slashed</p> <p>If these requirements are met and the proofs are valid against a beacon block root given by <code>beaconTimestamp</code>, a checkpoint is started.</p> <p>Effects: * Sets <code>currentCheckpointTimestamp</code> to <code>block.timestamp</code> * Creates a new <code>Checkpoint</code>:     * <code>beaconBlockRoot</code>: set to the current block's parent beacon block root, fetched by querying the EIP-4788 oracle using <code>block.timestamp</code> as input.     * <code>proofsRemaining</code>: set to the current value of <code>activeValidatorCount</code>     * <code>podBalanceGwei</code>: set to the pod's native ETH balance, minus any balance already accounted for in previous checkpoints     * <code>balanceDeltasGwei</code>: set to 0 initially</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_START_CHECKPOINT</code> * Pause status MUST NOT be set: <code>PAUSED_VERIFY_STALE_BALANCE</code> * A checkpoint MUST NOT be active (<code>currentCheckpointTimestamp == 0</code>) * The last checkpoint completed MUST NOT be the current block * For the validator given by <code>proof.validatorFields</code>:     * <code>beaconTimestamp</code> MUST be greater than <code>validatorInfo.lastCheckpointedAt</code>     * <code>validatorInfo.status</code> MUST be <code>VALIDATOR_STATUS.ACTIVE</code>     * <code>proof.validatorFields</code> MUST show that the validator is slashed * <code>stateRootProof</code> MUST verify a <code>beaconStateRoot</code> against the <code>beaconBlockRoot</code> returned from the EIP-4788 oracle * The <code>ValidatorProof</code> MUST contain a valid merkle proof of the corresponding <code>validatorFields</code> under the <code>beaconStateRoot</code> at <code>validatorInfo.validatorIndex</code></p>"},{"location":"docs/core/EigenPod/#other-methods","title":"Other Methods","text":"<p>Minor methods that do not fit well into other sections: * <code>setProofSubmitter</code> * <code>stake</code> * <code>withdrawRestakedBeaconChainETH</code> * <code>recoverTokens</code></p>"},{"location":"docs/core/EigenPod/#setproofsubmitter","title":"<code>setProofSubmitter</code>","text":"<pre><code>function setProofSubmitter(address newProofSubmitter) external onlyEigenPodOwner\n</code></pre> <p>Allows the Pod Owner to update the Proof Submitter address for the <code>EigenPod</code>. The Proof Submitter can call <code>verifyWithdrawalCredentials</code> and <code>startCheckpoint</code> just like the Pod Owner. This is intended to allow the Pod Owner to create a hot wallet to manage calls to these methods.</p> <p>If set, EITHER the Pod Owner OR Proof Submitter may call <code>verifyWithdrawalCredentials</code>/<code>startCheckpoint</code>.</p> <p>The Pod Owner can call this with <code>newProofSubmitter == 0</code> to remove the current Proof Submitter. If there is no designated Proof Submitter, ONLY the Pod Owner can call <code>verifyWithdrawalCredentials</code>/<code>startCheckpoint</code>.</p> <p>Effects: * Updates <code>proofSubmitter</code> to <code>newProofSubmitter</code></p> <p>Requirements: * Caller MUST be the Pod Owner</p>"},{"location":"docs/core/EigenPod/#stake","title":"<code>stake</code>","text":"<pre><code>function stake(\n    bytes calldata pubkey,\n    bytes calldata signature,\n    bytes32 depositDataRoot\n)\n    external \n    payable \n    onlyEigenPodManager\n</code></pre> <p>Handles the call to the beacon chain deposit contract. Only called via <code>EigenPodManager.stake</code>.</p> <p>Effects: * Deposits 32 ETH into the beacon chain deposit contract, and provides the pod's address as the deposit's withdrawal credentials</p> <p>Requirements: * Caller MUST be the <code>EigenPodManager</code> * Call value MUST be 32 ETH * Deposit contract <code>deposit</code> method MUST succeed given the provided <code>pubkey</code>, <code>signature</code>, and <code>depositDataRoot</code></p>"},{"location":"docs/core/EigenPod/#withdrawrestakedbeaconchaineth","title":"<code>withdrawRestakedBeaconChainETH</code>","text":"<pre><code>function withdrawRestakedBeaconChainETH(\n    address recipient, \n    uint256 amountWei\n)\n    external \n    onlyEigenPodManager\n</code></pre> <p>The <code>EigenPodManager</code> calls this method when withdrawing a Pod Owner's shares as tokens (native ETH). The input <code>amountWei</code> is converted to Gwei and subtracted from <code>withdrawableRestakedExecutionLayerGwei</code>, which tracks native ETH balance that has been accounted for in a checkpoint (see Checkpointing Validators).</p> <p>If the <code>EigenPod</code> does not have <code>amountWei</code> available to transfer, this method will revert</p> <p>Effects: * Decreases the pod's <code>withdrawableRestakedExecutionLayerGwei</code> by <code>amountWei / GWEI_TO_WEI</code> * Sends <code>amountWei</code> ETH to <code>recipient</code></p> <p>Requirements: * <code>amountWei / GWEI_TO_WEI</code> MUST NOT be greater than the proven <code>withdrawableRestakedExecutionLayerGwei</code> * Pod MUST have at least <code>amountWei</code> ETH balance * <code>recipient</code> MUST NOT revert when transferred <code>amountWei</code> * <code>amountWei</code> MUST be a whole Gwei amount</p>"},{"location":"docs/core/EigenPod/#recovertokens","title":"<code>recoverTokens</code>","text":"<pre><code>function recoverTokens(\n    IERC20[] memory tokenList,\n    uint256[] memory amountsToWithdraw,\n    address recipient\n) \n    external \n    onlyEigenPodOwner \n    onlyWhenNotPaused(PAUSED_NON_PROOF_WITHDRAWALS)\n</code></pre> <p>Allows the Pod Owner to rescue ERC20 tokens accidentally sent to the <code>EigenPod</code>.</p> <p>Effects: * Calls <code>transfer</code> on each of the ERC20's in <code>tokenList</code>, sending the corresponding <code>amountsToWithdraw</code> to the <code>recipient</code></p> <p>Requirements: * Caller MUST be the Pod Owner * Pause status MUST NOT be set: <code>PAUSED_NON_PROOF_WITHDRAWALS</code> * <code>tokenList</code> and <code>amountsToWithdraw</code> MUST have equal lengths</p>"},{"location":"docs/core/EigenPodManager/","title":"EigenPodManager","text":""},{"location":"docs/core/EigenPodManager/#eigenpodmanager","title":"EigenPodManager","text":"File Notes <code>EigenPodManager.sol</code> <code>EigenPodManagerStorage.sol</code> state variables <code>IEigenPodManager.sol</code> interface <p>Libraries and Mixins: | File | Notes | | -------- | -------- | | <code>EigenPodPausingConstants.sol</code> | pause values for <code>EigenPod/EigenPodManager</code> methods |</p>"},{"location":"docs/core/EigenPodManager/#prior-reading","title":"Prior Reading","text":"<ul> <li>Shares Accounting, especially Handling Beacon Chain Balance Decreases in EigenPods</li> </ul>"},{"location":"docs/core/EigenPodManager/#overview","title":"Overview","text":"<p>The <code>EigenPodManager</code> manages the \"beacon chain ETH strategy\", a virtual strategy that stakers can hold delegatable shares in, similar to the strategies managed by the <code>StrategyManager</code>. Whereas the <code>StrategyManager's</code> strategy shares are backed by deposited ERC20 tokens, beacon chain ETH strategy shares are backed either by beacon chain validators or native ETH attributed to <code>EigenPods</code>.</p> <p>The <code>EigenPodManager</code> allows any staker to deploy an <code>EigenPod</code>. <code>EigenPods</code> contains beacon chain state proof logic that enable a staker to point either/both a validator's withdrawal credentials and/or fee recipient addresses to their pod. After submitting beacon chain state proofs to their pod, the staker is awarded deposit shares in the beacon chain ETH strategy, which are then delegated to their operator in the <code>DelegationManager</code> (if applicable). For more details, see <code>EigenPod.md</code>.</p> <p>As an <code>EigenPod</code> receives balance updates, they are forwarded to the <code>EigenPodManager</code>. Balance increases resulting from validator activity on the beacon chain or ETH received in the <code>EigenPod</code> will result in an increase in the staker's deposit shares for the beacon chain ETH strategy.</p> <p>Balance decreases resulting from validator inactivity or beacon chain slashing do NOT decrease the staker's deposit shares. Instead, they result in a decrease to the staker's beacon chain slashing factor. Among other factors, the <code>DelegationManager</code> uses the beacon chain slashing factor when determining: * How many of a staker's deposit shares can actually be withdrawn * How many of a staker's deposit shares can be delegated to an operator</p> <p>Note that the number of withdrawable shares a staker's deposit shares represent can be queried using <code>DelegationManager.getWithdrawableShares(staker, strategies)</code>.</p> <p>The <code>EigenPodManager's</code> responsibilities can be broken down into the following concepts: * Depositing Into EigenLayer * Withdrawal Processing * Other Methods</p>"},{"location":"docs/core/EigenPodManager/#parameterization","title":"Parameterization","text":"<ul> <li><code>beaconChainETHStrategy = 0xbeaC0eeEeeeeEEeEeEEEEeeEEeEeeeEeeEEBEaC0</code><ul> <li>A virtual strategy used to represent beacon chain ETH internally. The <code>DelegationManager</code> uses this address to denote the beacon chain ETH strategy managed by the <code>EigenPodManager</code>. However, it does not correspond to an actual contract!</li> </ul> </li> <li><code>ethPOS = 0x00000000219ab540356cBB839Cbe05303d7705Fa</code><ul> <li>The address of the beacon chain deposit contract</li> </ul> </li> <li><code>beaconProxyBytecode</code> (defined in <code>EigenPodManagerStorage.sol</code>)<ul> <li><code>EigenPods</code> are deployed using a beacon proxy. This bytecode is a constant, containing the creation bytecode calculated by compiling OpenZeppelin's <code>BeaconProxy</code> contract at version 4.7.1. Compilation used solc version <code>0.8.12</code>, optimization enabled, 200 runs. Example verified contract here.</li> </ul> </li> </ul>"},{"location":"docs/core/EigenPodManager/#depositing-into-eigenlayer","title":"Depositing Into EigenLayer","text":"<p>Before a staker begins restaking beacon chain ETH, they need to deploy an <code>EigenPod</code>, stake, and start a beacon chain validator: * <code>createPod</code> * <code>stake</code></p>"},{"location":"docs/core/EigenPodManager/#createpod","title":"<code>createPod</code>","text":"<pre><code>/**\n * @notice Creates an EigenPod for the sender.\n * @dev Function will revert if the `msg.sender` already has an EigenPod.\n * @dev Returns EigenPod address\n */\nfunction createPod()\n    external\n    onlyWhenNotPaused(PAUSED_NEW_EIGENPODS)\n    returns (address)\n</code></pre> <p>Allows a staker to deploy an <code>EigenPod</code> instance, if they have not done so already.</p> <p>Each staker can only deploy a single <code>EigenPod</code> instance, but a single <code>EigenPod</code> can serve as the fee recipient / withdrawal credentials for any number of beacon chain validators. Each <code>EigenPod</code> is created using Create2 and the beacon proxy pattern, using the staker's address as the Create2 salt.</p> <p>As part of the <code>EigenPod</code> deployment process, the staker is made the Pod Owner, a permissioned role within the <code>EigenPod</code>.</p> <p>Effects: * Create2 deploys <code>EigenPodManager.beaconProxyBytecode</code>, appending the <code>eigenPodBeacon</code> address as a constructor argument. <code>bytes32(msg.sender)</code> is used as the salt.     * <code>address eigenPodBeacon</code> is an OpenZeppelin v4.7.1 <code>UpgradableBeacon</code>, whose implementation address points to the current <code>EigenPod</code> implementation     * <code>beaconProxyBytecode</code> is the constructor code for an OpenZeppelin v4.7.1 <code>BeaconProxy</code> * <code>EigenPod.initialize(msg.sender)</code>: initializes the pod, setting the caller as the Pod Owner and activating restaking for any validators pointed at the pod. * Maps the new pod to the Pod Owner (each address can only deploy a single <code>EigenPod</code>)</p> <p>Requirements: * Caller MUST NOT have deployed an <code>EigenPod</code> already * Pause status MUST NOT be set: <code>PAUSED_NEW_EIGENPODS</code></p>"},{"location":"docs/core/EigenPodManager/#stake","title":"<code>stake</code>","text":"<pre><code>/**\n * @notice Stakes for a new beacon chain validator on the sender's EigenPod.\n * Also creates an EigenPod for the sender if they don't have one already.\n * @param pubkey The 48 bytes public key of the beacon chain validator.\n * @param signature The validator's signature of the deposit data.\n * @param depositDataRoot The root/hash of the deposit data for the validator's deposit.\n */\nfunction stake(\n    bytes calldata pubkey,\n    bytes calldata signature,\n    bytes32 depositDataRoot\n)\n    external\n    payable\n    onlyWhenNotPaused(PAUSED_NEW_EIGENPODS)\n</code></pre> <p>Allows a staker to deposit 32 ETH into the beacon chain deposit contract, providing the credentials for the staker's beacon chain validator. The <code>EigenPod.stake</code> method is called, which automatically calculates the correct withdrawal credentials for the pod and passes these to the deposit contract along with the 32 ETH.</p> <p>Effects: * Deploys and initializes an <code>EigenPod</code> on behalf of staker, if this has not been done already * See <code>EigenPod.stake</code></p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_NEW_EIGENPODS</code> * See <code>EigenPod.stake</code></p>"},{"location":"docs/core/EigenPodManager/#withdrawal-processing","title":"Withdrawal Processing","text":"<p>These methods are callable ONLY by the DelegationManager, and are used when processing undelegations and withdrawals.</p> <p>Concepts: * Shares Accounting - Handling Beacon Chain Balance Decreases * Deposit Shares and Beacon Chain Slashing</p> <p>Methods: * <code>removeDepositShares</code> * <code>addShares</code> * <code>withdrawSharesAsTokens</code></p>"},{"location":"docs/core/EigenPodManager/#deposit-shares-and-beacon-chain-slashing","title":"Deposit Shares and Beacon Chain Slashing","text":"<p>The <code>EigenPodManager</code> tracks a staker's deposit shares and beacon chain slashing factor using the following state variables:</p> <pre><code>/**\n * @notice mapping from pod owner to the deposit shares they have in the virtual beacon chain ETH strategy\n * \n * @dev When an EigenPod registers a balance increase, deposit shares are increased. When registering a balance\n * decrease, however, deposit shares are NOT decreased. Instead, the pod owner's beacon chain slashing factor\n * is decreased proportional to the balance decrease. This impacts the number of shares that will be withdrawn\n * when the deposit shares are queued for withdrawal in the DelegationManager.\n * \n * Note that prior to the slashing release, deposit shares were decreased when balance decreases occurred.\n * In certain cases, a combination of queueing a withdrawal plus registering a balance decrease could result\n * in a staker having negative deposit shares in this mapping. This negative value would be corrected when the\n * staker completes a withdrawal (as tokens or as shares).\n *\n * With the slashing release, negative shares are no longer possible. However, a staker can still have negative\n * shares if they met the conditions for them before the slashing release. If this is the case, that staker\n * should complete any outstanding queued withdrawal in the DelegationManager (\"as shares\"). This will correct\n * the negative share count and allow the staker to continue using their pod as normal.\n */\nmapping(address podOwner =&gt; int256 shares) public podOwnerDepositShares;\n\n/**\n * @notice The amount of beacon chain slashing experienced by a pod owner as a proportion of WAD\n * @param isSet whether the slashingFactor has ever been updated. Used to distinguish between\n * a value of \"0\" and an uninitialized value.\n * @param slashingFactor the proportion of the pod owner's balance that has been decreased due to\n * slashing or other beacon chain balance decreases.\n * @dev NOTE: if !isSet, `slashingFactor` should be treated as WAD. `slashingFactor` is monotonically\n * decreasing and can hit 0 if fully slashed.\n */\nstruct BeaconChainSlashingFactor {\n    bool isSet;\n    uint64 slashingFactor;\n}\n\n/// @notice Returns the slashing factor applied to the `staker` for the `beaconChainETHStrategy`\n/// Note: this value starts at 1 WAD (1e18) for all stakers, and is updated when a staker's pod registers\n/// a balance decrease.\nmapping(address staker =&gt; BeaconChainSlashingFactor) internal _beaconChainSlashingFactor;\n</code></pre>"},{"location":"docs/core/EigenPodManager/#removedepositshares","title":"<code>removeDepositShares</code>","text":"<pre><code>/**\n * @notice Used by the DelegationManager to remove a pod owner's deposit shares when they enter the withdrawal queue.\n * Simply decreases the `podOwner`'s shares by `shares`, down to a minimum of zero.\n * @dev This function reverts if it would result in `podOwnerDepositShares[podOwner]` being less than zero, i.e. it is forbidden for this function to\n * result in the `podOwner` incurring a \"share deficit\". This behavior prevents a Staker from queuing a withdrawal which improperly removes excessive\n * shares from the operator to whom the staker is delegated.\n * @dev The delegation manager validates that the podOwner is not address(0)\n */\nfunction removeDepositShares(\n    address podOwner,\n    IStrategy strategy,\n    uint256 depositSharesToRemove\n)\n    external\n    onlyDelegationManager\n</code></pre> <p>The <code>DelegationManager</code> calls this method when a staker queues a withdrawal (or undelegates, which also queues a withdrawal). The shares are removed while the withdrawal is in the queue, and when the queue completes, the shares will either be re-awarded or withdrawn as tokens (<code>addShares</code> and <code>withdrawSharesAsTokens</code>, respectively).</p> <p>The staker's share balance is decreased by <code>depositSharesToRemove</code>.</p> <p>This method is not allowed to cause the <code>staker's</code> balance to go negative. This prevents a staker from queueing a withdrawal for more shares than they have (or more shares than they delegated to an operator).</p> <p>Note that the amount of deposit shares removed while in the withdrawal queue may not equal the amount credited when the withdrawal is completed. The staker may receive fewer if slashing occurred; see <code>DelegationManager.md</code> for details.</p> <p>Effects: * Removes <code>depositSharesToRemove</code> from <code>podOwner</code> share balance in <code>podOwnerDepositShares</code> * Emits a <code>NewTotalShares</code> event</p> <p>Requirements: * Caller MUST be the <code>DelegationManager</code> * <code>strategy</code> MUST be <code>beaconChainETHStrategy</code> * <code>staker</code> MUST NOT be zero * <code>depositSharesToRemove</code> MUST be less than <code>staker</code> share balance in <code>podOwnerDepositShares</code></p>"},{"location":"docs/core/EigenPodManager/#addshares","title":"<code>addShares</code>","text":"<pre><code>/**\n * @notice Increases the `podOwner`'s shares by `shares`, paying off negative shares if needed.\n * Used by the DelegationManager to award a pod owner shares on exiting the withdrawal queue\n * @return existingDepositShares the pod owner's shares prior to any additions. Returns 0 if negative\n * @return addedShares the number of shares added to the staker's balance above 0. This means that if,\n * after shares are added, the staker's balance is non-positive, this will return 0.\n */\nfunction addShares(\n    address staker,\n    IStrategy strategy,\n    uint256 shares\n)\n    external\n    onlyDelegationManager\n    returns (uint256, uint256)\n</code></pre> <p>The <code>DelegationManager</code> calls this method when a queued withdrawal is completed and the withdrawer specifies that they want to receive the withdrawal \"as shares\" (rather than as the underlying tokens). A staker might want to do this in order to change their delegated operator without needing to fully exit their validators.</p> <p>This method credits the input deposit shares to the staker. In most cases, the input <code>shares</code> equal the same shares originally removed when the withdrawal was queued. However, if the staker's operator was slashed (or the staker experienced beacon chain slashing), they may receive less. See <code>DelegationManager.md</code> for details.</p> <p>If the staker has a share deficit (negative shares), the deficit is repaid out of the added <code>shares</code>. If the Pod Owner's positive share count increases, this change is returned to the <code>DelegationManager</code> to be delegated to the staker's operator (if they have one).</p> <p>Effects: * Increases <code>staker</code>'s deposit share balance in <code>podOwnerDepositShares</code> by <code>shares</code></p> <p>Requirements: * Caller MUST be the <code>DelegationManager</code> * <code>strategy</code> MUST be <code>beaconChainETHStrategy</code> * <code>staker</code> MUST NOT be <code>address(0)</code> * <code>shares</code> MUST NOT be negative when converted to an <code>int256</code> * Emits <code>PodSharesUpdated</code> and <code>NewTotalShares</code> events</p>"},{"location":"docs/core/EigenPodManager/#withdrawsharesastokens","title":"<code>withdrawSharesAsTokens</code>","text":"<pre><code>/**\n * @notice Used by the DelegationManager to complete a withdrawal, sending tokens to the pod owner\n * @dev Prioritizes decreasing the podOwner's share deficit, if they have one\n * @dev This function assumes that `removeShares` has already been called by the delegationManager, hence why\n *      we do not need to update the podOwnerDepositShares if `currentpodOwnerDepositShares` is positive\n */\nfunction withdrawSharesAsTokens(\n    address podOwner,\n    IStrategy strategy,\n    IERC20,\n    uint256 shares\n)\n    external\n    onlyDelegationManager\n</code></pre> <p>The <code>DelegationManager</code> calls this method when a queued withdrawal is completed and the withdrawer specifies that they want to receive the withdrawal as the tokens underlying the shares. This can be used to \"fully exit\" some amount of native ETH and send it to the pod owner (via <code>EigenPod.withdrawRestakedBeaconChainETH</code>).</p> <p>Note that because this method entails withdrawing and sending native ETH, two conditions must be met for this method to succeed: (i) the ETH being withdrawn should already be in the <code>EigenPod</code>, and (ii) the amount being withdrawn should be accounted for in <code>EigenPod.withdrawableExecutionLayerGwei</code>. This latter condition can be achieved by completing an <code>EigenPod</code> checkpoint just prior to completing a queued <code>DelegationManager</code> withdrawal (see EigenPod: Checkpointing Validators for details).</p> <p>Also note that, like <code>addShares</code>, if the original Pod Owner has a share deficit (negative shares), the deficit is repaid out of the withdrawn <code>shares</code> before any native ETH is withdrawn.</p> <p>Effects: * If <code>staker</code>'s share balance in <code>podOwnerDepositShares</code> is negative (i.e. the staker has a deficit):     * If <code>shares</code> is greater than the current deficit:         * Sets <code>staker</code> balance in <code>podOwnerDepositShares</code> to 0         * Subtracts <code>|deficit|</code> from <code>shares</code> and converts remaining shares 1:1 to ETH (see <code>EigenPod.withdrawRestakedBeaconChainETH</code>)     * If <code>shares</code> is less than or equal to the current deficit:         * Increases <code>staker</code> negative balance in <code>podOwnerDepositShares</code> by <code>shares</code>, bringing it closer to 0         * Does not withdraw any shares * Emits <code>PodSharesUpdated</code> and <code>NewTotalShares</code> events</p> <p>Requirements: * Caller MUST be the <code>DelegationManager</code> * <code>strategy</code> MUST be <code>beaconChainETHStrategy</code> * <code>staker</code> MUST NOT be <code>address(0)</code> * <code>shares</code> MUST NOT be negative when converted to an <code>int256</code> * See <code>EigenPod.withdrawRestakedBeaconChainETH</code></p>"},{"location":"docs/core/EigenPodManager/#other-methods","title":"Other Methods","text":"<p>Methods: * <code>recordBeaconChainETHBalanceUpdate</code> * <code>increaseBurnableShares</code></p>"},{"location":"docs/core/EigenPodManager/#recordbeaconchainethbalanceupdate","title":"<code>recordBeaconChainETHBalanceUpdate</code>","text":"<pre><code>/**\n * @notice Adds any positive share delta to the pod owner's deposit shares, and delegates them to the pod\n * owner's operator (if applicable). A negative share delta does NOT impact the pod owner's deposit shares,\n * but will reduce their beacon chain slashing factor and delegated shares accordingly.\n * @param podOwner is the pod owner whose balance is being updated.\n * @param prevRestakedBalanceWei is the total amount restaked through the pod before the balance update, including\n * any amount currently in the withdrawal queue.\n * @param balanceDeltaWei is the amount the balance changed\n * @dev Callable only by the podOwner's EigenPod contract.\n * @dev Reverts if `sharesDelta` is not a whole Gwei amount\n */\nfunction recordBeaconChainETHBalanceUpdate(\n    address podOwner,\n    uint256 prevRestakedBalanceWei,\n    int256 balanceDeltaWei\n)\n    external\n    onlyEigenPod(podOwner)\n    nonReentrant\n</code></pre> <p>This method is called by an <code>EigenPod</code> to report a change in its pod owner's shares. It accepts a positive or negative <code>balanceDeltaWei</code>. A positive delta is added to the pod owner's deposit shares, and delegated to their operator if applicable. A negative delta is NOT removed from the pod owner's deposit shares. Instead, the proportion of the balance decrease is used to update the pod owner's beacon chain slashing factor and decrease the number of shares delegated to their operator (if applicable). A zero delta results in no change. </p> <p>Note that prior to the slashing release, negative balance deltas subtracted from the pod owner's shares, and could, in certain cases, result in a negative share balance. As of the slashing release, negative balance deltas no longer subtract from share balances, updating the beacon chain slashing factor instead. </p> <p>If a staker has negative shares as of the slashing release, this method will REVERT, preventing any further balance updates from their pod while the negative share balance persists. In order to fix this and restore the use of their pod, the staker should complete any outstanding withdrawals in the <code>DelegationManager</code> \"as shares,\" which will correct the share deficit.</p> <p>Effects: * If <code>balanceDeltaWei</code> is zero, do nothing * If <code>balanceDeltaWei</code> is positive:   * Adds <code>shares</code> to <code>podOwnerDepositShares</code> for <code>podOwner</code>   * Emits <code>PodSharesUpdated</code> and <code>NewTotalShares</code> events   * Calls <code>DelegationManager.increaseDelegatedShares</code> * If <code>balanceDeltaWei</code> is negative:   * Reduces slashing factor proportional to relative balance decrease   * Emits <code>BeaconChainSlashingFactorDecreased</code> event   * Calls <code>DelegationManager.decreaseDelegatedShares</code></p> <p>Requirements: * Caller MUST be the <code>EigenPod</code> associated with the passed-in <code>podOwner</code> * <code>podOwner</code> MUST NOT be <code>address(0)</code> * <code>balanceDeltaWei</code> MUST be a whole Gwei amount * Legacy withdrawals MUST be complete (i.e. <code>currentDepositShares &gt;= 0</code>)</p>"},{"location":"docs/core/EigenPodManager/#increaseburnableshares","title":"<code>increaseBurnableShares</code>","text":"<pre><code>/**\n * @notice Increase the amount of burnable shares for a given Strategy. This is called by the DelegationManager\n * when an operator is slashed in EigenLayer.\n * @param strategy The strategy to burn shares in.\n * @param addedSharesToBurn The amount of added shares to burn.\n * @dev This function is only called by the DelegationManager when an operator is slashed.\n */\nfunction increaseBurnableShares(\n    IStrategy strategy, \n    uint256 addedSharesToBurn\n)\n    external\n    onlyDelegationManager\n</code></pre> <p>The <code>DelegationManager</code> calls this method when an operator is slashed, calculating the number of slashable shares and marking them for burning here.</p> <p>Unlike in the <code>StrategyManager</code>, there is no current mechanism to burn these shares, as burning requires the Pectra hard fork to be able to eject validators. This will be added in a future update.</p> <p>Effects: * Increases <code>burnableShares</code> for the beacon chain ETH strategy by <code>addedSharesToBurn</code></p> <p>Requirements: * Can only be called by the <code>DelegationManager</code></p>"},{"location":"docs/core/RewardsCoordinator/","title":"RewardsCoordinator","text":""},{"location":"docs/core/RewardsCoordinator/#rewardscoordinator","title":"RewardsCoordinator","text":"File Type Proxy <code>RewardsCoordinator.sol</code> Singleton Transparent proxy <p>The <code>RewardsCoordinator</code> accepts ERC20s from AVSs alongside rewards submission requests made out to Operators who, during a specified time range, were registered to the AVS in the core <code>AllocationManager</code> contract.</p> <p>There are two forms of rewards: * Rewards v1, also known as rewards submissions. * Rewards v2, also known as operator-directed rewards submissions. See the ELIP for additional context on this rewards type.</p> <p>Off-chain, the trusted rewards updater calculates a rewards distribution over some rewards submission's time range, depending on the rewards type. For a v1 rewards submission, it is based on: (i) the relative stake weight of each Operator's Stakers and (ii) a default split given to the Operator. For a v2 rewards submission, it is based on: (i) an AVS's custom rewards logic, (ii) the per-operator splits.</p> <p>On-chain, the rewards updater sends the <code>RewardsCoordinator</code> a merkle root of each earner's cumulative earnings. Earners provide merkle proofs to the <code>RewardsCoordinator</code> to claim rewards against these roots.</p> <p>The typical user flow is as follows: 1. An AVS submits a rewards submission, either a <code>RewardsSubmission</code> (v1) or <code>OperatorDirectedRewardsSubmission</code> (v2), to the <code>RewardsCoordinator</code> contract, which specifies a time range (<code>startTimestamp</code> and <code>duration</code>) and <code>token</code>. The rewards submission also specifies the relative reward weights of strategies (i.e. \"distribute 80% out to holders of X strategy, and 20% to holders of strategy Y\").    * Note that v1 rewards specify a total <code>amount</code>, whereas v2 rewards specify a per-operator reward (due to customizable rewards logic). v2 rewards also allow for adding a <code>description</code> of the rewards submission's purpose. 2. Off-chain, the rewards submissions are used to calculate reward distributions, which are periodically consolidated into a merkle tree. 3. The root of this tree (aka the <code>DistributionRoot</code>) is posted on-chain by the rewards updater. A <code>DistributionRoot</code> becomes active for claims after some globally-configured <code>activationDelay</code>. 4. Stakers and Operators (or their configured \"claimers\") can claim their accumulated earnings by providing a merkle proof against any previously-posted <code>DistributionRoot</code>.</p> <p>This entire flow will repeat periodically as AVSs submit rewards submissions, <code>DistributionRoots</code> are submitted, and Stakers/Operators claim their accumulated earnings. Note that <code>DistributionRoots</code> contain cumulative earnings, meaning Stakers/Operators aren't required to claim against every root - simply claiming against the most recent root will claim anything not yet claimed.</p>"},{"location":"docs/core/RewardsCoordinator/#high-level-concepts","title":"High-level Concepts","text":"<p>This document is organized according to the following themes (click each to be taken to the relevant section): * Submitting Rewards Requests * Distributing and Claiming Rewards * System Configuration * Rewards Merkle Tree Structure * Off Chain Calculation</p>"},{"location":"docs/core/RewardsCoordinator/#important-state-variables","title":"Important state variables","text":"<ul> <li><code>DistributionRoot[] public distributionRoots</code>:<ul> <li><code>distributionRoots</code> stores historic reward merkle tree roots submitted by the rewards updater. For each earner, the rewards merkle tree stores cumulative earnings per ERC20 reward token. For more details on merkle tree structure see Rewards Merkle Tree Structure below.</li> </ul> </li> <li><code>mapping(address =&gt; address) public claimerFor</code>: earner =&gt; claimer<ul> <li>Stakers and Operators can designate a \"claimer\" who can claim rewards via on their behalf via <code>processClaim</code>. If a claimer is not set in <code>claimerFor</code>, the earner will have to call <code>processClaim</code> themselves.</li> <li>Note that the claimer isn't necessarily the reward recipient, but they do have the authority to specify the recipient when calling <code>processClaim</code> on the earner's behalf.</li> </ul> </li> <li><code>mapping(address =&gt; mapping(IERC20 =&gt; uint256)) public cumulativeClaimed</code>: earner =&gt; token =&gt; total amount claimed to date<ul> <li>Mapping for earners(Stakers/Operators) to track their total claimed earnings per reward token. This mapping is used to calculate the difference between the cumulativeEarnings stored in the merkle tree and the previous total claimed amount. This difference is then transferred to the specified destination address.</li> </ul> </li> <li><code>uint16 public defaultOperatorSplitBips</code>: Used off-chain by the rewards updater to calculate an Operator's split for a specific reward.<ul> <li>This is expected to be a flat 10% rate for the initial rewards release. Expressed in basis points, this is <code>1000</code>.</li> </ul> </li> <li><code>mapping(address =&gt; mapping(address =&gt; OperatorSplit)) internal _operatorAVSSplitBips</code>: operator =&gt; AVS =&gt; <code>OperatorSplit</code></li> <li>Operators specify their custom split for a given AVS for each <code>OperatorDirectedRewardsSubmission</code>, where Stakers receive a relative proportion (by stake weight) of the remaining amount.</li> <li><code>mapping(address =&gt; OperatorSplit) internal _operatorPISplitBips</code>: operator =&gt; <code>OperatorSplit</code></li> <li>Operators may also specify their custom split for programmatic incentives, where Stakers similarly receive a relative proportion (by stake weight) of the remaining amount.</li> <li><code>mapping(address operator =&gt; mapping(bytes32 operatorSetKey =&gt; OperatorSplit split)) internal _operatorSetSplitBips</code>: operator =&gt; Operator Set Key =&gt; <code>OperatorSplit</code></li> <li>Operators may specify their custom split for a given Operator Set, which is more granular than an overarching AVS split</li> </ul>"},{"location":"docs/core/RewardsCoordinator/#helpful-definitions","title":"Helpful definitions","text":"<ul> <li>AVS (Autonomous Verifiable Service) refers to the contract entity that is submitting rewards to the <code>RewardsCoordinator</code>.</li> <li>This is assumed to be a customized <code>ServiceManager</code> contract of some kind that is interfacing with the EigenLayer protocol. See the <code>ServiceManagerBase</code> docs here: <code>eigenlayer-middleware/docs/ServiceManagerBase.md</code>.</li> <li>An Operator Set refers to a collection of registered operators and strategies. See ELIP-002 for more details.</li> <li>An Operator Set Key describes the tuple of an AVS address and an ID that uniquely identifies an Operator Set. See the AllocationManager for details.</li> <li>A rewards submission includes, unless specified otherwise, both the v1 <code>RewardsSubmission</code> and the v2 <code>OperatorDirectedRewardsSubmission</code> types.</li> <li>The internal function <code>_checkClaim(RewardsMerkleClaim calldata claim, DistributionRoot memory root)</code> checks the merkle inclusion of a claim against a <code>DistributionRoot</code><ul> <li>It reverts if any of the following are true:<ul> <li>mismatch input param lengths: tokenIndices, tokenTreeProofs, tokenLeaves</li> <li>earner proof reverting from calling <code>_verifyEarnerClaimProof</code></li> <li>any of the token proofs reverting from calling <code>_verifyTokenClaimProof</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"docs/core/RewardsCoordinator/#submitting-rewards-requests","title":"Submitting Rewards Requests","text":"<p>Rewards are initially submitted to the contract to be distributed to Operators and Stakers by the following functions:</p> <ul> <li><code>RewardsCoordinator.createAVSRewardsSubmission</code></li> <li><code>RewardsCoordinator.createRewardsForAllSubmission</code></li> <li><code>RewardsCoordinator.createRewardsForAllEarners</code></li> <li><code>RewardsCoordinator.createOperatorDirectedAVSRewardsSubmission</code></li> <li><code>RewardsCoordinator.createOperatorDirectedOperatorSetRewardsSubmission</code></li> </ul>"},{"location":"docs/core/RewardsCoordinator/#createavsrewardssubmission","title":"<code>createAVSRewardsSubmission</code>","text":"<pre><code>function createAVSRewardsSubmission(\n    RewardsSubmission[] calldata RewardsSubmissions\n)\n    external\n    onlyWhenNotPaused(PAUSED_AVS_REWARDS_SUBMISSION)\n    nonReentrant\n</code></pre> <p>Called by an AVS to submit a list of <code>RewardsSubmission</code>s to be distributed across all registered Operators (and Stakers delegated to each Operator). A <code>RewardsSubmission</code> consists of the following fields: * <code>IERC20 token</code>: the address of the ERC20 token being used for reward submission * <code>uint256 amount</code>: amount of <code>token</code> to transfer to the <code>RewardsCoordinator</code> * <code>uint32 startTimestamp</code>: the start of the submission time range * <code>uint32 duration</code>: the duration of the submission time range, in seconds * <code>StrategyAndMultiplier[] strategiesAndMultipliers</code>: an array of <code>StrategyAndMultiplier</code> structs that define a linear combination of EigenLayer strategies the AVS is considering eligible for rewards. Each <code>StrategyAndMultiplier</code> contains:     * <code>IStrategy strategy</code>: address of the strategy against which a Staker/Operator's relative shares are weighted in order to determine their reward amount     * <code>uint96 multiplier</code>: the relative weighting of the strategy in the linear combination. (Recommended use here is to use 1e18 as the base multiplier and adjust the relative weightings accordingly)</p> <p>For each submitted <code>RewardsSubmission</code>, this method performs a <code>transferFrom</code> to transfer the specified reward <code>token</code> and <code>amount</code> from the caller to the <code>RewardsCoordinator</code>.</p> <p>Eligibility:</p> <p>In order to be eligible to claim a <code>createAVSRewardsSubmission</code> reward, the Operator should be registered for the AVS in the <code>AVSDirectory</code> during the time period over which the reward is being made (see docs for <code>AVSDirectory.registerOperatorToAVS</code>). If an Operator is ineligible, any Stakers delegated to the Operator are also ineligible.</p> <p>In addition, the AVS ServiceManager contract must also implement the interfaces <code>ServiceManager.getRestakeableStrategies</code> and <code>ServiceManager.getOperatorRestakedStrategies</code> to have their rewards be successfully distributed as these view functions are called offchain as part of the rewards distribution process. This is by default implemented in the <code>ServiceManagerBase</code> contract but is important to note if the base contract is not being inherited from. See the <code>ServiceManagerBase</code> abstract contract here: <code>ServiceManagerBase.sol</code></p> <p>Rewards Distribution:</p> <p>The rewards distribution amongst the AVS's Operators and delegated Stakers is determined offchain using the strategies and multipliers provided in the <code>RewardsSubmission</code> struct as well as the actual shares for those defined strategies over the <code>RewardsSubmission</code>'s time range. These shares are read from the <code>EigenPodManager</code> (in the case of the Beacon Chain ETH strategy), or the <code>StrategyManager</code> for any other strategy. Note that Stakers' shares specifically are what determines rewards distribution; Operators earn based on a combination of their own deposited shares and a configured <code>defaultOperatorSplitBips</code>.</p> <p>Effects: * For each <code>RewardsSubmission</code> element     * Transfers <code>amount</code> of <code>token</code> from the msg.sender (AVS) to the <code>RewardsCoordinator</code>     * Hashes msg.sender(AVS), nonce, and <code>RewardsSubmission</code> struct to create a unique rewards hash and sets this value to <code>true</code> in the <code>isAVSRewardsSubmissionHash</code> mapping     * Increments <code>submissionNonce[msg.sender]</code>     * Emits a <code>AVSRewardsSubmissionCreated</code> event</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_AVS_REWARDS_SUBMISSION</code> * Function call is not reentered * For each <code>RewardsSubmission</code> element     * Requirements from calling internal function <code>_validateRewardsSubmission()</code>         * <code>rewardsSubmission.strategiesAndMultipliers.length &gt; 0</code>         * <code>rewardsSubmission.amount &gt; 0</code>         * <code>rewardsSubmission.amount &lt;= MAX_REWARDS_AMOUNT</code>         * <code>rewardsSubmission.duration &lt;= MAX_REWARDS_DURATION</code>         * <code>rewardsSubmission.duration % calculationIntervalSeconds == 0</code>         * <code>rewardsSubmission.duration &gt; 0</code>         * <code>rewardsSubmission.startTimestamp % calculationIntervalSeconds == 0</code>         * <code>block.timestamp - MAX_RETROACTIVE_LENGTH &lt;= rewardsSubmission.startTimestamp</code>         * <code>GENESIS_REWARDS_TIMESTAMP &lt;= rewardsSubmission.startTimestamp</code>         * <code>rewardsSubmission.startTimestamp &lt;= block.timestamp + MAX_FUTURE_LENGTH</code>         * Requirements for <code>rewardsSubmission.strategiesAndMultipliers</code>             * Each <code>strategy</code> is whitelisted for deposit in the StrategyManager or is the <code>beaconChainETHStrategy</code>             * <code>rewardsSubmission.strategiesAndMultipliers</code> is sorted by ascending strategy address to prevent duplicate strategies     * <code>transferFrom</code> MUST succeed in transferring <code>amount</code> of <code>token</code> from <code>msg.sender</code> to the <code>RewardsCoordinator</code></p> <p>The text diagram below better visualizes a valid start timestamp for a <code>RewardsSubmission</code> <pre><code>Sliding Window for valid RewardsSubmission startTimestamp\n\nScenario A: GENESIS_REWARDS_TIMESTAMP IS WITHIN RANGE\n        &lt;-----MAX_RETROACTIVE_LENGTH-----&gt; t (block.timestamp) &lt;---MAX_FUTURE_LENGTH---&gt;\n            &lt;--------------------valid range for startTimestamp------------------------&gt;\n            ^\n        GENESIS_REWARDS_TIMESTAMP\n\n\nScenario B: GENESIS_REWARDS_TIMESTAMP IS OUT OF RANGE\n        &lt;-----MAX_RETROACTIVE_LENGTH-----&gt; t (block.timestamp) &lt;---MAX_FUTURE_LENGTH---&gt;\n        &lt;------------------------valid range for startTimestamp------------------------&gt;\n    ^\nGENESIS_REWARDS_TIMESTAMP\n</code></pre></p>"},{"location":"docs/core/RewardsCoordinator/#createrewardsforallsubmission","title":"<code>createRewardsForAllSubmission</code>","text":"<pre><code>function createRewardsForAllSubmission(\n    RewardsSubmission[] calldata RewardsSubmissions\n)\n    external\n    onlyWhenNotPaused(PAUSED_REWARDS_FOR_ALL_SUBMISSION)\n    onlyRewardsForAllSubmitter\n    nonReentrant\n</code></pre> <p>This method is identical in function to <code>createAVSRewardsSubmission</code> above, except: * It can only be called by a whitelisted \"rewards for all submitter\" * ALL Stakers are eligible for rewards, instead of those specifically registered for a given AVS</p> <p>Effects: * See <code>createAVSRewardsSubmission</code> above. The only differences are that:     * Each rewards submission hash is stored in the <code>isRewardsSubmissionForAllHash</code> mapping     * A <code>RewardsSubmissionForAllCreated</code> event is emitted</p> <p>Requirements: * See <code>createAVSRewardsSubmission</code> above. The only difference is that each calculated rewards submission hash MUST NOT already exist in the <code>isRewardsSubmissionForAllHash</code> mapping.</p>"},{"location":"docs/core/RewardsCoordinator/#createrewardsforallearners","title":"<code>createRewardsForAllEarners</code>","text":"<pre><code>function createRewardsForAllEarners(\n    RewardsSubmission[] calldata RewardsSubmissions\n)\n    external\n    onlyWhenNotPaused(PAUSED_REWARDS_FOR_ALL_SUBMISSION)\n    onlyRewardsForAllSubmitter\n    nonReentrant\n</code></pre> <p>This method is identical in function to <code>createAVSRewardsSubmission</code> above, except: * It can only be called by a whitelisted \"rewards for all submitter\" * Only operators who have opted into at least one AVS and the operator's delegated stakers are eligible for rewards</p> <p>Effects: * See <code>createAVSRewardsSubmission</code> above. The only differences are that:     * Each rewards submission hash is stored in the <code>isRewardsSubmissionForAllEarnersHash</code> mapping     * Emits a <code>RewardsSubmissionForAllEarnersCreated</code> event</p> <p>Requirements: * See <code>createAVSRewardsSubmission</code> above. The only difference is that each calculated rewards submission hash MUST NOT already exist in the <code>isRewardsSubmissionForAllEarnersHash</code> mapping.</p>"},{"location":"docs/core/RewardsCoordinator/#createoperatordirectedavsrewardssubmission","title":"<code>createOperatorDirectedAVSRewardsSubmission</code>","text":"<pre><code>function createOperatorDirectedAVSRewardsSubmission(\n    address avs,\n    OperatorDirectedRewardsSubmission[] calldata operatorDirectedRewardsSubmissions\n)\n    external\n    onlyWhenNotPaused(PAUSED_OPERATOR_DIRECTED_AVS_REWARDS_SUBMISSION)\n    checkCanCall(avs)\n    nonReentrant\n</code></pre> <p>AVS may make Rewards v2 submissions by calling <code>createOperatorDirectedAVSRewardsSubmission()</code> with any custom on-chain or off-chain logic to determine their rewards distribution strategy. This can be custom to the work performed by Operators during a certain period of time, can be a flat reward rate, or some other structure based on the AVS\u2019s economic model. This would enable AVSs' flexibility in rewarding different operators for performance and other variables while maintaining the same easily calculable reward rate for stakers delegating to the same operator and strategy. The AVS can submit multiple performance-based rewards denominated in different tokens for even more flexibility.</p> <p>Effects: * For each <code>OperatorDirectedRewardsSubmission</code> element   * Transfers <code>amount</code> of <code>token</code> from <code>msg.sender</code> to the <code>RewardsCoordinator</code>   * Hashes <code>AVS</code>, <code>nonce</code>, and <code>OperatorDirectedRewardsSubmission</code> struct to create a unique rewards hash and sets this value to <code>true</code> in the <code>isOperatorDirectedAVSRewardsSubmissionHash</code> mapping   * Increments <code>submissionNonce[avs]</code>   * Emits an <code>OperatorDirectedAVSRewardsSubmissionCreated</code> event</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_OPERATOR_DIRECTED_AVS_REWARDS_SUBMISSION</code> * Caller MUST be authorized, either as the AVS itself or an admin/appointee (see <code>PermissionController.md</code>) * Function call is not reentered * For each <code>OperatorDirectedRewardsSubmission</code> element:   * Requirements from calling internal function <code>_validateOperatorDirectedRewardsSubmission()</code>     * <code>operatorDirectedRewardsSubmission.strategiesAndMultipliers.length &gt; 0</code>     * <code>operatorDirectedRewardsSubmission.duration &lt;= MAX_REWARDS_DURATION</code>     * <code>operatorDirectedRewardsSubmission.duration % calculationIntervalSeconds == 0</code>     * <code>operatorDirectedRewardsSubmission.duration &gt; 0</code>     * <code>operatorDirectedRewardsSubmission.startTimestamp % calculationIntervalSeconds == 0</code>     * <code>block.timestamp - MAX_RETROACTIVE_LENGTH &lt;= operatorDirectedRewardsSubmission.startTimestamp</code>     * <code>GENESIS_REWARDS_TIMESTAMP &lt;= operatorDirectedRewardsSubmission.startTimestamp</code>     * For each <code>operatorDirectedRewardsSubmission.strategiesAndMultipliers</code> element:       * Each <code>strategy</code> is whitelisted for deposit in the StrategyManager or is the <code>beaconChainETHStrategy</code>       * <code>rewardsSubmission.strategiesAndMultipliers</code> is sorted by ascending strategy address to prevent duplicate strategies     * <code>operatorDirectedRewardsSubmission.operatorRewards.length &gt; 0</code>     * For each <code>operatorDirectedRewardsSubmission.operatorRewards</code> element:       * <code>operatorReward.operator != address(0)</code>       * <code>currOperatorAddress &lt; operatorReward.operator</code>       * <code>operatorReward.amount &gt; 0</code>     * <code>totalAmount &lt;= MAX_REWARDS_AMOUNT</code>, where <code>totalAmount</code> is the sum of every <code>operatorReward.amount</code>     * <code>operatorDirectedRewardsSubmission.startTimestamp + operatorDirectedRewardsSubmission.duration &lt; block.timestamp</code>, enforcing strictly retoractive rewards submissions   * <code>transferFrom</code> MUST succeed in transferring <code>amount</code> of <code>token</code> from <code>msg.sender</code> to the <code>RewardsCoordinator</code></p>"},{"location":"docs/core/RewardsCoordinator/#createoperatordirectedoperatorsetrewardssubmission","title":"<code>createOperatorDirectedOperatorSetRewardsSubmission</code>","text":"<pre><code>function createOperatorDirectedOperatorSetRewardsSubmission(\n    OperatorSet calldata operatorSet,\n    OperatorDirectedRewardsSubmission[] calldata operatorDirectedRewardsSubmissions\n)\n    external\n    onlyWhenNotPaused(PAUSED_OPERATOR_DIRECTED_OPERATOR_SET_REWARDS_SUBMISSION)\n    checkCanCall(operatorSet.avs)\n    nonReentrant\n</code></pre> <p>This function allows AVSs to make rewards submissions to specific operator sets, allowing for more granularly targeted rewards based on tasks assigned to a specific operator set, or any other custom AVS logic. Its functionality is almost identical to <code>createOperatorDirectedAVSRewardsSubmission</code>, save for some operator-set specific requirements, state variables, and events.</p> <p>Note that an AVS must specify an operator set registered to the AVS; in other words, an operator set belonging to a different AVS, or an unregistered operator set, will cause this function to revert.</p> <p>Also note that making this reward submission with a duration extending prior to the slashing release will result in those reward snapshots, prior to the slashing release, being refunded to the AVS (This is handled in the Sidecar rewards calculation logic).</p> <p>Effects: * See <code>createOperatorDirectedAVSRewardsSubmission</code> above. The only differences are that:   * Each rewards submission is stored in the <code>isOperatorDirectedOperatorSetRewardsSubmissionHash</code> mapping   * An <code>OperatorDirectedOperatorSetRewardsSubmissionCreated</code> event is emitted</p> <p>Requirements: * See <code>createOperatorDirectedAVSRewardsSubmission</code> above. The only differences are that:   * <code>operatorSet</code> MUST be a registered operator set for the given AVS as according to <code>allocationManager.isOperatorSet()</code>   * Pause status is instead: <code>PAUSED_OPERATOR_DIRECTED_OPERATOR_SET_REWARDS_SUBMISSION</code></p>"},{"location":"docs/core/RewardsCoordinator/#distributing-and-claiming-rewards","title":"Distributing and Claiming Rewards","text":"<p>The rewards updater calculates rewards distributions and submit claimable roots through the following function <code>submitRoot</code>. They can also disable the root if it has not yet been activated:</p> <ul> <li><code>RewardsCoordinator.submitRoot</code></li> <li><code>RewardsCoordinator.disableRoot</code></li> </ul> <p>Earners configure and claim these rewards using the following functions:</p> <ul> <li><code>RewardsCoordinator.setClaimerFor</code></li> <li><code>RewardsCoordinator.processClaim</code></li> <li><code>RewardsCoordinator.processClaims</code></li> </ul>"},{"location":"docs/core/RewardsCoordinator/#submitroot","title":"<code>submitRoot</code>","text":"<pre><code>function submitRoot(\n    bytes32 root,\n    uint32 rewardsCalculationEndTimestamp\n)\n    external\n    onlyWhenNotPaused(PAUSED_SUBMIT_DISABLE_ROOTS)\n    onlyRewardsUpdater\n</code></pre> <p>Called only by the <code>rewardsUpdater</code> address to create a new <code>DistributionRoot</code> in the RewardsCoordinator. The <code>DistributionRoot</code> struct contains the following fields: * <code>bytes32 root</code>: the merkle root of the rewards merkle tree * <code>uint32 rewardsCalculationEndTimestamp</code>: the end of the rewards time range for which the <code>DistributionRoot</code> is being submitted * <code>uint32 activatedAt</code>: the timestamp in seconds when the <code>DistributionRoot</code> is activated and can be claimed against</p> <p><code>submitRoot</code> pushes a new <code>DistributionRoot</code> to the <code>distributionRoots</code> array. The <code>DistributionRoot.activatedAt</code> timestamp is set to <code>block.timestamp + activationDelay()</code> to allow for a delay before claims can be processed. Once this delay has passed, the root can be used to verify merkle proofs of rewards made out to Stakers/Operators.</p> <p>Effects: * Pushes a new <code>DistributionRoot</code> to the <code>distributionRoots</code> array * Sets <code>currRewardsCalculationEndTimestamp</code> to the param <code>rewardsCalculationEndTimestamp</code> * Emits a <code>DistributionRootSubmitted</code> event</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_SUBMIT_DISABLE_ROOTS</code> * <code>msg.sender</code> MUST be the <code>rewardsUpdater</code> * <code>rewardsCalculationEndTimestamp &gt; currRewardsCalculationEndTimestamp</code> * <code>rewardsCalculationEndTimestamp &lt; block.timestamp</code></p>"},{"location":"docs/core/RewardsCoordinator/#disableroot","title":"<code>disableRoot</code>","text":"<pre><code>function disableRoot(\n    uint32 rootIndex\n)\n    external\n    onlyWhenNotPaused(PAUSED_SUBMIT_DISABLE_ROOTS)\n    onlyRewardsUpdater\n</code></pre> <p>Called only by the <code>rewardsUpdater</code> address to disable a pending <code>DistributionRoot</code> that has not yet been activated (activatedAt timestamp hasn't been reached yet) in the RewardsCoordinator. Once the activatedAt timestamp has been reached, a root can no longer be disabled and is deemed finalized and claimable against. This is to add additional measures to prevent invalid roots posted to the contract, either from error or potentially malicious roots posted.</p> <p>Effects: * Sets the <code>disabled</code> field to True for the corresponding <code>DistributionRoot</code> * <code>DistributionRoot</code> can no longer be claimed against in <code>processClaim</code> * Emits a <code>DistributionRootDisabled</code> event</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_SUBMIT_DISABLE_ROOTS</code> * <code>msg.sender</code> MUST be the <code>rewardsUpdater</code> * <code>rootIndex &lt; distributionRoots.length</code> * <code>root.disabled == False</code> * <code>block.timestamp &lt; root.activatedAt</code> * <code>rewardsCalculationEndTimestamp &lt; block.timestamp</code></p>"},{"location":"docs/core/RewardsCoordinator/#setclaimerfor","title":"<code>setClaimerFor</code>","text":"<pre><code>function setClaimerFor(address claimer) external\n</code></pre> <p>Called by an earner (Staker/Operator) to set a claimer address that can call <code>processClaim</code> on their behalf. If the claimer is not set (<code>claimerFor[earner] == address(0)</code>), the earner themselves can call <code>processClaim</code> directly.</p> <p>Effects: * Sets the <code>claimerFor[msg.sender]</code> to the input param <code>claimer</code> * Emits a <code>ClaimerForSet</code> event</p>"},{"location":"docs/core/RewardsCoordinator/#processclaim","title":"<code>processClaim</code>","text":"<pre><code>function processClaim(\n    RewardsMerkleClaim calldata claim,\n    address recipient\n)\n    external\n    onlyWhenNotPaused(PAUSED_PROCESS_CLAIM)\n    nonReentrant\n</code></pre> <p>Called an earner (Staker/Operator) to claim their accumulated earnings by providing a merkle proof against a posted <code>DistributionRoot</code>. If the earner has configured a claimer (via <code>setClaimerFor</code>), the claimer must call this method instead.</p> <p>The <code>RewardsMerkleClaim</code> struct contains the following fields (see Rewards Merkle Tree Structure for further details): * <code>uint32 rootIndex</code>: the index of the <code>DistributionRoot</code> in <code>distributionRoots</code> to prove against * <code>uint32 earnerIndex</code>: the index of the earner's account root in the merkle tree * <code>bytes earnerTreeProof</code>: the proof of the earner's <code>EarnerTreeMerkleLeaf</code> against the <code>DistributionRoot</code> * <code>EarnerTreeMerkleLeaf earnerLeaf</code>: the earner's address and token subtree root     * <code>address earner</code>: the address of the earner     * <code>bytes32 earnerTokenRoot</code>: the merkle root of the earner's token merkle tree * <code>uint32[] tokenIndices</code>: the indices of the token leaves in the earner's subtree * <code>bytes[] tokenTreeProofs</code>: the proofs of the token leaves against the earner's <code>earnerTokenRoot</code> * <code>TokenTreeMerkleLeaf[] tokenLeaves</code>: the token leaves to be claimed:     * <code>IERC20 token</code>: the ERC20 token to be claimed     * <code>uint256 amount</code>: the amount of the ERC20 token to be claimed</p> <p><code>processClaim</code> is a simple wrapper function which calls out to the internal function <code>_processClaim</code>, which holds all of the necessary logic.</p> <p><code>_processClaim</code> will first call <code>_checkClaim</code> to verify the merkle proofs against the <code>DistributionRoot</code> at the specified <code>rootIndex</code>. This is done by first performing a merkle proof verification of the earner's <code>EarnerTreeMerkleLeaf</code> against the <code>DistributionRoot</code> and then for each tokenIndex, verifying each token leaf against the earner's <code>earnerTokenRoot</code>.</p> <p>The caller must be the set claimer address in the <code>claimerFor</code> mapping or the earner themselves if the claimer is not set.</p> <p>After the claim is verified, for each token leaf, the difference between the cumulative earnings in the merkle tree and the previous total claimed amount last stored in the contract is calculated and transferred from the <code>RewardsCoordinator</code> contract to the address <code>recipient</code>.</p> <p>Effects: * For each <code>claim.tokenLeaves</code>:     * Calculates <code>uint claimAmount = tokenLeaf.cumulativeEarnings - cumulativeClaimed[earner][tokenLeaf.token]</code>         * Transfers <code>claimAmount</code> of <code>tokenLeaf.token</code> to the specified <code>recipient</code>     * Updates the <code>cumulativeClaimed</code> mapping for the earner and token     * Emits a <code>RewardsClaimed</code> event</p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_PROCESS_CLAIM</code> * The <code>claim</code> must have valid proofs against a valid <code>DistributionRoot</code>:     * For the <code>DistributionRoot</code> given by <code>claim.rootIndex</code>, the root MUST be active (<code>block.timestamp &gt;= root.activatedAt</code>)     * <code>claim.tokenIndices</code> MUST equal the lengths of <code>claim.TokenTreeProofs</code> AND <code>claim.tokenLeaves</code>     * <code>claim.earnerTreeProof</code> MUST validate <code>claim.earnerLeaf</code> against the <code>DistributionRoot</code>     * For each <code>claim.tokenIndices[i]</code>:         * <code>claim.tokenTreeProofs[i]</code> MUST validate <code>claim.tokenLeaves[i]</code> against <code>claim.earnerLeaf.earnerTokenRoot</code> * If the <code>earner</code> specified in <code>claim.earnerLeaf.earner</code> has a designated <code>claimer</code> in <code>claimerFor[earner]</code>, <code>msg.sender</code> MUST be the <code>claimer</code>     * Otherwise, <code>msg.sender</code> MUST be the <code>earner</code> * For each <code>TokenTreeMerkleLeaf</code>,     * <code>tokenLeaf.cumulativeEarnings &gt; cumulativeClaimed[earner][token]</code>: cumulativeEarnings must be gt than cumulativeClaimed. Trying to reclaim with the same proofs will revert because the claimed and earnings values will equal, breaking this requirement.     * <code>tokenLeaf.token.safeTransfer(recipient, claimAmount)</code> MUST succeed</p>"},{"location":"docs/core/RewardsCoordinator/#processclaims","title":"<code>processClaims</code>","text":"<pre><code>function processClaims(\n        RewardsMerkleClaim[] calldata claims,\n        address recipient\n)\n    external\n    onlyWhenNotPaused(PAUSED_PROCESS_CLAIM)\n    nonReentrant\n</code></pre> <p><code>processClaims</code> is a simple wrapper function around <code>_processClaim</code>, calling it once for each claim provided.</p> <p>Effects: * For each <code>RewardsMerkleClaim</code> element: see <code>processClaim</code> above.</p> <p>Requirements * See <code>processClaim</code> above.</p>"},{"location":"docs/core/RewardsCoordinator/#system-configuration","title":"System Configuration","text":"<ul> <li><code>RewardsCoordinator.setActivationDelay</code></li> <li><code>RewardsCoordinator.setDefaultOperatorSplit</code></li> <li><code>RewardsCoordinator.setRewardsUpdater</code></li> <li><code>RewardsCoordinator.setRewardsForAllSubmitter</code></li> <li><code>RewardsCoordinator.setOperatorAVSSplit</code></li> <li><code>RewardsCoordinator.setOperatorPISplit</code></li> <li><code>RewardsCoordinator.setOperatorSetSplit</code></li> </ul>"},{"location":"docs/core/RewardsCoordinator/#setactivationdelay","title":"<code>setActivationDelay</code>","text":"<pre><code>function setActivationDelay(uint32 _activationDelay) external onlyOwner\n</code></pre> <p>Allows the Owner to set the global <code>activationDelay</code>. The activation delay is the time in seconds after a <code>DistributionRoot</code> is submitted before it can be claimed against. This delay is to allow for interested parties to perform verification of the root before claiming begins.</p> <p>Effects: * Sets the global <code>activationDelay</code> * Emits a <code>ActivationDelaySet</code> event</p> <p>Requirements: * Caller MUST be the Owner</p>"},{"location":"docs/core/RewardsCoordinator/#setdefaultoperatorsplit","title":"<code>setDefaultOperatorSplit</code>","text":"<pre><code>function setDefaultOperatorSplit(uint16 split) external onlyOwner\n</code></pre> <p>Allows the Owner to set the default operator split in basis points.</p> <p>This split is used off-chain when calculating Operator earnings for a given rewards distribution. Operator split is calculated as a percentage of the reward amount made out to each Operator. This split is deducted from the reward amount, after which the remainder is used to calculate rewards made to any Stakers delegated to the Operator.</p> <p>Effects: * Sets the <code>defaultOperatorSplitBips</code> * Emits a <code>DefaultOperatorSplitBipsSet</code> event</p> <p>Requirements: * Caller MUST be the Owner</p>"},{"location":"docs/core/RewardsCoordinator/#setrewardsupdater","title":"<code>setRewardsUpdater</code>","text":"<pre><code>function setRewardsUpdater(address _rewardsUpdater) external onlyOwner\n</code></pre> <p>Allows the Owner to set the <code>rewardsUpdater</code> address. The <code>rewardsUpdater</code> is the singleton address that can submit new <code>DistributionRoots</code> to the <code>RewardsCoordinator</code>. The <code>rewardsUpdater</code> is a trusted entity that performs the bulk of the calculations and merkle tree structuring described in this document.</p> <p>Effects: * Sets the global <code>rewardsUpdater</code> address * Emits a <code>RewardsUpdaterSet</code> event</p> <p>Requirements: * Caller MUST be the Owner</p>"},{"location":"docs/core/RewardsCoordinator/#setrewardsforallsubmitter","title":"<code>setRewardsForAllSubmitter</code>","text":"<pre><code>function setRewardsForAllSubmitter(address _submitter, bool _newValue) external onlyOwner\n</code></pre> <p>Allows the Owner to update the <code>_submitter's</code> permissions in the <code>isRewardsForAllSubmitter</code> mapping. This mapping is used to determine if a given address is a valid submitter for the <code>createRewardsForAllSubmission</code> method.</p> <p>Effects: * Sets the <code>isRewardsForAllSubmitter</code> mapping for the address <code>_submitter</code> to the bool <code>_newValue</code> * Emits a <code>RewardsForAllSubmitterSet</code> event</p> <p>Requirements: * Caller MUST be the Owner</p>"},{"location":"docs/core/RewardsCoordinator/#setoperatoravssplit","title":"<code>setOperatorAVSsplit</code>","text":"<pre><code>function setOperatorAVSSplit(\n    address operator,\n    address avs,\n    uint16 split\n)\n    external\n    onlyWhenNotPaused(PAUSED_OPERATOR_AVS_SPLIT)\n    checkCanCall(operator)\n</code></pre> <p>An Operator may, for a given AVS, set a split which will determine what percent of their attributed rewards are allocated to themselves. The remaining percentage will go to Stakers.</p> <p>The split will take effect after an <code>activationDelay</code> set by the contract owner. Note that once an operator initiates a split update, the <code>activationDelay</code> must pass before a new split update can be initiated.</p> <p>Effects: * Updates <code>operatorSplit.activatedAt</code> to <code>block.timestamp + activationDelay</code> * If the operator has not initialized yet, sets  <code>operatorSplit.oldSplitBips</code> to <code>defaultOperatorSplitBips</code>. Else sets <code>operatorSplit.oldSplitBips</code> to the current <code>newSplitBips</code> * Updates <code>operatorSplit.newSplitBips</code> to <code>split</code> * Emits an <code>OperatorAVSSplitBipsSet</code> event</p> <p>Requirements: * Caller MUST be authorized, either as the operator itself or an admin/appointee (see <code>PermissionController.md</code>) * Split MUST BE &lt;= 10,000 bips (100%) * Current <code>block.timestamp</code> MUST BE greater than current <code>operatorSplit.activatedAt</code>.   * Any pending split must have already completed prior to setting a new split.</p>"},{"location":"docs/core/RewardsCoordinator/#setoperatorpisplit","title":"<code>setOperatorPIsplit</code>","text":"<pre><code>function setOperatorPISplit(\n    address operator,\n    uint16 split\n)\n    external\n    onlyWhenNotPaused(PAUSED_OPERATOR_PI_SPLIT)\n    checkCanCall(operator)\n</code></pre> <p>Similar to <code>setOperatorAVSSplit</code>, Operators may set their split for programmatic incentives, allowing them to specify what percent of these rewards they will maintain and what percent will go to their Stakers. The <code>allocationDelay</code> also applies here, as well as the inability to reinitiate a split update before the delay passes.</p> <p>Effects: * See <code>setOperatorAVSSplit</code> above. The only differences are that:   * The split is stored within <code>_operatorPISplitBips</code> instead of <code>_operatorAVSSplitBips</code>.   * An <code>OperatorPISplitBipsSet</code> event is emitted</p> <p>Requirements: * See <code>setOperatorAVSSplit</code> above. The only difference is that:   * Pause status is instead: <code>PAUSED_OPERATOR_PI_SPLIT</code></p>"},{"location":"docs/core/RewardsCoordinator/#setoperatorsetsplit","title":"<code>setOperatorSetSplit</code>","text":"<pre><code>function setOperatorSetSplit(\n    address operator,\n    OperatorSet calldata operatorSet,\n    uint16 split\n) \n    external \n    onlyWhenNotPaused(PAUSED_OPERATOR_SET_SPLIT) \n    checkCanCall(operator)\n</code></pre> <p>Effects: * See <code>setOperatorAVSSplit</code> above. The only difference is that:   * The split is stored within <code>_operatorSetSplitBips</code> instead of <code>_operatorAVSSplitBips</code>   * An <code>OperatorSetSplitBipsSet</code> event is emitted </p> <p>Requirements: * See <code>setOperatorAVSSplit</code> above. The only differences are that:   * <code>operatorSet</code> MUST be a registered operator set for the given AVS as according to <code>allocationManager.isOperatorSet()</code>   * Pause status is instead: <code>PAUSED_OPERATOR_SET_SPLIT</code></p>"},{"location":"docs/core/RewardsCoordinator/#rewards-merkle-tree-structure","title":"Rewards Merkle Tree Structure","text":"<p>This merkle tree is used to verify the claims against a <code>DistributionRoot</code>.</p> <p>When submitting a new <code>DistributionRoot</code>, the rewards updater consolidates all <code>RewardsSubmissions</code> submitted by AVSs since the previously submitted <code>DistributionRoot</code> into a merkle tree comprised of earners and their cumulative earnings for their respective reward tokens distributed.</p> <p>When an earner or their designated claimer calls <code>processClaim</code>, they must provide a <code>RewardsMerkleClaim</code> struct that contains the necessary information to verify their claim against the latest <code>DistributionRoot</code>. The merkle proof verification is done in the internal <code>_checkClaim</code> helper function. This function verifies the merkle proof of the earner's <code>EarnerTreeMerkleLeaf</code> against the <code>DistributionRoot</code> and then for each tokenIndex, verifies each token leaf against the earner's <code>earnerTokenRoot</code>.</p> <p>Claimers can selectively choose which token leaves to prove against and claim accumulated earnings. Each token reward claimed in a <code>processClaim</code> call will send tokens to the <code>recipient</code> address specified in the call.</p> <p>The rewards merkle tree is structured in the diagram below:</p> <p></p>"},{"location":"docs/core/RewardsCoordinator/#off-chain-calculation","title":"Off Chain Calculation","text":"<p>Rewards are calculated via an off-chain data pipeline. The pipeline takes snapshots of core contract state at the <code>SNAPSHOT_CADENCE</code>, currently set to once per day. It then combines these snapshots with any active rewards to calculate what the single daily reward of an earner is. Every <code>CALCULATION_INTERVAL_SECONDS</code> rewards are accumulated up to <code>lastRewardsTimestamp + CALCULATION_INTERVAL_SECONDS</code> and posted on-chain by the entity with the <code>rewardsUpdater</code> role.</p> <p><code>MAX_REWARDS_AMOUNT</code> is set to <code>1e38-1</code> given the precision bounds of the off-chain pipeline. An in-depth overview of the off-chain calculation can be found here</p>"},{"location":"docs/core/StrategyManager/","title":"StrategyManager","text":""},{"location":"docs/core/StrategyManager/#strategymanager","title":"StrategyManager","text":"File Notes <code>StrategyManager.sol</code> singleton share manager hooked into core <code>StrategyManagerStorage.sol</code> state variables <code>IStrategyManager.sol</code> interface <p>StrategyFactory:</p> File Notes <code>StrategyFactory.sol</code> allows deployment of <code>StrategyBase</code> for ERC20 tokens <code>StrategyBase.sol</code> deployed as a beacon proxy via <code>StrategyFactory</code> <p>Individual strategies:</p> File Notes <code>StrategyBaseTVLLimits.sol</code> Pre-StrategyFactory, deployed for certain LSTs. Each instances uses a transparent proxy pattern <code>EigenStrategy.sol</code> One-off strategy deployed to support EIGEN/bEIGEN"},{"location":"docs/core/StrategyManager/#overview","title":"Overview","text":"<p>The primary function of the <code>StrategyManager</code> is to handle deposit share accounting for individual stakers as they deposit and withdraw supported tokens from their corresponding strategies. Note that the <code>StrategyManager</code> only handles deposit shares. When the word shares is used in this document, it refers to deposit shares, specifically. For an explanation of other share types, see Shares Accounting - Terminology.</p> <p>The <code>StrategyManager</code> is responsible for (i) allowing stakers to deposit tokens into the corresponding strategy, (ii) allowing the <code>DelegationManager</code> to remove deposit shares when a staker queues a withdrawal, and (iii) allowing the <code>DelegationManager</code> to complete a withdrawal by either adding deposit shares back to the staker or withdrawing the deposit shares as tokens via the corresponding strategy.</p> <p>Any ERC20-compatible token can be supported by deploying a <code>StrategyBase</code> instance from the <code>StrategyFactory</code>. Under the hood, the <code>StrategyFactory</code> uses the beacon proxy pattern and only allows a strategy to be deployed once per token. Deployed strategies are automatically whitelists for deposit in the <code>StrategyManager</code>. For details, see Strategies below.</p> <p>Note: for the EIGEN/bEIGEN token specifically, the <code>EigenStrategy</code> contract is used instead of <code>StrategyBase</code>. Additionally, the EIGEN/bEIGEN token are blacklisted within the <code>StrategyFactory</code> to prevent duplicate strategies from being deployed for these tokens.</p> <p>Note: for certain LST tokens, the <code>StrategyBaseTVLLimits</code> contract is used instead of <code>StrategyBase</code>. These strategies were deployed before the <code>StrategyFactory</code> allowed arbitrary ERC20 strategies. Unlike strategies deployed through the <code>StrategyFactory</code>, these <code>StrategyBaseTVLLimits</code> contracts use the transparent proxy pattern. For all intents and purposes, these instances behave the same as <code>StrategyBase</code> instances deployed from the <code>StrategyFactory</code>. The \"TVL Limits\" capability of these instances has never been used. Any tokens using one of these instances are blacklisted in the <code>StrategyFactory</code> to prevent duplicate strategies from being deployed for these tokens.</p> <p>The <code>StrategyManager's</code> responsibilities can be broken down into the following concepts: * Depositing Into Strategies * Withdrawal Processing * Burning Slashed Shares * Strategies * System Configuration</p>"},{"location":"docs/core/StrategyManager/#parameterization","title":"Parameterization","text":"<ul> <li><code>MAX_TOTAL_SHARES = 1e38 - 1</code><ul> <li>The maximum total shares a single strategy can handle. This maximum prevents overflow in offchain services. Deposits that would increase a strategy's total shares beyond this value will revert.</li> </ul> </li> <li><code>MAX_STAKER_STRATEGY_LIST_LENGTH = 32</code><ul> <li>The maximum number of unique <code>StrategyManager</code> strategies a staker can have deposits in. Any deposits that cause this number to be exceeded will revert.</li> </ul> </li> <li><code>DEFAULT_BURN_ADDRESS = 0x00000000000000000000000000000000000E16E4</code><ul> <li>When slashed shares are burned, they are converted to tokens and transferred to this address, where they are unrecoverable.</li> </ul> </li> </ul>"},{"location":"docs/core/StrategyManager/#depositing-into-strategies","title":"Depositing Into Strategies","text":"<p>The following methods are called by stakers as they (i) deposit ERC20 tokens into strategies to receive deposit shares:</p> <ul> <li><code>StrategyManager.depositIntoStrategy</code></li> <li><code>StrategyManager.depositIntoStrategyWithSignature</code></li> </ul> <p>Withdrawals are performed through the <code>DelegationManager</code> (see <code>DelegationManager.md</code>).</p>"},{"location":"docs/core/StrategyManager/#depositintostrategy","title":"<code>depositIntoStrategy</code>","text":"<pre><code>/**\n * @notice Deposits `amount` of `token` into the specified `strategy` and credits shares to the caller\n * @param strategy the strategy that handles `token`\n * @param token the token from which the `amount` will be transferred\n * @param amount the number of tokens to deposit\n * @return depositShares the number of deposit shares credited to the caller\n * @dev The caller must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\n * \n * WARNING: Be extremely cautious when depositing tokens that do not strictly adhere to ERC20 standards.\n * Tokens that diverge significantly from ERC20 norms can cause unexpected behavior in token balances for\n * that strategy, e.g. ERC-777 tokens allowing cross-contract reentrancy.\n */\nfunction depositIntoStrategy(\n    IStrategy strategy,\n    IERC20 token,\n    uint256 amount\n)\n    external\n    onlyWhenNotPaused(PAUSED_DEPOSITS)\n    nonReentrant\n    returns (uint256 depositShares)\n</code></pre> <p>Allows a staker to deposit some <code>amount</code> of <code>token</code> into the specified <code>strategy</code> in exchange for deposit shares in that strategy. The underlying <code>strategy</code> must be whitelisted for deposits, meaning it has either been deployed via the <code>StrategyFactory</code>, or is an existing <code>StrategyBaseTVLLimits/EigenStrategy</code> instance. The <code>token</code> parameter should correspond to the strategy's supported token.</p> <p>The number of shares received is calculated by the <code>strategy</code> using an internal exchange rate that depends on the previous number of tokens deposited.</p> <p>After processing a deposit, the <code>StrategyManager</code> forwards the deposit information to the <code>DelegationManager</code>, which updates the staker's deposit scaling factor and delegates shares to the staker's operator (if applicable). See <code>DelegationManager.increaseDelegatedShares</code> for details.</p> <p>Effects: * <code>token.safeTransferFrom</code>: Transfers <code>amount</code> of <code>token</code> to <code>strategy</code> on behalf of the caller. * <code>StrategyManager</code> awards the staker with the newly-created deposit shares * See <code>StrategyBase.deposit</code> * See <code>DelegationManager.increaseDelegatedShares</code></p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_DEPOSITS</code> * Caller MUST allow at least <code>amount</code> of <code>token</code> to be transferred by <code>StrategyManager</code> to the strategy * <code>strategy</code> in question MUST be whitelisted for deposits. * See <code>StrategyBaseTVLLimits.deposit</code></p>"},{"location":"docs/core/StrategyManager/#depositintostrategywithsignature","title":"<code>depositIntoStrategyWithSignature</code>","text":"<pre><code>/**\n * @notice Deposits `amount` of `token` into the specified `strategy` and credits shares to the `staker`\n * Note tokens are transferred from `msg.sender`, NOT from `staker`. This method allows the caller, using a\n * signature, to deposit their tokens to another staker's balance.\n * @param strategy the strategy that handles `token`\n * @param token the token from which the `amount` will be transferred\n * @param amount the number of tokens to transfer from the caller to the strategy\n * @param staker the staker that the deposited assets will be credited to\n * @param expiry the timestamp at which the signature expires\n * @param signature a valid ECDSA or EIP-1271 signature from `staker`\n * @return depositShares the number of deposit shares credited to `staker`\n * @dev The caller must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\n *\n * WARNING: Be extremely cautious when depositing tokens that do not strictly adhere to ERC20 standards.\n * Tokens that diverge significantly from ERC20 norms can cause unexpected behavior in token balances for\n * that strategy, e.g. ERC-777 tokens allowing cross-contract reentrancy.\n */\nfunction depositIntoStrategyWithSignature(\n    IStrategy strategy,\n    IERC20 token,\n    uint256 amount,\n    address staker,\n    uint256 expiry,\n    bytes memory signature\n)\n    external\n    onlyWhenNotPaused(PAUSED_DEPOSITS)\n    nonReentrant\n    returns (uint256 depositShares)\n</code></pre> <p>This method works like <code>depositIntoStrategy()</code>, transferring tokens from the caller to the <code>strategy</code> contract. Unlike <code>depositIntoStrategy</code>, the resulting deposit shares are credited to the passed-in <code>staker</code> address, which must sign off on this intent.</p> <p>Effects: See <code>depositIntoStrategy</code> above. Additionally: * The staker's nonce is incremented</p> <p>Requirements: See <code>depositIntoStrategy</code> above. Additionally: * Caller MUST provide a valid, unexpired signature over the correct fields</p>"},{"location":"docs/core/StrategyManager/#withdrawal-processing","title":"Withdrawal Processing","text":"<p>These methods are callable ONLY by the <code>DelegationManager</code>, and are used when processing undelegations and withdrawals: * <code>StrategyManager.removeDepositShares</code> * <code>StrategyManager.addShares</code> * <code>StrategyManager.withdrawSharesAsTokens</code></p> <p>See <code>DelegationManager.md</code> for more context on how these methods are used.</p>"},{"location":"docs/core/StrategyManager/#removedepositshares","title":"<code>removeDepositShares</code>","text":"<pre><code>/// @notice Used by the DelegationManager to remove a Staker's shares from a particular strategy when entering the withdrawal queue\n/// @dev strategy must be beaconChainETH when talking to the EigenPodManager\nfunction removeDepositShares(\n    address staker,\n    IStrategy strategy,\n    uint256 depositSharesToRemove\n)\n    external\n    onlyDelegationManager\n</code></pre> <p>The <code>DelegationManager</code> calls this method when a staker queues a withdrawal (or undelegates, which also queues a withdrawal). The staker's deposit shares are removed while the withdrawal is in the queue, and when the withdrawal is completed, the staker can choose whether to be re-awarded the shares, or to convert and receive them as tokens (<code>addShares</code> and <code>withdrawSharesAsTokens</code>, respectively).</p> <p>The staker's deposit share balance for the <code>strategy</code> is decreased by the removed <code>depositSharesToRemove</code>. If this causes the staker's share balance to hit zero, the <code>strategy</code> is removed from the staker's strategy list.</p> <p>Note that the amount of deposit shares removed while in the withdrawal queue may not equal the amount credited when the withdrawal is completed. The staker may receive fewer if slashing occurred; see <code>DelegationManager.md</code> for details.</p> <p>Effects: * Decrease the staker's deposit share balance for the given <code>strategy</code> by the given <code>depositSharesToRemove</code>     * If this causes the balance to hit zero, the <code>strategy</code> is removed from the staker's strategy list</p> <p>Requirements: * Caller MUST be the <code>DelegationManager</code> * <code>depositSharesToRemove</code> parameter MUST NOT be zero * <code>staker</code> MUST have at least <code>depositSharesToRemove</code> balance for the given <code>strategy</code></p>"},{"location":"docs/core/StrategyManager/#addshares","title":"<code>addShares</code>","text":"<pre><code>/// @notice Used by the DelegationManager to award a Staker some shares that have passed through the withdrawal queue\n/// @dev strategy must be beaconChainETH when talking to the EigenPodManager\n/// @return existingDepositShares the shares the staker had before any were added\n/// @return addedShares the new shares added to the staker's balance\nfunction addShares(\n    address staker,\n    IStrategy strategy,\n    uint256 shares\n)\n    external\n    onlyDelegationManager\n    returns (uint256, uint256)\n</code></pre> <p>The <code>DelegationManager</code> calls this method when a queued withdrawal is completed and the withdrawer specifies that they want to receive the withdrawal \"as shares\" (rather than as the underlying tokens). </p> <p>This method credits the input deposit shares to the staker. In most cases, the input <code>shares</code> equal the same shares originally removed when the withdrawal was queued. However, if the staker's operator was slashed, they may receive less. See <code>DelegationManager.md</code> for details.</p> <p>Note that if the staker has deposits in <code>MAX_STAKER_STRATEGY_LIST_LENGTH</code> unique strategies (and the input <code>strategy</code> is not among them), this method will revert. The staker can still choose to complete the withdrawal \"as tokens\" (See <code>DelegationManager.completeQueuedWithdrawal</code>).</p> <p>Effects: * Increase the <code>staker's</code> deposit share balance for the given <code>strategy</code> by <code>shares</code>     * If the prior balance was zero, the <code>strategy</code> is added to the <code>staker's</code> strategy list * Emit a <code>Deposit</code> event</p> <p>Requirements: * Caller MUST be the <code>DelegationManager</code> * <code>staker</code> parameter MUST NOT be zero * <code>shares</code> parameter MUST NOT be zero * Length of <code>stakerStrategyList</code> for the <code>staker</code> MUST NOT exceed <code>MAX_STAKER_STRATEGY_LIST_LENGTH</code></p>"},{"location":"docs/core/StrategyManager/#withdrawsharesastokens","title":"<code>withdrawSharesAsTokens</code>","text":"<pre><code>/// @notice Used by the DelegationManager to convert deposit shares to tokens and send them to a staker\n/// @dev strategy must be beaconChainETH when talking to the EigenPodManager\n/// @dev token is not validated when talking to the EigenPodManager\nfunction withdrawSharesAsTokens(\n    address staker,\n    IStrategy strategy,\n    IERC20 token,\n    uint256 shares\n)\n    external\n    onlyDelegationManager\n</code></pre> <p>The <code>DelegationManager</code> calls this method when a queued withdrawal is completed and the withdrawer specifies that they want to receive the withdrawal as the tokens underlying the shares. </p> <p>This method directs the <code>strategy</code> to convert the input deposit shares to tokens and send them to the <code>staker</code>. In most cases, the input <code>shares</code> equal the same shares originally removed when the withdrawal was queued. However, if the staker's operator was slashed, they may receive less. See <code>DelegationManager.md</code> for details.</p> <p>Effects: * Calls <code>StrategyBase.withdraw</code></p> <p>Requirements: * Caller MUST be the <code>DelegationManager</code> * See <code>StrategyBase.withdraw</code></p>"},{"location":"docs/core/StrategyManager/#burning-slashed-shares","title":"Burning Slashed Shares","text":"<p>Slashed shares are marked as burnable, and anyone can call <code>burnShares</code> to transfer them to the default burn address. Burnable shares are stored in <code>burnableShares</code>, an EnumerableMap with strategy contract addresses as keys and associated view functions. The following methods handle burning of slashed shares: * <code>StrategyManager.increaseBurnableShares</code> * <code>StrategyManager.burnShares</code></p>"},{"location":"docs/core/StrategyManager/#increaseburnableshares","title":"<code>increaseBurnableShares</code>","text":"<pre><code>/**\n * @notice Increase the amount of burnable shares for a given Strategy. This is called by the DelegationManager\n * when an operator is slashed in EigenLayer.\n * @param strategy The strategy to burn shares in.\n * @param addedSharesToBurn The amount of added shares to burn.\n * @dev This function is only called by the DelegationManager when an operator is slashed.\n */\nfunction increaseBurnableShares(\n    IStrategy strategy, \n    uint256 addedSharesToBurn\n)\n    external\n    onlyDelegationManager\n</code></pre> <p>The <code>DelegationManager</code> calls this method when an operator is slashed, calculating the number of slashable shares and marking them for burning here.</p> <p>Anyone can then convert the shares to tokens and trigger a burn via <code>burnShares</code>. This asynchronous burning method was added to mitigate potential DoS vectors when slashing.</p> <p>Effects: * Increases <code>burnableShares</code> for the given <code>strategy</code> by <code>addedSharesToBurn</code></p> <p>Requirements: * Can only be called by the <code>DelegationManager</code></p>"},{"location":"docs/core/StrategyManager/#burnshares","title":"<code>burnShares</code>","text":"<pre><code>/**\n * @notice Burns Strategy shares for the given strategy by calling into the strategy to transfer\n * to the default burn address.\n * @param strategy The strategy to burn shares in.\n */\nfunction burnShares(\n    IStrategy strategy\n)\n    external\n</code></pre> <p>Anyone can call this method to burn slashed shares previously added by the <code>DelegationManager</code> via <code>increaseBurnableShares</code>. This method resets the strategy's burnable shares to 0, and directs the corresponding <code>strategy</code> to convert the shares to tokens and transfer them to <code>DEFAULT_BURN_ADDRESS</code>, rendering them unrecoverable.</p> <p>The <code>strategy</code> is not called if the strategy had no burnable shares.</p> <p>Effects: * Resets the strategy's burnable shares to 0 * Calls <code>withdraw</code> on the <code>strategy</code>, withdrawing shares and sending a corresponding amount of tokens to the <code>DEFAULT_BURN_ADDRESS</code></p>"},{"location":"docs/core/StrategyManager/#strategies","title":"Strategies","text":"<p>Concepts: * StrategyBase vs StrategyBaseTVLLimits</p> <p>Methods: * <code>StrategyBase.deposit</code> * <code>StrategyBase.withdraw</code> * <code>StrategyFactory.deployNewStrategy</code> * <code>StrategyFactory.blacklistTokens</code> * <code>StrategyFactory.whitelistStrategies</code> * <code>StrategyFactory.removeStrategiesFromWhitelist</code></p>"},{"location":"docs/core/StrategyManager/#strategybase-vs-strategybasetvllimits","title":"<code>StrategyBase</code> vs <code>StrategyBaseTVLLimits</code>","text":"<p>Before the introduction of the <code>StrategyFactory</code>, strategies were manually deployed and whitelisted in the <code>StrategyManager</code>. These strategies used <code>StrategyBaseTVLLimits.sol</code>, and were deployed using the transparent proxy pattern. With the introduction of the <code>StrategyFactory</code>, anyone can create a depositable strategy for any ERC20 (provided it does not have a deployed strategy yet). The <code>StrategyFactory</code> deploys beacon proxies, each of which points at a single implementation of <code>StrategyBase.sol</code>.</p> <p>Though these are two different contracts, <code>StrategyBaseTVLLimits</code> inherits all its basic functionality from <code>StrategyBase</code>, and only implements a \"TVL limits\" capability on top of them. In short, this additional functionality checks, before each deposit, whether: 1. the deposit amount exceeds a configured <code>maxPerDeposit</code> 2. the total token balance after the deposit exceeds a configured <code>maxTotalDeposits</code></p> <p>To this date, however, these \"TVL limits\" capabilities have never been used. The values for both of the variables mentioned above have been set to <code>type(uint).max</code> since deployment, and there is no plan to change these. Effectively, all instances of <code>StrategyBaseTVLLimits</code> behave identically to instances of <code>StrategyBase</code> - with the exception being that the former uses a transparent proxy, and the latter a beacon proxy.</p>"},{"location":"docs/core/StrategyManager/#strategybasedeposit","title":"<code>StrategyBase.deposit</code>","text":"<pre><code>/**\n * @notice Used to deposit tokens into this Strategy\n * @param token is the ERC20 token being deposited\n * @param amount is the amount of token being deposited\n * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\n * `depositIntoStrategy` function, and individual share balances are recorded in the strategyManager as well.\n * @dev Note that the assumption is made that `amount` of `token` has already been transferred directly to this contract\n * (as performed in the StrategyManager's deposit functions). In particular, setting the `underlyingToken` of this contract\n * to be a fee-on-transfer token will break the assumption that the amount this contract *received* of the token is equal to\n * the amount that was input when the transfer was performed (i.e. the amount transferred 'out' of the depositor's balance).\n * @dev Note that any validation of `token` is done inside `_beforeDeposit`. This can be overridden if needed.\n * @return newShares is the number of new shares issued at the current exchange ratio.\n */\nfunction deposit(\n    IERC20 token,\n    uint256 amount\n)\n    external\n    onlyWhenNotPaused(PAUSED_DEPOSITS)\n    onlyStrategyManager\n    returns (uint256 newShares)\n</code></pre> <p>The <code>StrategyManager</code> calls this method when stakers deposit ERC20 tokens into a strategy. At the time this method is called, the tokens have already been transferred to the strategy. The role of this method is to (i) calculate the number of deposit shares the tokens represent according to the exchange rate, and (ii) add the new deposit shares to the strategy's recorded total shares.</p> <p>The number of new shares created are returned to the <code>StrategyManager</code> to be added to the staker's strategy share balance.</p> <p>Effects: * <code>StrategyBaseTVLLimits.totalShares</code> is increased to account for the new shares created by the deposit</p> <p>Requirements: * Caller MUST be the <code>StrategyManager</code> * Pause status MUST NOT be set: <code>PAUSED_DEPOSITS</code> * The passed-in <code>token</code> MUST match the strategy's <code>underlyingToken</code> * The token amount being deposited MUST NOT exceed the per-deposit cap * When converted to shares via the strategy's exchange rate:     * The <code>amount</code> of <code>token</code> deposited MUST represent at least 1 new share for the depositor     * The new total shares awarded by the strategy MUST NOT exceed <code>MAX_TOTAL_SHARES</code></p>"},{"location":"docs/core/StrategyManager/#strategybasewithdraw","title":"<code>StrategyBase.withdraw</code>","text":"<pre><code>/**\n * @notice Used to withdraw tokens from this Strategy, to the `recipient`'s address\n * @param recipient is the address to receive the withdrawn funds\n * @param token is the ERC20 token being transferred out\n * @param amountShares is the amount of shares being withdrawn\n * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\n * other functions, and individual share balances are recorded in the strategyManager as well.\n * @dev Note that any validation of `token` is done inside `_beforeWithdrawal`. This can be overridden if needed.\n */\nfunction withdraw(\n    address recipient,\n    IERC20 token,\n    uint256 amountShares\n)\n    external\n    onlyWhenNotPaused(PAUSED_WITHDRAWALS)\n    onlyStrategyManager\n</code></pre> <p>The <code>StrategyManager</code> calls this method to convert a number of deposit shares to tokens, and transfer them to a <code>recipient</code>. Typically, this method is invoked as part of the withdrawal completion flow (see <code>DelegationManager.completeQueuedWithdrawal</code>). However, this method may also be invoked during the share burning flow (see <code>StrategyManager.burnShares</code>).</p> <p>This method converts the deposit shares back into tokens using the strategy's exchange rate. The strategy's total shares are decreased to reflect the withdrawal before transferring the tokens to the <code>recipient</code>.</p> <p>Effects: * <code>StrategyBaseTVLLimits.totalShares</code> is decreased to account for the shares being withdrawn * <code>underlyingToken.safeTransfer</code> is called to transfer the tokens to the <code>recipient</code></p> <p>Requirements: * Caller MUST be the <code>StrategyManager</code> * Pause status MUST NOT be set: <code>PAUSED_WITHDRAWALS</code> * The passed-in <code>token</code> MUST match the strategy's <code>underlyingToken</code> * The <code>amountShares</code> being withdrawn MUST NOT exceed the <code>totalShares</code> in the strategy * The tokens represented by <code>amountShares</code> MUST NOT exceed the strategy's token balance</p>"},{"location":"docs/core/StrategyManager/#strategyfactorydeploynewstrategy","title":"<code>StrategyFactory.deployNewStrategy</code>","text":"<pre><code>/**\n * @notice Deploy a new StrategyBase contract for the ERC20 token, using a beacon proxy\n * @dev A strategy contract must not yet exist for the token.\n * @dev Immense caution is warranted for non-standard ERC20 tokens, particularly \"reentrant\" tokens\n * like those that conform to ERC777.\n */\nfunction deployNewStrategy(IERC20 token)\n    external\n    onlyWhenNotPaused(PAUSED_NEW_STRATEGIES)\n    returns (IStrategy newStrategy)\n</code></pre> <p>Allows anyone to deploy a new <code>StrategyBase</code> instance that supports deposits/withdrawals using the provided <code>token</code>. As part of calling this method, the <code>StrategyFactory</code> automatically whitelists the new strategy for deposits via the <code>StrategyManager</code>.</p> <p>Note that the <code>StrategyFactory</code> only permits ONE strategy deployment per <code>token</code>. Once a <code>token</code> has an associated strategy deployed via this method, <code>deployNewStrategy</code> cannot be used to deploy a strategy for <code>token</code> again. Additionally, <code>deployNewStrategy</code> will reject any <code>token</code> placed onto the <code>StrategyFactory</code> blacklist. This feature was added to prevent the deployment of strategies that existed before the <code>StrategyFactory</code> was created. For details, see <code>StrategyFactory.blacklistTokens</code>.</p> <p>NOTE: Use caution when deploying strategies for tokens that do not strictly conform to ERC20 standards. Rebasing tokens similar to already-whitelisted LSTs should be supported, but please DYOR if your token falls outside of ERC20 norms. Specific things to look out for include (but are not limited to): exotic rebasing tokens, tokens that support reentrant behavior (like ERC-777), and other nonstandard ERC20 derivatives.</p> <p>Effects: * Deploys a new <code>BeaconProxy</code> for the <code>token</code>, which references the current <code>StrategyBase</code> implementation * Updates the <code>tokenStrategy</code> mapping for the <code>token</code>, preventing a second strategy deployment for the same token * See <code>StrategyManager.addStrategiesToDepositWhitelist</code></p> <p>Requirements: * Pause status MUST NOT be set: <code>PAUSED_NEW_STRATEGIES</code> * <code>token</code> MUST NOT be blacklisted within <code>StrategyFactory</code> * <code>StrategyFactory</code> MUST NOT have been used to deploy a strategy for <code>token</code> already * See <code>StrategyManager.addStrategiesToDepositWhitelist</code></p>"},{"location":"docs/core/StrategyManager/#strategyfactoryblacklisttokens","title":"<code>StrategyFactory.blacklistTokens</code>","text":"<pre><code>/**\n * @notice Owner-only function to prevent strategies from being created for given tokens.\n * @param tokens An array of token addresses to blacklist.\n */\nfunction blacklistTokens(IERC20[] calldata tokens) \n    external \n    onlyOwner\n</code></pre> <p>Allows the owner to prevent certain <code>tokens</code> from having strategies deployed via <code>StrategyFactory.deployNewStrategy</code>. This method was added to prevent the deployment of strategies for tokens that already have strategies deployed/whitelisted through other means.</p> <p>Note that once the owner adds tokens to the blacklist, they cannot be removed. This is a known limitation of the <code>StrategyFactory</code>, and can be addressed by upgrading the factory if needed.</p> <p>Effects: * Adds each token in <code>tokens</code> to the <code>isBlacklisted</code> mapping</p> <p>Requirements: * Caller MUST be the owner * Each passed in <code>token</code> MUST NOT already be blacklisted</p>"},{"location":"docs/core/StrategyManager/#strategyfactorywhiteliststrategies","title":"<code>StrategyFactory.whitelistStrategies</code>","text":"<pre><code>/**\n * @notice Owner-only function to pass through a call to `StrategyManager.addStrategiesToDepositWhitelist`\n */\nfunction whitelistStrategies(\n    IStrategy[] calldata strategiesToWhitelist\n)\n    external\n    onlyOwner\n</code></pre> <p>Allows the owner to explicitly whitelist strategies in the <code>StrategyManager</code>. This method is used as a passthrough for the <code>StrategyManager.addStrategiesToDepositWhitelist</code>, in case the owner needs to whitelist strategies not deployed via the <code>StrategyFactory</code>.</p> <p>Effects: * See <code>StrategyManager.addStrategiesToDepositWhitelist</code></p> <p>Requirements: * Caller MUST be the owner * See <code>StrategyManager.addStrategiesToDepositWhitelist</code></p>"},{"location":"docs/core/StrategyManager/#strategyfactoryremovestrategiesfromwhitelist","title":"<code>StrategyFactory.removeStrategiesFromWhitelist</code>","text":"<pre><code>/**\n * @notice Owner-only function to pass through a call to `StrategyManager.removeStrategiesFromDepositWhitelist`\n */\nfunction removeStrategiesFromWhitelist(\n    IStrategy[] calldata strategiesToRemoveFromWhitelist\n) \n    external\n    onlyOwner\n</code></pre> <p>Allows the owner to remove strategies from the <code>StrategyManager</code> strategy whitelist. This method is used as a passthrough for the <code>StrategyManager.removeStrategiesFromDepositWhitelist</code>, in case the owner needs to access this method.</p> <p>Effects: * See <code>StrategyManager.removeStrategiesFromDepositWhitelist</code></p> <p>Requirements: * Caller MUST be the owner * See <code>StrategyManager.removeStrategiesFromDepositWhitelist</code></p>"},{"location":"docs/core/StrategyManager/#system-configuration","title":"System Configuration","text":"<p>The Strategy Whitelister role has the ability to permit/remove strategies from being depositable via the <code>StrategyManager</code>. This role is held by the <code>StrategyFactory</code> (which is fully documented in Strategies). The following methods concern the Strategy Whitelister role and its abilities within the <code>StrategyManager</code>: * <code>StrategyManager.setStrategyWhitelister</code> * <code>StrategyManager.addStrategiesToDepositWhitelist</code> * <code>StrategyManager.removeStrategiesFromDepositWhitelist</code></p>"},{"location":"docs/core/StrategyManager/#setstrategywhitelister","title":"<code>setStrategyWhitelister</code>","text":"<pre><code>/**\n * @notice Owner-only function to change the `strategyWhitelister` address.\n * @param newStrategyWhitelister new address for the `strategyWhitelister`.\n */\nfunction setStrategyWhitelister(address newStrategyWhitelister) external onlyOwner\n</code></pre> <p>Allows the <code>owner</code> to update the Strategy Whitelister address. Currently, the Strategy Whitelister role is held by the <code>StrategyFactory</code>. See Strategies for more details.</p> <p>Effects: * Updates <code>StrategyManager.strategyWhitelister</code></p> <p>Requirements: * Caller MUST be the <code>owner</code></p>"},{"location":"docs/core/StrategyManager/#addstrategiestodepositwhitelist","title":"<code>addStrategiesToDepositWhitelist</code>","text":"<pre><code>/**\n * @notice Owner-only function that adds the provided Strategies to the 'whitelist' of strategies that stakers can deposit into\n * @param strategiesToWhitelist Strategies that will be added to the `strategyIsWhitelistedForDeposit` mapping (if they aren't in it already)\n */\nfunction addStrategiesToDepositWhitelist(\n    IStrategy[] calldata strategiesToWhitelist\n)\n    external\n    onlyStrategyWhitelister\n</code></pre> <p>Allows the Strategy Whitelister to add any number of strategies to the <code>StrategyManager</code> whitelist, and configure whether third party transfers are enabled or disabled for each. Strategies on the whitelist are eligible for deposit via <code>depositIntoStrategy</code>.</p> <p>Effects: * Adds entries to <code>StrategyManager.strategyIsWhitelistedForDeposit</code></p> <p>Requirements: * Caller MUST be the <code>strategyWhitelister</code></p>"},{"location":"docs/core/StrategyManager/#removestrategiesfromdepositwhitelist","title":"<code>removeStrategiesFromDepositWhitelist</code>","text":"<pre><code>/**\n * @notice Owner-only function that removes the provided Strategies from the 'whitelist' of strategies that stakers can deposit into\n * @param strategiesToRemoveFromWhitelist Strategies that will be removed to the `strategyIsWhitelistedForDeposit` mapping (if they are in it)\n */\nfunction removeStrategiesFromDepositWhitelist(\n    IStrategy[] calldata strategiesToRemoveFromWhitelist\n)\n    external\n    onlyStrategyWhitelister\n</code></pre> <p>Allows the Strategy Whitelister to remove any number of strategies from the <code>StrategyManager</code> whitelist. The removed strategies will no longer be eligible for deposit via <code>depositIntoStrategy</code>. However, withdrawals for previously-whitelisted strategies may still be initiated and completed, as long as the staker has shares to withdraw.</p> <p>Effects: * Removes entries from <code>StrategyManager.strategyIsWhitelistedForDeposit</code></p> <p>Requirements: * Caller MUST be the <code>strategyWhitelister</code></p>"},{"location":"docs/core/accounting/SharesAccounting/","title":"Shares Accounting","text":"<p>This document outlines the changes to the staker and operator Shares accounting resulting from the Slashing Upgrade. There are several introduced variables such as the deposit scaling factor ($k_n$), max magnitude ($m_n$), and beacon chain slashing factor ($l_n$). How these interact with the operator and staker events like deposits, slashing, withdrawals will all be described below.</p>"},{"location":"docs/core/accounting/SharesAccounting/#prior-reading","title":"Prior Reading","text":"<ul> <li>ELIP-002: Slashing via Unique Stake and Operator Sets</li> </ul>"},{"location":"docs/core/accounting/SharesAccounting/#pre-slashing-upgrade","title":"Pre-Slashing Upgrade","text":"<p>We'll look at the \"shares\" model as historically defined prior to the Slashing upgrade. Pre-slashing, stakers could receive shares for deposited assets, delegate those shares to operators, and withdraw those shares from the protocol. We can write this a bit more formally:</p>"},{"location":"docs/core/accounting/SharesAccounting/#staker-level","title":"Staker Level","text":"<p>$s_n$ - The amount of shares in the storage of the <code>StrategyManager</code>/<code>EigenPodManager</code> at time n.</p>"},{"location":"docs/core/accounting/SharesAccounting/#operator-level","title":"Operator Level","text":"<p>$op_n$ - The operator shares in the storage of the <code>DelegationManager</code> at time n which can also be rewritten as \\ $op_n = \\sum_{i=1}^{k} s_{n,i}$ where the operator has $k$ number of stakers delegated to them.</p>"},{"location":"docs/core/accounting/SharesAccounting/#staker-deposits","title":"Staker Deposits","text":"<p>Upon each staker deposit of amount $d_n$ at time $n$, the staker's shares and delegated operator's shares are updated as follows:</p> <p>$$  s_{n+1} = s_{n} + d_{n} $$</p> <p>$$  op_{n+1} = op_{n} + d_{n} $$</p>"},{"location":"docs/core/accounting/SharesAccounting/#staker-withdrawals","title":"Staker Withdrawals","text":"<p>Similarly for staker withdrawals, given an amount $w_n$ to withdraw at time $n$, the staker and operator's shares are decremented at the point of the withdrawal being queued:</p> <p>$$  s_{n+1} = s_{n} - w_{n} $$</p> <p>$$  op_{n+1} = op_{n} - w_{n} $$</p> <p>Later after the withdrawal delay has passed, the staker can complete their withdrawal to withdraw the full amount $w_n$ of shares. </p>"},{"location":"docs/core/accounting/SharesAccounting/#slashing-upgrade-changes","title":"Slashing Upgrade Changes","text":"<p>The remaining portions of this document will assume understanding of Allocations/Deallocations, Max Magnitudes, and Operator Sets as described in ELIP-002.</p>"},{"location":"docs/core/accounting/SharesAccounting/#terminology","title":"Terminology","text":"<p>The word \"shares\" in EigenLayer has historically referred to the amount of shares a staker receives upon depositing assets through the <code>StrategyManager</code> or <code>EigenPodManager</code>. Outside of some conversion ratios in the <code>StrategyManager</code> to account for rebasing tokens, shares roughly correspond 1:1 with deposit amounts (i.e. 1e18 shares in the <code>beaconChainETHStrategy</code> corresponds to 1 ETH of assets). When delegating to an operator or queueing a withdrawal, the <code>DelegationManager</code> reads deposit shares from the <code>StrategyManager</code> or <code>EigenPodManager</code> to determine how many shares to delegate (or undelegate).</p> <p>With the slashing release, there is a need to differentiate \"classes\" of shares.</p> <p>Deposit shares: </p> <p>Formerly known as \"shares,\" these are the same shares used before the slashing release. They continue to be managed by the <code>StrategyManager</code> and <code>EigenPodManager</code>, and roughly correspond 1:1 with deposited assets.</p> <p>Withdrawable shares: </p> <p>When an operator is slashed, the slash is applied to their stakers asynchronously (otherwise, slashing would require iterating over each of an operator's stakers; this is prohibitively expensive). </p> <p>The <code>DelegationManager</code> must find a common representation for the deposit shares of many stakers, each of which may have experienced different amounts of slashing depending on which operator they are delegated to, and when they delegated. This common representation is achieved in part through a value called the <code>depositScalingFactor</code>: a per-staker, per-strategy value that scales a staker's deposit shares as they deposit assets over time.</p> <p>When a staker does just about anything (changing their delegated operator, queueing/completing a withdrawal, depositing new assets), the <code>DelegationManager</code> converts their deposit shares to withdrawable shares by applying the staker's <code>depositScalingFactor</code> and the current slashing factor (a per-strategy scalar primarily derived from the amount of slashing an operator has received in the <code>AllocationManager</code>).</p> <p>These withdrawable shares are used to determine how many of a staker's deposit shares are actually able to be withdrawn from the protocol, as well as how many shares can be delegated to an operator. An individual staker's withdrawable shares are not reflected anywhere in storage; they are calculated on-demand.</p> <p>Operator shares:</p> <p>Operator shares are derivative of withdrawable shares. When a staker delegates to an operator, they are delegating their withdrawable shares. Thus, an operator's operator shares represent the sum of all of their stakers' withdrawable shares. Note that when a staker first delegates to an operator, this is a special case where deposit shares == withdrawable shares. If the staker deposits additional assets later, this case will not hold if slashing was experienced in the interim.</p> <p>Each of these definitions can also be applied to the pre-slashing share model, but with the caveat that for all stakers, withdrawable shares equal deposit shares. After the slashing upgrade this is not necessarily the case - a staker may not be able to withdraw the amount they deposited if their operator got slashed.</p> <p>Now let's look at these updated definitions in detail and how the accounting math works with deposits, withdrawals, and slashing.</p>"},{"location":"docs/core/accounting/SharesAccounting/#stored-variables","title":"Stored Variables","text":"<p>Note that these variables are all defined within the context of a single Strategy. Also note that the concept of \"1\" used within these equations is represented in the code by the constant <code>1 WAD</code>, or <code>1e18</code>.</p>"},{"location":"docs/core/accounting/SharesAccounting/#staker-level_1","title":"Staker Level","text":"<p>$s_n$ - The amount of deposit shares in the storage of the <code>StrategyManager</code>/<code>EigenPodManager</code> at time $n$. In storage: <code>StrategyManager.stakerDepositShares</code> and <code>EigenPodManager.podOwnerDepositShares</code></p> <p>$k_n$ - The staker's \u201cdeposit scaling factor\u201d at time $n$. This is initialized to 1. In storage: <code>DelegationManager.depositScalingFactor</code></p> <p>$l_n$ - The staker's \"beacon chain slashing factor\" at time $n$. This is initialized to 1. For any equations concerning non-native ETH strategies, this can be assumed to be 1. In storage: <code>EigenPodManager.beaconChainSlashingFactor</code></p>"},{"location":"docs/core/accounting/SharesAccounting/#operator-level_1","title":"Operator Level","text":"<p>$m_n$ - The operator magnitude at time n. This is initialized to 1.</p> <p>$op_n$ - The operator shares in the storage of the <code>DelegationManager</code> at time n. In storage: <code>DelegationManager.operatorShares</code></p>"},{"location":"docs/core/accounting/SharesAccounting/#conceptual-variables","title":"Conceptual Variables","text":"<p>$a_n = s_n k_n l_n m_n$ - The withdrawable shares that the staker owns at time $n$. Read from view function <code>DelegationManager.getWithdrawableShares</code></p> <p>Note that $op_n = \\sum_{i=1}^{k} a_{n,i}$.</p>"},{"location":"docs/core/accounting/SharesAccounting/#deposits","title":"Deposits","text":"<p>For an amount of newly deposited shares $d_n$,</p>"},{"location":"docs/core/accounting/SharesAccounting/#staker-level_2","title":"Staker Level","text":"<p>Conceptually, the staker's deposit shares and withdrawable shares both increase by the deposited amount $d_n$. Let's work out how this math impacts the deposit scaling factor $k_n$.</p> <p>$$ a_{n+1} = a_n + d_n $$</p> <p>$$ s_{n+1} = s_n +d_n $$</p> <p>$$ l_{n+1} = l_n $$</p> <p>$$ m_{n+1} = m_n $$</p> <p>Expanding the $a_{n+1}$ calculation</p> <p>$$ s_{n+1} k_{n+1} l_{n+1} m_{n+1} = s_n k_n l_n m_n + d_n $$</p> <p>Simplifying yields:</p> <p>$$ k_{n+1} = \\frac{s_n k_n l_n m_n + d_n}{s_{n+1} l_{n+1} m_{n+1}}=\\frac{s_n k_n l_n m_n + d_n}{(s_n+d_n)l_nm_n} $$</p> <p>Updating the slashing factor is implemented in <code>SlashingLib.update</code>.</p>"},{"location":"docs/core/accounting/SharesAccounting/#operator-level_2","title":"Operator Level","text":"<p>For the operator (if the staker is delegated), the delegated operator shares should increase by the exact amount the staker just deposited. Therefore $op_n$ is updated as follows:</p> <p>$$ op_{n+1} = op_n+d_n $$</p> <p>See implementation in: * <code>StrategyManager.depositIntoStrategy</code> * <code>EigenPodManager.recordBeaconChainETHBalanceUpdate</code></p>"},{"location":"docs/core/accounting/SharesAccounting/#delegation","title":"Delegation","text":"<p>Suppose we have an undelegated staker who decides to delegate to an operator. We have the following properties that should be preserved.</p>"},{"location":"docs/core/accounting/SharesAccounting/#operator-level_3","title":"Operator Level","text":"<p>Operator shares should be increased by the amount of delegatable shares the staker has, this is synonymous to their withdrawable shares $a_n$. Therefore,</p> <p>$$ op_{n+1} = op_{n} + a_n $$</p> <p>$$ = op_{n} + s_n k_n l_n m_n $$</p>"},{"location":"docs/core/accounting/SharesAccounting/#staker-level_3","title":"Staker Level","text":"<p>withdrawable shares should remain unchanged</p> <p>$$ a_{n+1} = a_n $$</p> <p>deposit shares should remain unchanged</p> <p>$$ s_{n+1} = s_n $$</p> <p>beaconChainSlashingFactor and maxMagnitude should also remain unchanged. In this case, since the staker is not delegated, then their maxMagnitude should by default be equal to 1.</p> <p>$$ l_{n+1} = l_n $$</p> <p>Now the question is what is the new depositScalingFactor equal to?</p> <p>$$ a_{n+1} = a_n $$</p> <p>$$ =&gt; s_{n+1} k_{n+1} l_{n+1} m_{n+1} = s_n k_n l_n m_n $$</p> <p>$$ =&gt; s_{n} k_{n+1} l_{n} m_{n+1} = s_n k_n l_n m_n $$</p> <p>$$ =&gt; k_{n+1} = \\frac {k_n m_n} { m_{n+1} } $$</p> <p>Notice how the staker variables that update $k_{n+1}$ and $m_{n+1}$ do not affect previously queued withdrawals and shares received upon withdrawal completion. This is because the maxMagnitude that is looked up is dependent on the operator at the time of the queued withdrawal and the $k_n$ is effectively stored in the scaled shares field.</p>"},{"location":"docs/core/accounting/SharesAccounting/#slashing","title":"Slashing","text":"<p>Given a proportion to slash $p_n = \\frac {m_{n+1}}{m_n}$ ,</p>"},{"location":"docs/core/accounting/SharesAccounting/#operator-level_4","title":"Operator Level","text":"<p>From a conceptual level, operator shares should be decreased by the proportion according to the following:</p> <p>$$  op_{n+1} = op_n p_n $$</p> <p>$$  =&gt; op_{n+1} = op_n \\frac {m_{n+1}} {m_n} $$ </p> <p>Calculating the amount of $sharesToDecrement$:</p> <p>$$  sharesToDecrement = op_n - op_{n+1} $$</p> <p>$$  = op_n - op_n \\frac {m_{n+1}} {m_n} $$</p> <p>This calculation is performed in <code>SlashingLib.calcSlashedAmount</code>.</p>"},{"location":"docs/core/accounting/SharesAccounting/#staker-level_4","title":"Staker Level","text":"<p>From the conceptual level, a staker's withdrawable shares should also be proportionally slashed so the following must be true:</p> <p>$$ a_{n+1} = a_n p_n $$</p> <p>We don't want to update storage at the staker level during slashing as this would be computationally too expensive given an operator has a 1-many relationship with its delegated stakers. Therefore we want to prove $a_{n+1} = a_n p_n$ since withdrawable shares are slashed by $p_n$.</p> <p>Given the following:</p> <p>$l_{n+1} = l_n$ \\ $k_{n+1} = k_n$ \\ $s_{n+1} = s_n$</p> <p>Expanding the $a_{n+1}$ equation:</p> <p>$$ a_{n+1} = s_{n+1} k_{n+1} l_{n+1} m_{n+1} $$</p> <p>$$ =&gt; s_{n} k_{n} l_{n} m_{n+1} $$</p> <p>We know that  $p_n = \\frac {m_{n+1}}{m_n}$ =&gt;  $m_{n+1} = m_n p_n$ </p> <p>$$ =&gt;  s_n k_n l_n m_n p_n $$</p> <p>$$ =&gt; a_n p_n $$</p> <p>This means that a staker's withdrawable shares are immediately affected upon their operator's maxMagnitude being decreased via slashing.</p>"},{"location":"docs/core/accounting/SharesAccounting/#queue-withdrawal","title":"Queue Withdrawal","text":"<p>Withdrawals are queued by inputting a <code>depositShares</code> amount $x_n &lt;= s_n$. The actual withdrawable amount $w_n$ corresponding to $x_n$ is given by the following:</p> <p>$$  w_n = x_n k_n l_n m_n $$</p> <p>This conceptually makes sense as the amount being withdrawn $w_n$ is some amount &lt;= $a_n$ which is the total withdrawable shares amount for the staker. </p>"},{"location":"docs/core/accounting/SharesAccounting/#operator-level_5","title":"Operator Level","text":"<p>When a staker queues a withdrawal, their operator's shares are reduced accordingly:</p> <p>$$  op_{n+1} = op_n - w_n $$</p>"},{"location":"docs/core/accounting/SharesAccounting/#staker-level_5","title":"Staker Level","text":"<p>$$  a_{n+1} = a_n - w_n $$</p> <p>$$  s_{n+1} = s_n - x_n $$</p> <p>This means that when queuing a withdrawal, the staker inputs a <code>depositShares</code> amount $x_n$. The <code>DelegationManager</code> calls the the <code>EigenPodManager</code>/<code>StrategyManager</code> to decrement their <code>depositShares</code> by this amount. Additionally, the <code>depositShares</code> are converted to a withdrawable amount $w_n$, which are decremented from the operator's shares.</p> <p>We want to show that the total withdrawable shares for the staker are decreased accordingly such that $a_{n+1} = a_n - w_n$.</p> <p>Given the following:</p> <p>$l_{n+1} = l_n$ \\ $k_{n+1} = k_n$ \\ $s_{n+1} = s_n$</p> <p>Expanding the $a_{n+1}$ equation:</p> <p>$$  a_{n+1} = s_{n+1} k_{n+1} l_{n+1} m_{n+1} $$</p> <p>$$  =&gt;  (s_{n} - x_n) k_{n+1} l_{n+1} m_{n+1} $$</p> <p>$$  =  (s_{n} - x_n) k_n l_n m_n $$</p> <p>$$  = s_n k_n l_n m_n - x_n k_n l_n m_n $$</p> <p>$$  = a_n - w_n $$</p> <p>Note that when a withdrawal is queued, a <code>Withdrawal</code> struct is created with scaled shares defined as $q_t = x_t k_t$ where $t$ is the time of the queuing. The reason we define and store scaled shares like this will be clearer in Complete Withdrawal below.</p> <p>Additionally, we reset the depositScalingFactor when a user queues a withdrawal for all their shares, either through un/redelegation or directly. This is because the DSF at the time of withdrawal is stored in the scaled shares, and any \"new\" deposits or delegations by the staker should be considered as new. Note that withdrawal completion is treated as a kind of deposit when done as shares, which again will be clearer below.</p> <p>See implementation in: * <code>DelegationManager.queueWithdrawals</code> * <code>SlashingLib.scaleForQueueWithdrawal</code></p> <p></p>"},{"location":"docs/core/accounting/SharesAccounting/#complete-withdrawal","title":"Complete Withdrawal","text":"<p>Now the staker completes a withdrawal $(q_t, t)$ which was queued at time $t$.</p>"},{"location":"docs/core/accounting/SharesAccounting/#operator-level_6","title":"Operator Level","text":"<p>If the staker completes the withdrawal as tokens, any operator shares remain unchanged. The original operator's shares were decremented when the withdrawal was queued, and a new operator does not receive shares if the staker is withdrawing assets (\"as tokens\").</p> <p>However, if the staker completes the withdrawal as shares, the shares are added to the staker's current operator according to the formulae in Deposits.</p>"},{"location":"docs/core/accounting/SharesAccounting/#staker-level_6","title":"Staker Level","text":"<p>Recall from Queue Withdrawal that, when a withdrawal is queued, the <code>Withdrawal</code> struct stores scaled shares, defined as $q_t = x_t k_t$ where $x_t$ is the deposit share amount requested for withdrawal and $t$ is the time of the queuing.</p> <p>And, given the formula for calculating withdrawable shares, the withdrawable shares given to the staker are $w_t$:</p> <p>$$ w_t = q_t m_t l_t = x_t k_t l_t m_t $$</p> <p>However, the staker's shares in their withdrawal may have been slashed while the withdrawal was in the queue. Their operator may have been slashed by an AVS, or, if the strategy is the <code>beaconChainETHStrategy</code>, the staker's validators may have been slashed/penalized.</p> <p>The amount of shares they actually receive is proportionally the following:</p> <p>$$     \\frac{m_{t+delay} l_{now} }{m_t l_t} $$</p> <p>So the actual amount of shares withdrawn on completion is calculated to be:</p> <p>$$ sharesWithdrawn = w_t (\\frac{m_{t+delay} l_{now}}{m_t l_t} ) $$</p> <p>$$  = x_t k_t l_t m_t (\\frac{m_{t+delay} l_{now}}{m_t l_t} ) $$</p> <p>$$  = x_t k_t m_{t+delay} l_{now} $$</p> <p>Now we know that $q_t = x_t k_t$ so we can substitute this value in here. </p> <p>$$  = q_t m_{t+delay} l_{now} $$</p> <p>From the above equations the known values we have during the time of queue withdrawal is $x_t k_t$ and we only know $m_{t+delay} l_{now}$ when the queued withdrawal is completable. This is why we store scaled shares as $q_t = x_t k_t$. The other term ($m_{t+delay} l_{now}$) is read during the completing transaction of the withdrawal.</p> <p>Note: Reading $m_{t+delay}$ is performed by a historical Snapshot lookup of the max magnitude in the <code>AllocationManager</code> while $l_{now}$, the current beacon chain slashing factor, is done through the <code>EigenPodManager</code>. Recall that if the strategy in question is not the <code>beaconChainETHStrategy</code>, $l_{now}$ will default to \"1\".</p> <p>The definition of scaled shares is used solely for handling withdrawals and accounting for slashing that may have occurred (both on EigenLayer and on the beacon chain) during the queue period.</p> <p>See implementation in: * <code>DelegationManager.completeQueuedWithdrawal</code> * <code>SlashingLib.scaleForCompleteWithdrawal</code></p>"},{"location":"docs/core/accounting/SharesAccounting/#handling-beacon-chain-balance-decreases-in-eigenpods","title":"Handling Beacon Chain Balance Decreases in EigenPods","text":"<p>Beacon chain balance decreases are handled differently after the slashing upgrade with the introduction of $l_n$ the beacon chain slashing factor. </p> <p>Prior to the upgrade, any decreases in an <code>EigenPod</code> balance for a staker as a result of completing a checkpoint immediately decrements from the staker's shares in the <code>EigenPodManager</code>. As an edge case, this meant that a staker's shares could go negative if, for example, they queued a withdrawal for all their shares and then completed a checkpoint on their <code>EigenPod</code> showing a balance decrease.</p> <p>With the introduction of the beacon chain slashing factor, beacon chain balance decreases no longer result in a decrease in deposit shares. Instead, the staker's beacon chain slashing factor is decreased, allowing the system to realize that slash in any existing shares, as well as in any existing queued withdrawals. Effectively, this means that beacon chain slashing is accounted for similarly to EigenLayer-native slashing; deposit shares remain the same, while withdrawable shares are reduced:</p> <p></p> <p>Now let's consider how beacon chain balance decreases are handled when they represent a negative share delta for a staker's EigenPod.</p>"},{"location":"docs/core/accounting/SharesAccounting/#added-definitions","title":"Added Definitions","text":"<p>$welw$ is <code>withdrawableExecutionLayerGwei</code>. This is purely native ETH in the <code>EigenPod</code>, attributed via checkpoint and considered withdrawable by the pod (but without factoring in any EigenLayer-native slashing). <code>DelegationManager.getWithdrawableShares</code> can be called  to account for both EigenLayer and beacon chain slashing.</p> <p>$before\\text{ }start$ is time just before a checkpoint is started</p> <p>$after\\text{ }complete$ is the time just after a checkpoint is completed </p> <p>As a checkpoint is completed, the total assets represented by the pod's native ETH and beacon chain balances before and after are given by:</p> <p>$g_n = welw_{before\\text{ }start}+\\sum_i validator_i.balance_{before\\text{ }start}$ \\ $h_n = welw_{after\\text{ }complete}+\\sum_i validator_i.balance_{after\\text{ }complete}$</p>"},{"location":"docs/core/accounting/SharesAccounting/#staker-level_7","title":"Staker Level","text":"<p>Conceptually, the above logic specifies that we decrease the staker's withdrawable shares proportionally to the balance decrease:</p> <p>$$ a_{n+1} = \\frac{h_n}{g_n}a_n $$</p> <p>We implement this by setting</p> <p>$$ l_{n+1}=\\frac{h_n}{g_n}l_n $$</p> <p>Given:</p> <p>$m_{n+1}=m_n$ (staker beacon chain slashing does not affect its operator's magnitude) $s_{n+1} = s_n$ (no subtraction of deposit shares) $k_{n+1}=k_n$</p> <p>Then, plugging into the formula for withdrawable shares:</p> <p>$$ a_{n+1} = s_{n+1}k_{n+1}l_{n+1}m_{n+1} $$</p> <p>$$ =s_nk_n\\frac{h_n}{g_n}l_nm_n $$</p> <p>$$ = \\frac{h_n}{g_n}a_n $$</p>"},{"location":"docs/core/accounting/SharesAccounting/#operator-level_7","title":"Operator Level","text":"<p>Now we want to update the operator's shares accordingly. At a conceptual level $op_{n+1}$ should be the following:</p> <p>$$  op_{n+1} = op_n - a_n + a_{n+1} $$</p> <p>We can simplify this further</p> <p>$$  =op_{n}-s_nk_nl_nm_n + s_nk_nl_{n+1}m_n $$</p> <p>$$  = op_{n}+s_nk_nm_n(l_{n+1}-l_n) $$</p> <p>See implementation in: * <code>EigenPodManager.recordBeaconChainETHBalanceUpdate</code> * <code>DelegationManager.decreaseDelegatedShares</code></p>"},{"location":"docs/core/accounting/SharesAccounting/#implementation-details","title":"Implementation Details","text":"<p>In practice, we can\u2019t actually have floating values so we will substitute all $k_n, l_n, m_n$ terms with $m_n$/1e18  $\\frac{k_n}{1e18},\\frac{l_n}{1e18} ,\\frac{m_n}{1e18}$ respectively where $k_n, l_n, m_n$ are the values in storage, all initialized to 1e18. This allows us to conceptually have values in the range $[0,1]$.</p> <p>We make use of OpenZeppelin's Math library and <code>mulDiv</code> for calculating $floor(\\frac{x \\cdot y}{denominator})$ with full precision. Sometimes for specific rounding edge cases, $ceiling(\\frac{x \\cdot y}{denominator})$ is explicitly used.</p>"},{"location":"docs/core/accounting/SharesAccounting/#multiplication-and-division-operations","title":"Multiplication and Division Operations","text":"<p>For all the equations in the above document, we substitute any product operations of $k_n, l_n, m_n$ with the <code>mulWad</code> pure function. <pre><code>function mulWad(uint256 x, uint256 y) internal pure returns (uint256) {\n    return x.mulDiv(y, WAD);\n}\n</code></pre></p> <p>Conversely, for any divisions of $k_n, l_n, m_n$ we use the <code>divWad</code> pure function.</p> <pre><code>function divWad(uint256 x, uint256 y) internal pure returns (uint256) {\n    return x.mulDiv(WAD, y);\n}\n</code></pre>"},{"location":"docs/core/accounting/SharesAccountingEdgeCases/","title":"Shares Accounting Edge Cases","text":"<p>This document is meant to explore and analyze the different mathematical operations we are performing in the slashing release. Primarily we want to ensure safety on rounding and overflow situations. Prior reading of the Shares Accounting is required to make sense of this document.</p>"},{"location":"docs/core/accounting/SharesAccountingEdgeCases/#prior-reading","title":"Prior Reading","text":"<ul> <li>ELIP-002: Slashing via Unique Stake and Operator Sets</li> <li>Shares Accounting</li> </ul>"},{"location":"docs/core/accounting/SharesAccountingEdgeCases/#fully-slashed-for-a-strategy","title":"Fully Slashed for a Strategy","text":"<p>Within the context of a single Strategy, recall that updates to the deposit scaling factor $k_n$ are defined as the following:</p> <p>$$ k_{n+1} = \\frac{s_n k_n m_n + d_n}{s_{n+1} l_{n+1} m_{n+1}}=\\frac{s_n k_n l_n m_n + d_n}{(s_n+d_n)l_nm_n} $$</p> <p>We can see here that calculating $k_{n+1}$ can give us a divide by 0 error if any of $(s_n + d_n)$, $l_n$, or $m_n$ are equal to 0. The $(s_n + d_n) = 0$ case should not arise because the <code>EigenPodManager</code> and <code>StrategyManager</code> will not report share increases in this case. However, the other two terms may reach 0: * When an operator is 100% slashed for a given strategy and their max magnitude $m_n = 0$ * When a staker's <code>EigenPod</code> native ETH balance is 0 and their validators have all been slashed such that $l_n = 0$</p> <p>In these cases, updates to a staker's deposit scaling factor will encounter a division by 0 error. In either case, we know that since either the operator was fully slashed or the staker was fully slashed for the <code>beaconChainETHStrategy</code> then their withdrawable shares $a_n = 0$.</p> <p>In practice, if $m_n = 0$ for a given operator, then: 1. Any staker who is already delegated to this operator will be unable to deposit additional assets into the corresponding strategy  2. Any staker that currently holds deposit shares in this strategy and is NOT delegated to the operator will be unable to delegate to the operator</p> <p>Note that in the first case, it is possible for the staker to undelegate, queue, and complete withdrawals - though as $a_n = 0$, they will not receive any withdrawable shares as a result.</p> <p>Additionally, if $l_n = 0$ for a given staker in the beacon chain ETH strategy, then any further deposits of ETH or restaking of validators will not yield shares in EigenLayer. This should only occur in extraordinary circumstances, as a beacon chain slashing factor of 0 means that a staker both has ~0 assets in their <code>EigenPod</code>, and ALL of their validators have been ~100% slashed on the beacon chain - something that happens only when coordinated groups of validators are slashed. If this case occurs, an <code>EigenPod</code> is essentially bricked - the pod owner should NOT send ETH to the pod, and should NOT point additional validators at the pod.</p> <p>These are all expected edge cases and their occurrences and side effects are within acceptable tolerances.</p>"},{"location":"docs/core/accounting/SharesAccountingEdgeCases/#upper-bound-on-deposit-scaling-factor-k_n","title":"Upper Bound on Deposit Scaling Factor $k_n$","text":"<p>Let's examine potential overflow situations with respect to calculating a staker's withdrawable shares. Below is the function in <code>SlashingLib.sol</code> which calculates $a_n = s_nk_nl_nm_n$. \\ Note: <code>slashingFactor</code> = $l_nm_n$</p> <pre><code>function calcWithdrawable(\n    DepositScalingFactor memory dsf,\n    uint256 depositShares,\n    uint256 slashingFactor\n) internal pure returns (uint256) {\n    /// forgefmt: disable-next-item\n    return depositShares\n        .mulWad(dsf.scalingFactor())\n        .mulWad(slashingFactor);\n}\n</code></pre> <p><code>depositShares</code> are the staker\u2019s shares $s_n$ in storage. We know this can at max be 1e38 - 1 as this is the max total shares we allow in a strategy. $l_n \u2264 1e18$ and $m_n \u2264 1e18$ as they are montonically decreasing values. So a <code>mulWad</code> of the <code>slashingFactor</code> operation should never result in a overflow, it will always result in a smaller or equal number.</p> <p>The question now comes to <code>depositShares.mulWad(dsf.scalingFactor())</code> and whether this term will overflow a <code>uint256</code>. Let's examine the math behind this. The function <code>SlashingLib.update</code> performs the following calculation:</p> <p>$$ k_{n+1} =\\frac{s_n k_n l_n m_n + d_n}{(s_n+d_n)l_nm_n} $$</p> <p>Assuming: - $k_0 = 1$ - 0 &lt; $l_0$ \u2264 1 and is monotonically decreasing but doesn\u2019t reach 0 - 0 &lt; $m_0$ \u2264 1 and is monotonically decreasing but doesn\u2019t reach 0 - 0 \u2264 $s_n, {s_{n+1}}$ \u2264 1e38 - 1 (<code>MAX_TOTAL_SHARES = 1e38 - 1</code> in StrategyBase.sol) - 0 &lt; $d_n$ \u2264 1e38 - 1 - ${s_{n+1}}={s_n} + {d_n}$</p> <p>Rewriting above we can get the following by factoring out the k and cancelling out some terms.</p> <p>$$ k_{n+1} = k_n\\frac{s_n}{s_n + d_n} + \\frac{d_n}{(s_n+d_n)l_nm_n} $$</p> <p>The first term  $\\frac{s_n}{{{s_n} + {d_n}}}$ &lt; 1 so when multiplied with $k_n$ will not contribute to the growth of ${k_{n+1}}$ if only considering this term. </p> <p>The second term $\\frac{d_n}{({{s_n} + {d_n}}){l_n}{m_n}}$ however can make $k_n$ grow over time depending on how small ${l_n}{m_n}$ becomes and also how large $d_n$ is proportionally compared to $s_n$. We only care about the worst case scenario here so let\u2019s assume the upper bound on the existing shares and new deposit amount by rounding the value up to 1.</p> <p>Now in practice, the smallest values ${l_n}$ and ${m_n}$ could equal to is 1/1e18. Substituting this in the above second term gives the following:</p> <p>$$ \\frac{d_n}{(s_n+d_n)l_nm_n} = \\frac{d_n}{s_n+d_n}*1e18^2 $$</p> <p>So lets round up the first term $\\frac{s_n}{{{s_n} + {d_n}}}$ to 1 and also $\\frac{d_n}{{{s_n} + {d_n}}}$ in the second term to 1. We can simplify the recursive definition of k in this worst case scenario as the following.</p> <p>$$ k_{n+1} = k_n\\frac{s_n}{s_n + d_n} + \\frac{d_n}{(s_n+d_n)l_nm_n} $$</p> <p>$$ =&gt; k_{n+1} = k_n+ \\frac{d_n}{(s_n+d_n)l_nm_n} $$</p> <p>$$ =&gt; k_{n+1} = k_n + 1e36 $$</p> <p>Because of the max shares in storage for a strategy is 1e38 - 1 and deposits must be non-zero we can actually come up with an upper bound on ${k_n}$ by having 1e38-1 deposits of amount 1, updating ${k_n}$ each time.</p> <p>$$ k_{1e38-1} \\approx (1e38-1)\\cdot 1e36 &lt; 1e74 $$</p> <p>After 1e38-1 iterations/deposits, the upper bound on k we calculate is 1e74 in the worst case scenario. This is technically possible if as a staker, you are delegated to an operator for the beaconChainStrategy where your operator has been slashed 99.9999999\u2026% for native ETH but also as a staker you have had proportional EigenPod balance decreases up to 99.9999999\u2026..%.</p> <p>The max shares of 1e38-1 also accommodates the entire supply of ETH as well (only needs 27 bits). For normal StrategyManager strategies,  ${l_n} = 1$ and ${k_n}$ would not grow nearly to the same extent.</p> <p>Clearly this value of 1e74 for ${k_n}$ fits within a uint256 storage slot.</p> <p>Bringing this all back to the <code>calcWithdrawable</code> method used to calculate your actual withdrawable shares for a staker as well as the actual next ${k_{n+1}}$ value. We can see here that the shares is not expected to overflow given the constraints on all our variables and the use of the depositScalingFactor is safe.</p> <p>The staker depositScalingFactor is unbounded on how it can increase over time but because of the lower bounds we have  ${l_n}$ and  ${m_n}$ as well as the upper bound on number of shares a strategy has (or amount of ETH in existence w.r.t beaconChainStrategy) we can see that it is infeasble for the deposit scaling factor $k_n$ to overflow in our contracts.  </p>"},{"location":"docs/core/accounting/SharesAccountingEdgeCases/#rounding-behavior-considerations","title":"Rounding Behavior Considerations","text":"<p>The <code>SlashingLib.sol</code> introduces some small rounding precision errors due to the usage of <code>mulWad</code>/<code>divWad</code> operations in the contracts where we are doing a <code>x * y / denominator</code> operation. In Solidity, we round down to the nearest integer introducing an absolute error of up to 1 wei. Taking this into consideration, in certain portions of code, we will explicitly use either take the floor or ceiling value of <code>x * y / denominator</code>.</p> <p>This has implications on several parts of the system. For example, completing a withdrawal as shares and having your updated withdrawable shares being less than what it was originally due to rounding. For stakers having a non-WAD beacon chain slashing factor(BCSF) this is essentially self induced from being penalized/slashed on the BC. For operator's have non-WAD maxMagnitudes for specific strategies, it is also a result of them being slashed by the OperatorSet(s) they are allocated to. Stakers should be wary of delegating to operators of low maxMagnitude for the strategies they they have deposits in. The impact of rounding error can result in a larger discrepancy between what they should have withdrawable vs what they actually can withdraw.</p>"},{"location":"docs/core/accounting/SharesAccountingEdgeCases/#rounding-up-on-slashing","title":"Rounding up on Slashing","text":"<p>When an operator is slashed by an operatorSet in the <code>AllocationManager</code>, we actually want to round up on slashing. Rather than calculating <code>floor(x * y / denominator)</code> from mulDiv, we want <code>ceiling(x * y / denominator)</code>. This is because we don\u2019t want any kind of DOS scenario where an operatorSet attempting to slash an operator is rounded to 0; potentially possible if an operator registered for their own fake AVS and slashed themselves repeatedly to bring their maxMagnitude to a small enough value. This will ensure an operator is always slashed for some amount from their maxMagnitude which eventually, if they are slashed enough, can reach 0.</p> <p><code>AllocationManager.slashOperator</code> <pre><code>// 3. Calculate the amount of magnitude being slashed, and subtract from\n// the operator's currently-allocated magnitude, as well as the strategy's\n// max and encumbered magnitudes\nuint64 slashedMagnitude = uint64(uint256(allocation.currentMagnitude).mulWadRoundUp(params.wadsToSlash[i]));\n</code></pre></p>"},{"location":"docs/core/accounting/SharesAccountingEdgeCases/#deposits-actually-reducing-withdrawableshares","title":"Deposits actually reducing withdrawableShares","text":"<p>There are some very particular edge cases where, due to rounding error, deposits can actually decrease withdrawble shares for a staker which is conceptually wrong. The unit test <code>DelegationUnit.t.sol:test_increaseDelegatedShares_depositRepeatedly</code> exemplifies this where there is an increasing difference over the course of multiple deposits between a staker's withdrawable shares and the staker's delegated operator shares. Essentially, what\u2019s happening in this test case is that after the very first deposit of a large amount of shares, subsequent deposits of amount 1000 are causing the getWithdrawable shares to actually decrease for the staker.</p> <p>Since the operatorShares are simply incrementing by the exact depositShares, the operatorShares mapping is increasing as expected. This ends up creating a very big discrepancy/drift between the two values after performing 1000 deposits. The difference between the operatorShares and the staker\u2019s withdrawableShares ends up being <code>4.418e13</code>.</p> <p>Granted the initial deposit amount was <code>4.418e28</code> which is magnitudes larger than the discrepancy here but this its important to note the side effects of the redesigned accounting model. Instead of purely incremented/decremented amounts, we have introduced magnitudes and scaling factor variables which now result in small amounts of rounding error from division in several places. We deem this rounding behavior to be tolerable given the costs associated for the number of transactions to emulate this and the proportional error is very small.</p>"},{"location":"docs/core/accounting/SharesAccountingEdgeCases/#slashing-and-rounding-up-operator-shares-and-rounding-down-on-staker-withdrawable-shares","title":"Slashing and Rounding Up Operator Shares and Rounding down on Staker Withdrawable Shares","text":"<p>As can be observed in the <code>SlashingLib.sol</code> library, we round up on the operatorShares when slashing and round down on the staker's withdrawableShares. If we look at a core invariant of the shares accounting model, we ideally want to preserve the following:</p> <p>$$ op_n = \\sum_{i=1}^{k} a_{n,i} $$</p> <p>where $op_n$ is the operatorShares at time $n$ and $a_{n,i}$ is the staker's withdrawableShares at time $n$ for the $i^{th}$ staker.</p> <p>However due to rounding limitations, there will be some error introduced in calculating the amount of operator shares to slash above and also in calculating the staker's withdrawableShares. To prevent a situation where all stakers were to attempt to withdraw and the operatorShares underflows, we round up on the operatorShares when slashing and round down on the staker's withdrawableShares.</p> <p>So in practice, the above invariant becomes.</p> <p>$$ op_n \\geq \\sum_{i=1}^{k} a_{n,i} $$</p> <p>Upwards rounding on calculating the amount of operatorShares to give to an operator after slashing is intentionally performed in <code>SlashingLib.calcSlashedAmount</code>. For calculating a staker's withdrawableShares, there are many different factors to consider such as calculating their depositScalingFactor, their slashingFactor, and calculating the amount of withdrawable shares altogether with their depositShares. These variables are all by default rounded down in calculation and is expected behavior for stakers.</p>"},{"location":"docs/core/accounting/SharesAccountingEdgeCases/#upper-bound-on-residual-operator-shares","title":"Upper bound on Residual Operator Shares","text":"<p>Related to the above rounding error on deposits, we want to calculate what is the worst case rounding error for a staker depositing shares into EigenLayer. That is, what is the largest difference between the depositShares deposited and the resulting withdrawableShares? For a staker who initially deposits without getting slashed, these two values should conceptually be equal. Let's examine below.</p> <p>Below is a code snippet of <code>SlashingLib.sol</code> <pre><code>function update(\n    DepositScalingFactor storage dsf,\n    uint256 prevDepositShares,\n    uint256 addedShares,\n    uint256 slashingFactor\n) internal {\n    // If this is the staker's first deposit, set the scaling factor to\n    // the inverse of slashingFactor\n    if (prevDepositShares == 0) {\n        dsf._scalingFactor = uint256(WAD).divWad(slashingFactor);\n        return;\n    }\n\n...\n\nfunction calcWithdrawable(\n    DepositScalingFactor memory dsf,\n    uint256 depositShares,\n    uint256 slashingFactor\n) internal pure returns (uint256) {\n    /// forgefmt: disable-next-item\n    return depositShares\n        .mulWad(dsf.scalingFactor())\n        .mulWad(slashingFactor);\n}\n</code></pre></p> <p>Mathematically, withdrawable shares can be represented as below</p> <p>$$ withdrawableShares = d\\space\\cdot\\space \\frac{k}{WAD} \\space\\cdot\\space \\frac{slashingFactor}{WAD} $$</p> <p>Substituting $k$ with <code>WAD.divWad(slashingFactor)</code> (see update function above) if the staker only has done one single deposit of amount $d$. Also expanding out slashingFactor which is <code>maxMagnitude.mulWad(beaconChainScalingFactor)</code></p> <p>$$ = d\\space\\cdot\\space \\frac{\\frac{WAD\\space\\cdot \\space WAD}{m_{deposit} \\cdot l_{deposit}}}{WAD} \\space\\cdot\\space \\frac{\\frac{m \\space\\cdot\\space l}{WAD}}{WAD} $$</p> <p>Above is the real true value of the amount of withdrawable shares a staker has but in practice, there are rounding implications at each division operation. It becomes the following</p> <p>$$ withdrawableShares (rounded) = \\lfloor \\lfloor  d \\space\\cdot\\space  \\frac{\\lfloor\\frac{WAD\\space\\cdot \\space WAD }{m_{deposit} \\space\\cdot\\space l_{deposit}} \\rfloor }{WAD} \\rfloor  \\space\\cdot\\space \\frac{\\lfloor \\frac{m \\space\\cdot\\space l}{WAD}\\rfloor}{WAD} \\rfloor $$</p> <p>Each floor operation can introduce a rounding error of at most 1 wei. Because there are nested divisions however, this error can result in a total error thats larger than just off by 1 wei. We can rewrite parts of above with epsilon $e$ which is in the range of [0,1].</p> <ol> <li>First inner rounded term</li> </ol> <p>$$ \\frac{WAD \\cdot WAD}{m_{deposit} \\cdot l_{deposit}} = \\lfloor \\frac{WAD \\cdot WAD}{m_{deposit} \\cdot l_{deposit}} \\rfloor + \\epsilon_1 $$</p> <p>$$ \\frac{\\lfloor \\frac{WAD \\cdot WAD}{m_{deposit} \\cdot l_{deposit}} \\rfloor}{WAD} = \\frac{\\frac{WAD \\cdot WAD}{m_{deposit} \\cdot l_{deposit}} - \\epsilon_1}{WAD} $$</p> <ol> <li>Second rounded term</li> </ol> <p>$$ \\lfloor d \\cdot \\frac{\\lfloor \\frac{WAD \\cdot WAD}{m_{deposit} \\cdot l_{deposit}} \\rfloor}{WAD} \\rfloor $$</p> <p>$$ = \\lfloor d \\cdot \\frac{WAD \\cdot WAD}{m_{deposit} \\cdot l_{deposit} \\cdot WAD} - d \\cdot \\frac{\\epsilon_1}{WAD} \\rfloor $$</p> <p>$$ = d \\cdot \\frac{WAD \\cdot WAD}{m_{deposit} \\cdot l_{deposit} \\cdot WAD} - d \\cdot \\frac{\\epsilon_1}{WAD} - \\epsilon_2 $$</p> <ol> <li>Third rounded term</li> </ol> <p>$$ \\lfloor \\frac{m \\cdot l}{WAD} \\rfloor = \\frac{m \\cdot l}{WAD}  - \\epsilon_3 $$</p> <p>$$ =&gt; \\frac{\\lfloor \\frac{m \\cdot l}{WAD} \\rfloor}{WAD} = \\frac{\\frac{m \\cdot l}{WAD} - \\epsilon_3}{WAD} $$</p> <p>$$ =&gt; \\frac{\\lfloor \\frac{m \\cdot l}{WAD} \\rfloor}{WAD} = \\frac{m \\cdot l}{WAD^2} - \\frac{\\epsilon_3}{WAD} $$</p> <ol> <li>Now bringing it all back to the original equation</li> </ol> <p>$$ withdrawableShares (rounded) = \\lfloor \\lfloor  d \\space\\cdot\\space  \\frac{\\lfloor\\frac{WAD\\space\\cdot \\space WAD }{m_{deposit} \\space\\cdot\\space l_{deposit}} \\rfloor }{WAD} \\rfloor  \\space\\cdot\\space \\frac{\\lfloor \\frac{m \\space\\cdot\\space l}{WAD}\\rfloor}{WAD} \\rfloor $$</p> <p>$$ = \\lfloor\\left(d \\cdot \\frac{WAD \\cdot WAD}{m_{deposit} \\cdot l_{deposit} \\cdot WAD} - d \\cdot \\frac{\\epsilon_1}{WAD} - \\epsilon_2\\right)\\cdot\\left(\\frac{m \\cdot l}{WAD^2} - \\frac{\\epsilon_3}{WAD}\\right)\\rfloor $$</p> <p>$$ = \\left( d \\cdot \\frac{WAD \\cdot WAD}{m_{deposit} \\cdot l_{deposit} \\cdot WAD} - d \\cdot \\frac{\\epsilon_1}{WAD} - \\epsilon_2 \\right) \\cdot \\left( \\frac{m \\cdot l}{WAD^2} - \\frac{\\epsilon_3}{WAD} \\right) - \\epsilon_4 $$</p> <p>After expansion and some simplification</p> <p>$$ withdrawableShares (rounded) = d \\cdot \\frac{m\\cdot l}{m_{deposit} \\cdot l_{deposit}\\cdot WAD} - d \\cdot \\frac{\\epsilon_1 \\cdot m \\cdot l}{WAD^3} - \\frac{\\epsilon_2 \\cdot m \\cdot l}{WAD^2} - d \\cdot \\frac{\\epsilon_3}{m_{deposit} \\cdot l_{deposit} } + \\text{(higher-order terms)} $$</p> <p>Note that (higher-order terms) are the terms with multiple epsilon terms where the amounts become negligible, because each term $e$ is &lt; 1.</p> <p>The true value term is the following:</p> <p>$$ withdrawableShares = d\\space\\cdot\\space \\frac{\\frac{WAD \\space\\cdot\\space WAD}{m_{deposit} \\cdot l_{deposit}}}{WAD} \\space\\cdot\\space \\frac{\\frac{m \\space\\cdot\\space l}{WAD}}{WAD} $$</p> <p>$$ = d\\space\\cdot\\space \\frac{WAD }{m_{deposit} \\cdot l_{deposit}}\\space\\cdot\\space \\frac{m \\space\\cdot\\space l}{WAD^2} $$</p> <p>$$ d \\cdot \\frac{m\\cdot l}{m_{deposit } \\cdot l_{deposit}\\cdot WAD} $$</p> <p>But we can see this term show in the withdrawableShares(rounded) above in the first term! Then we can see that we can represent the equations as the following. </p> <p>$$ withdrawableShares (rounded) = withdrawableShares - d \\cdot \\frac{\\epsilon_1 \\cdot m \\cdot l}{WAD^3} - \\frac{\\epsilon_2 \\cdot m \\cdot l}{WAD^2} - d \\cdot \\frac{\\epsilon_3 }{m_{deposit} \\cdot l_{deposit} } + \\text{(higher-order terms)} $$</p> <p>This intuitively makes sense as all the rounding error comes from the epsilon terms and how they propagate out from being nested. Therefore the introduced error from rounding are all the rounding terms added up ignoring the higher-order terms.</p> <p>$$ roundedError =d \\cdot \\frac{\\epsilon_1 \\cdot m \\cdot l}{WAD^3} + \\frac{\\epsilon_2 \\cdot m \\cdot l}{WAD^2} + d \\cdot \\frac{\\epsilon_3 }{m_{\\text{deposit}} \\cdot l_{deposit} } $$</p> <p>Now lets assume the worst case scenario of maximizing this sum above, if each epsilon $e$ is replaced with the value of 1 due to a full wei being rounded off we can get the following.</p> <p>$$ d \\cdot \\frac{m \\cdot l}{WAD^3} + \\frac{ m \\cdot l}{WAD^2} + \\frac{ d}{m_{\\text{deposit}} \\cdot l_{deposit}} $$</p> <p>Assuming close to max values that results in rounding behaviour, we can maximize this total sum by having $d = 1e38$ ,  $m, m_{deposit}, l, l_{deposit}$ equal to WAD(1e18) then we get the following:</p> <p>$$ \\frac{1e38\\cdot WAD^2}{WAD^3} + \\frac{ WAD^2}{WAD^2} + \\frac{1e38}{1e36} $$</p> <p>$$ =&gt; \\frac{1e38}{1e18} + 1 + 100 $$</p> <p>$$ \\approx 1e20 $$</p> <p>Framed in another way, the amount of loss a staker can have is $\\frac{1}{1e18}$ th of the deposit amount. This makes sense as a result of having nested flooring operations that are then multiplied against outer terms. Over time, as stakers deposit and withdraw, they may not receive as many shares as their \u201creal\u201d withdrawable amount as this is rounded down and there could be residual/dust shares amount in the delegated operatorShares mapping AND in the original Strategy contract. This is known and we specifically round down to avoid underflow of operatorShares if all their delegated stakers were to withdraw.</p>"},{"location":"docs/core/accounting/SlashingEdgeCase/","title":"Dual Slashing Edge Case","text":"<p>This document describes edge cases surrounding the slashing of a staker for native ETH by the beacon chain (BC) and an AVS. </p>"},{"location":"docs/core/accounting/SlashingEdgeCase/#prior-reading","title":"Prior Reading","text":"<ul> <li>ELIP-002: Slashing via Unique Stake and Operator Sets</li> <li>ELIP-004: Slashing-Aware EigenPods</li> <li>Shares Accounting</li> </ul>"},{"location":"docs/core/accounting/SlashingEdgeCase/#scenario","title":"Scenario","text":"<p>Consider a staker, Alice who is in the following state:</p> <ol> <li>Alice has verified a validator. <code>withdrawable: 32 ETH</code></li> <li> <p>Alice's operator is slashed for 75%. <code>withdrawable: 8 ETH</code> Calculation <ul> <li><code>depositShares: 32</code> </li> <li><code>maxMagnitude: 0.25</code></li> <li><code>BCSF: 1</code></li> <li><code>DSF: 1</code></li> <li><code>withdrawable = 32 * 0.25 * 1 * 1 = 8 ETH</code> </li> <li>Alice is slashed by 16 ETH on the beacon chain</li> </ul>"},{"location":"docs/core/accounting/SlashingEdgeCase/#restaking","title":"Restaking","text":"<p>We define restaking as reusing staked ETH as security for AVSs. Thus, the same Native ETH that is securing the BC (beacon chain) can also be slashed by an AVS, with priority burning rights going to the BC.</p> <p>In the above scenario, let's say the Alice now proves a checkpoint.</p> <ol> <li> <p>A checkpoint of BC state is proven. <code>withdrawable: 4 ETH</code> Calculation <ul> <li><code>depositShares: 16</code></li> <li><code>maxMagnitude: 0.25</code></li> <li><code>BCSF: 1</code></li> <li><code>DSF: 1</code></li> <li><code>withdrawable = 16 * 0.25 * 1 * 1 = 4 ETH</code> </li> </ul> <p>The checkpoint slash has devalued Alice's currently withdrawable assets by 50%. The AVS slashes from what's left due to the BC getting priority burning rights. Thus, AVSs must factor Native ETH (or an LST) being slashed by the beacon chain when designing their slashing conditions. The below diagram illustrates this behavior:</p> Diagram showing how AVS slashing is applied after Beacon Chain slashing, with BC having priority burning rights <p>Note that the portion that is marked as BC Slash and BC + AVS Slash has priority burning rights by the beacon chain. 12 ETH has been slashed \"twice\", but this is by design given our definition of restaking.</p> <p>The behavior of BC and AVS slashings for Native ETH mimics the behavior of slashings for an LST in isolation (see below for an additional edge case). This ensures that Native ETH security is not disadvantaged compared to LST security. ELIP-004 explains this in more detail.</p>"},{"location":"docs/core/accounting/SlashingEdgeCase/#ordering-of-eigenpod-actions","title":"Ordering of EigenPod Actions","text":"<p>When an AVS slashes, its attributable slashed amount is between 0 and the originally slashed amount. The attributable slashed amount decreases in the event of BC slashes. We see this behavior in the above example, where the 12 ETH that was attributed to the AVS is less than the original 24 ETH that was slashed. </p> <p>However, given the asynchronous nature of the EigenPod proof system, Alice may have a different number of withdrawable shares depending on the ordering of her actions. Note that even in this case, assets are not overslashed.</p> <p>Let's start with our above scenario. </p> <p>Scenario A:</p> <ol> <li> <p>Alice verifies another validator. <code>withdrawable: 40 ETH</code> Calculation <ul> <li><code>depositShares: 64</code></li> <li><code>maxMagnitude: 0.25</code></li> <li><code>BCSF: 1</code></li> <li><code>DSF = 40 / (32 + 32) / 0.25 = 2.5</code></li> <li><code>withdrawable = 64 * 0.25 * 1 * 2.5 = 40 ETH</code> </li> </ul> <li> <p>Alice checkpoints all her pods. <code>withdrawable: 30 ETH</code> Calculation <ul> <li><code>depositShares: 64</code></li> <li><code>maxMagnitude: 0.25</code></li> <li><code>BCSF = 48 / 64 = 0.75</code></li> <li><code>DSF: 2.5</code></li> <li><code>withdrawable = 64 * 0.25 * 0.75 * 2.5 = 30 ETH</code> </li> </ul> <p>In this scenario, 25% of Alice's currently proven assets are slashed. Similarly, the AVSs attributable slashed amount has been decreased by 25% (24 \u2192 18 ETH). </p> <p>Scenario B:</p> <ol> <li> <p>Alice checkpoints her pod. <code>withdrawable: 4 ETH</code> Calculation <ul> <li><code>depositShares: 32</code></li> <li><code>maxMagnitude: 0.25</code></li> <li><code>BCSF = 16 / 32 = 0.5</code></li> <li><code>DSF: 1</code></li> <li><code>withdrawable = 32 * 0.25 * 0.5 * 1 = 4 ETH</code> </li> </ul> <li> <p>Alice verifies another validator. <code>withdrawable: 40 ETH</code> Calculation <ul> <li><code>depositShares: 64</code></li> <li><code>maxMagnitude: 0.25</code></li> <li><code>BCSF: 0.5</code></li> <li><code>DSF = 36 / (32 + 32) / 0.125 = 4.5</code></li> <li><code>withdrawable = 64 * 0.25 * 0.5 * 4.5 = 36 ETH</code> </li> </ul> <p>In scenario B, 50% of Alice's currently proven assets are slashed, along with a commensurate decrease in the AVSs attributable slashed amount. In both cases Alice's withdrawable shares and the AVSs attributable slashed amount decrease by the same percentage.</p> <p>We acknowledge this edge case. A benefit of this system is that stakers are incentivized to immediately prove BC slashed. Eigen Labs runs an off-chain process (EigenPod Health Checker) that monitors BC slashings and starts checkpoints as needed. Conversely, when Native-ETH burning is implemented, AVSs are incentivized to immediately exit stakers from the BC to recoup the maximum possible attributable slashed amount.  </p> <p>This edge case also applies if Alice undelegates after being slashed on the beacon chain, and then continues along with Scenario A, exiting her position fully. See below for details:</p> Scenario  1. Alice verifies a validator: `withdrawable: 32 ETH` 2. Alice's operator is slashed for 100%. `withdrawable: 0 ETH`  3. Alice is slashed by 16 ETH on the beacon chain.  4. Alice undelegates. `depositShares = 0`  5. Alice verifies another validator. `withdrawable: 32 ETH`. `depositShares: 32 ETH`  6. Alice checkpoints her slash from step 3. `withdrawable: 24 ETH`     - `restakedExecutionLayerGwei = 16`. This is the AVSs attributable slashed amount, but it increases once Alice completely exits.      - `BCSF= 48/64 = 0.75` 7. Alice completes her withdrawal as shares from undelegation. No affect since the operator's magnitude was 0 8. Alice exits her validator from step 5. `withdrawable: 24 ETH`     - `restakedExecutionLayerGwei = 48`  9. Alice queues a withdrawal for all shares. `scaledShares = 32`  10. Alice completes her withdrawal. Alice receives 24 ETH     - `scaledShares * slashingFactor = 32 * 0.75 = 24`  11. There is 24 ETH locked up in the pod."},{"location":"docs/experimental/AVS-Guide/","title":"Purpose","text":"<p>This document aims to describe and summarize how actively validated services (AVSs) building on EigenLayer interact with the core EigenLayer protocol.</p> <p>Currently, this doc explains how AVS developers can use the current APIs for: - enabling operators to opt-in to the AVS, - enabling operators to opt-out (withdraw stake) from the AVS, - enabling operators to continuously update their commitments to middlewares, and - enabling AVS to freeze operators for the purpose of slashing (the corresponding unfreeze actions are determined by the veto committee).</p> <p>\ud83d\udea7 The Slasher contract is under active development and its interface is expected to change. We recommend writing slashing logic without integrating with the Slasher at this point in time. \ud83d\udea7</p> <p>We are currently in the process of implementing the API for rewards flow from AVSs to operators in EigenLayer. Details of this API will be added to this document in the near future.</p> <p>The following figure summarizes the scope of this document</p>"},{"location":"docs/experimental/AVS-Guide/#introduction","title":"Introduction","text":"<p>In designing EigenLayer, the EigenLabs team aspired to make minimal assumptions about the structure of AVSs built on top of it. If you are getting started looking at EigenLayer's codebase, the <code>Slasher.sol</code> contains most of the logic that actually mediates the interactions between EigenLayer and AVSs. Additionally, there is a general-purpose [/middleware/ folder][middleware-folder-link], which contains code that can be extended, used directly, or consulted as a reference in building an AVS on top of EigenLayer. Note that there will be a single, EigenLayer-owned, <code>Slasher.sol</code> contract, but all the <code>middleware</code> contracts are AVS-specific and need to be deployed separately by AVS teams.</p>"},{"location":"docs/experimental/AVS-Guide/#important-terminology","title":"Important Terminology","text":"<ul> <li>Tasks - A task in EigenLayer is the smallest unit of work that operators commit to perform when serving an AVS. These tasks may be associated with one or more slashing conditions applicable to the AVS.</li> <li>Strategies - A strategy in EigenLayer is a contract that holds staker deposits, i.e. it controls one or more asset(s) that can be restaked. At launch EigenLayer will feature only simple strategies which may hold a single token. However, EigenLayer's strategy design is flexible and open, and in the future strategies could be deployed which implement more complex logic, including DeFi integrations.</li> <li>Quorums - A quorum in EigenLayer is a grouping of specific kinds of stake who opt into an AVS while satisfying a particular trait. Examples of such traits could be stETH stakers or native stakers.  The purpose of having a quorum is that an AVS can customize the makeup of their security offering by choosing which kinds of stake/security they would like to utilize.</li> </ul>"},{"location":"docs/experimental/AVS-Guide/#key-design-considerations","title":"Key Design Considerations","text":"<ol> <li> <p>Decomposition into \"Tasks\":      EigenLayer assumes that an AVS manages tasks that are executed over time by a registered operator. Each task is associated with the time period during which the AVS's operators' stakes are placed \"at stake\", i.e. potentially subject to slashing. Examples of tasks could be:</p> <ul> <li>Hosting and serving a \u201cDataStore\u201d in the context of EigenDA</li> <li>Posting a state root of another blockchain for a bridge service</li> </ul> </li> <li> <p>Stake is \"At Stake\" on Tasks for a Finite Duration:      It is assumed that every task (eventually) resolves. Each operator places their stake in EigenLayer \u201cat stake\u201d on the tasks that they perform. In order to \u201crelease\u201d the stake (e.g. so the operator can withdraw their funds), these tasks need to eventually resolve. It is RECOMMENDED, but not required that a predefined duration is specified in the AVS contract for each task. As a guideline, the EigenLabs team believes that the duration of a task should be aligned with the longest reasonable duration that would be acceptable for an operator to keep funds \u201cat stake\u201d. An AVS builder should recognize that extending the duration of a task may impose significant negative externalities on the stakers of EigenLayer, and may disincentivize operators from opting-in to serving their application (so that they can attract more delegated stake).</p> </li> <li> <p>Services Slash Only Objectively Attributable Behavior:      EigenLayer is built to support slashing as a result of an on-chain-checkable, objectively attributable action. An AVS SHOULD slash in EigenLayer only for such provable and attributable behavior. It is expected that operators will be very hesitant to opt-in to services that slash for other types of behavior, and other services may even choose to exclude operators who have opted-in to serving one or more AVSs with such \u201csubjective slashing conditions\u201d, as these slashing conditions present a significant challenge for risk modeling, and may be perceived as more dangerous in general. Some examples of on-chain-checkable, objectively attributable behavior:</p> <ul> <li>double-signing a block in Ethereum, but NOT inactivity leak;</li> <li>proofs-of-custody in EigenDA, but NOT a node ceasing to serve data;</li> <li>a node in a light-node-bridge AVS signing an invalid block from another chain.</li> </ul> </li> <li> <p>Single Point-of-Interaction for Services and EigenLayer:      It is assumed that services have a single contract that coordinates the service\u2019s communications sent to EigenLayer. This contract \u2013 referred to as the ServiceManager \u2013 informs EigenLayer of operator registration, updates, and deregistration, as well as signaling to EigenLayer when an operator should be slashed (frozen). An AVS has full control over how it splits the actual logic involved, but is expected to route all calls to EigenLayer through a single contract. While technically possible, an AVS SHOULD NOT use multiple contracts to interact with EigenLayer. An AVS architecture using multiple contracts to interact with EigenLayer will impose additional burden on stakers in EigenLayer when withdrawing stake.</p> </li> </ol>"},{"location":"docs/experimental/AVS-Guide/#integration-with-eigenlayer-contracts","title":"Integration with EigenLayer Contracts:","text":"<p>In this section, we will explain various API interfaces that EigenLayer provides which are essential for AVSs to integrate with EigenLayer.</p>"},{"location":"docs/experimental/AVS-Guide/#operators-opting-into-avs","title":"Operators Opting into AVS","text":"<p>In order for any EigenLayer operator to be able to opt-in to an AVS, EigenLayer provides two interfaces: <code>optIntoSlashing(..)</code> and <code>recordFirstStakeUpdate(..)</code>. The sequential flow for opting into an AVS using these functions is as follows: 1. The operator first opts into slashing by calling  <code>Slasher.optIntoSlashing(..)</code>, where it has to specify the address of the AVS's ServiceManager contract in the argument. This step results in the operator giving permission to the AVS's ServiceManager contract to slash the operator via EigenLayer, if the operator is ever proven to have engaged in adversarial behavior while responding to the AVS's task. A successful call to  <code>Slasher.optIntoSlashing(..)</code> emits the <code>OptedIntoSlashing(..)</code> event. 2. Next, the operator needs to register with the AVS on chain via an AVS-specific registry contract (see [this][middleware-guide-link] section for examples). To integrate with EigenLayer, the AVS's Registry contract provides a registration endpoint that calls on the AVS's <code>ServiceManager.recordFirstStakeUpdate(..)</code> which in turn calls <code>Slasher.recordFirstStakeUpdate(..)</code>. On successful execution of this function call, the event <code>MiddlewareTimesAdded(..)</code> is emitted and the operator has to start serving the tasks from the AVS.</p> <p>The following figure illustrates the above flow: </p>"},{"location":"docs/experimental/AVS-Guide/#staker-delegation-to-an-operator-which-opts-in-to-avss","title":"Staker Delegation to an Operator: Which Opts-In to AVSs","text":"<p>A staker does not restake into AVSs. A staker delegates to an operator and it is the operator that registers for new AVSs (with the staker having option to opt-out).</p> <p>By delegating to a specific operator, stakers are implicitly agreeing to the AVSs they support. If desired, operators can pursue off-chain consensus with stakers prior to modifying their AVSs. Moreover, stakers will have a grace period to withdraw their delegation should an operator introduce an AVS that doesn't align with their objectives. This grace period is configurable on an operator level.</p>"},{"location":"docs/experimental/AVS-Guide/#avs-visibility-and-control","title":"AVS Visibility and Control","text":"<p>An AVS registration function can blacklist another AVS contract and during registration check that the operator is not registered in that AVS. Or it can check that the operator has not given permission to that AVS's service manager to slash it.</p> <p>An AVS registry contract should define quorums (eth LST quorum, erc20 quorum, etc.) and allow (or prefer) operators having a minimum amount of restaked assets in each of those quorums to register with the AVS.</p>"},{"location":"docs/experimental/AVS-Guide/#recording-stake-updates","title":"Recording Stake Updates","text":"<p>EigenLayer is a dynamic system where stakers and operators are constantly adjusting amounts of stake delegated via the system. It is therefore imperative for an AVS to be aware of any changes to stake delegated to its operators. In order to facilitate this, EigenLayer offers the <code>Slasher.recordStakeUpdate(..)</code>.</p> <p>Let us illustrate the usage of this facility with an example: A staker has delegated to an operator, who has opted-in to serving an AVS. Whenever the staker withdraws some or all of its stake from EigenLayer, this withdrawal affects all the AVSs uniformly that the staker's delegated operator is participating in. The series of steps for withdrawing stake is as follows:  - The staker queues their withdrawal request with EigenLayer. The staker can place this request by calling  <code>StrategyManager.queueWithdrawal(..)</code>.  - The operator, noticing an upcoming change in their delegated stake, notifies the AVS about this change. To do this, the operator triggers the AVS to call the <code>ServiceManager.recordStakeUpdate(..)</code> which in turn accesses <code>Slasher.recordStakeUpdate(..)</code>.  On successful execution of this call, the event <code>MiddlewareTimesAdded(..)</code> is emitted. - The AVS provider now is aware of the change in stake, and the staker can eventually complete their withdrawal.  Refer here for more details</p> <p>The following figure illustrates the above flow: </p>"},{"location":"docs/experimental/AVS-Guide/#deregistering-from-avs","title":"Deregistering from AVS","text":"<p>In order for any EigenLayer operator to be able to de-register from an AVS, EigenLayer provides the interface <code>Slasher.recordLastStakeUpdateAndRevokeSlashingAbility(..)</code>. Essentially, in order for an operator to deregister from an AVS, the operator has to call <code>Slasher.recordLastStakeUpdateAndRevokeSlashingAbility(..)</code>  via the AVS's ServiceManager contract. It is important to note that the latest block number until which the operator is required to serve tasks for the service must be known by the service and included in the ServiceManager's call to <code>Slasher.recordLastStakeUpdateAndRevokeSlashingAbility</code>.</p> <p>The following figure illustrates the above flow in which the operator calls the <code>deregister(..)</code> function in a sample Registry contract. </p>"},{"location":"docs/experimental/AVS-Guide/#slashing","title":"Slashing","text":"<p>As mentioned above, EigenLayer is built to support slashing as a result of an on-chain-checkable, objectively attributable action. In order for an AVS to be able to slash an operator in an objective manner, the AVS needs to deploy a DisputeResolution contract which anyone can call to raise a challenge against an EigenLayer operator for its adversarial action. On successful challenge, the DisputeResolution contract calls <code>ServiceManager.freezeOperator(..)</code>; the ServiceManager in turn calls <code>Slasher.freezeOperator(..)</code> to freeze the operator in EigenLayer. EigenLayer's Slasher contract emits a <code>OperatorFrozen(..)</code> event whenever an operator is (successfully) frozen</p> <p>The following figure illustrates the above flow: </p>"},{"location":"docs/experimental/AVS-Guide/#quick-start-guide-to-build-avs-contracts","title":"Quick Start Guide to Build AVS Contracts:","text":"<p>The EigenLayer team has built a set of reusable and extensible contracts for use in AVSs built on top of EigenLayer. These are contained in the general-purpose [/middleware/ folder][middleware-folder-link], which contains code that can be extended, used directly, or consulted as a reference in building AVS on top of EigenLayer. There are several basic contracts that all AVS-specific contracts can be built on: - The VoteWeigherBase contract tracks an operator\u2019s \u201cweight\u201d in a given quorum, across all strategies that are associated with that quorum.  This contract also manages which strategies are in each quorum - this includes functionalities for both adding and removing strategies, as well as changing strategy weights. - The RegistryBase contract is a basic registry contract that can be used to track operators opted-into running an AVS.  Importantly, this base registry contract assumes a maximum of two quorums, where each quorum represents an aggregation of a certain type of stake.</p> <p>Furthermore, it\u2019s expected that many AVSs will require a quorum of registered operators to sign on commitments.  To this end, the EigenLabs team has developed a set of contracts designed to optimize the cost of checking signatures through the use of a BLS aggregate signature scheme:</p>"},{"location":"docs/experimental/AVS-Guide/#blspublickeycompendium","title":"BLSPublicKeyCompendium","text":"<p>This contract allows each Ethereum address to register a unique BLS public key; a single BLSPublicKeyCompendium contract can be shared amongst all AVSs using BLS signatures. </p>"},{"location":"docs/experimental/AVS-Guide/#blsregistry","title":"BLSRegistry","text":"<p>This contract builds upon lower-level (RegistryBase and VoteWeigherBase) contracts, to allow users of EigenLayer to register as operators for a single AVS. Each AVS\u2019s BLSRegistry keeps a historic record of the Aggregate Public Key (APK) of all operators of the AVS. To allow proper encoding of data and aggregation of signatures while avoiding race conditions (e.g. from operators registering or deregistering, causing the current APK to change), each task defines a referenceBlockNumber, which may be briefly in the past. The BLSRegistry defines an optional whitelister role, which controls whether or not the whitelist is enabled and can edit the whitelist. If the whitelist is enabled, then only addresses that have been whitelisted may opt-in to serving the AVS. </p> <p>In addition, the BLSRegistry (technically the lower-level RegistryBase which the BLSRegistry inherits from) defines a \u201cminimum stake\u201d for the quorum(s). An operator can only register for the AVS if they meet the minimum requirement for at least one quorum. By default the <code>ServiceManager.owner()</code> has the ability to change the minimum stake requirement(s). Each BLSRegistry defines one or two \u201cquorums\u201d; each operator for the AVS may have stake in EigenLayer that falls into either (or both) quorum(s). Each quorum is essentially defined by two vectors: a vector of \u201cStrategies\u201d of interest (in practice this ends up being tokens of interest) and a vector of \u201cweights\u201d or \u201cmultipliers\u201d, which define whether certain strategies are weighed more heavily than others within the quorum (e.g. if the AVS desires to give 2x power to a specific token over another token). In the contract code these vectors are condensed into a single array of <code>StrategyAndWeightingMultiplier</code> structs. The <code>ServiceManager.owner()</code> has the ability to edit these arrays at will.</p>"},{"location":"docs/experimental/AVS-Guide/#blssignaturechecker","title":"BLSSignatureChecker","text":"<p>When signatures have been aggregated, they can be submitted to the BLSSignatureChecker, an optimized contract designed expressly for verifying quorums of BLS signers. The caller MUST provide a small amount of data corresponding to the task to be confirmed, the aggregate signature itself, and a bit of data for each non-signer, that is, the caller MUST provide data for each operator registered for the service for whom their signature has not been aggregated. The BLSSignatureChecker ultimately returns both the total stake that was present at the specified block number (i.e. the sum of all operator\u2019s stakes) and the total stake that signed; these amounts can then be checked against a quorum condition (e.g. requiring \u2154 stake to sign) before the task is ultimately confirmed.</p>"},{"location":"docs/permissions/PermissionController/","title":"PermissionController","text":"File Type Proxy <code>PermissionController.sol</code> Singleton Transparent proxy <p>The <code>PermissionController</code> handles user permissions for protocol contracts which explicitly integrate it. Note that \"users\" in the context of the <code>PermissionController</code> refers to AVSs and operators; it does not refer to stakers.</p> <p>The <code>PermissionController</code> is integrated into other core contracts, enabling (for specific methods) AVSs and operators to designate other accounts (\"appointees\") that can call these methods on their behalf. The core contracts using the <code>PermissionController</code> as a dependency are the: * <code>DelegationManager</code> * <code>AllocationManager</code> * <code>RewardsCoordinator</code></p> <p>The <code>PermissionController</code> defines three different roles: * Accounts * Admins * Appointees</p>"},{"location":"docs/permissions/PermissionController/#accounts","title":"Accounts","text":"<p>Accounts refer to the Ethereum address through which one interacts with the protocol if no appointees are set. From the core contracts' perspective, accounts are the \"state holder,\" i.e. the address referenced in storage when a contract method interacts with state. For example, in the <code>DelegationManager</code>, the <code>operator</code> address that holds shares in the <code>operatorShares</code> mapping is an \"account.\" In the <code>AllocationManager</code>, an AVS's \"account\" is the address under which operator sets are created.</p> <p>The <code>PermissionController</code> allows an account to designate admins and/or appointees to take certain actions on its behalf. Note that setting up admins/appointees is optional, and carries with it a significant responsibility to ensure the designated actors are intentionally being granted authority.</p> <p>Both admins AND appointees can be granted authority to act on an account's behalf. Admins are granted full reign over any <code>PermissionController</code>-enabled functions, while appointees must be granted authority to call specific functions on specific contracts. The list of methods that are <code>PermissionController</code>-enabled follow.</p> <p>For operators: * <code>AllocationManager.modifyAllocations</code> * <code>AllocationManager.registerForOperatorSets</code> * <code>AllocationManager.deregisterFromOperatorSets</code> * <code>AllocationManager.setAllocationDelay</code> * <code>DelegationManager.modifyOperatorDetails</code> * <code>DelegationManager.updateOperatorMetadataURI</code> * <code>DelegationManager.undelegate</code> * <code>RewardsCoordinator.setClaimerFor</code> * <code>RewardsCoordinator.setClaimerFor</code> * <code>RewardsCoordinator.setOperatorAVSSplit</code> * <code>RewardsCoordinator.setOperatorPISplit</code></p> <p>For AVSs: * <code>AllocationManager.slashOperator</code> * <code>AllocationManager.deregisterFromOperatorSets</code> * <code>AllocationManager.setAVSRegistrar</code> * <code>AllocationManager.updateAVSMetadataURI</code> * <code>AllocationManager.createOperatorSets</code> * <code>AllocationManager.addStrategiesToOperatorSet</code> * <code>AllocationManager.removeStrategiesFromOperatorSet</code> * <code>RewardsCoordinator.createOperatorDirectedAVSRewardsSubmission</code> * <code>RewardsCoordinator.setClaimerFor</code></p>"},{"location":"docs/permissions/PermissionController/#account-permissions","title":"Account Permissions","text":"<p>Account permissions are stored within a struct defined as follows:</p> <pre><code>struct AccountPermissions {\n    /// @notice The pending admins of the account\n    EnumerableSet.AddressSet pendingAdmins;\n    /// @notice The admins of the account\n    EnumerableSet.AddressSet admins;\n    /// @notice Mapping from an appointee to the list of encoded target &amp; selectors\n    mapping(address appointee =&gt; EnumerableSet.Bytes32Set) appointeePermissions;\n    /// @notice Mapping from encoded target &amp; selector to the list of appointees\n    mapping(bytes32 targetSelector =&gt; EnumerableSet.AddressSet) permissionAppointees;\n}\n</code></pre> <p>These structs are then stored within a mapping defined as follows, allowing for fetching account permissions for a given account with ease:</p> <pre><code>mapping(address account =&gt; AccountPermissions) internal _permissions;\n</code></pre> <p>By default, no other address can perform an action on behalf of a given account. However, accounts can add admins and/or appointees to give other addresses the ability to act on their behalf.</p>"},{"location":"docs/permissions/PermissionController/#admins","title":"Admins","text":"<p>Admins are able to take ANY action on behalf of an original account -- including adding or removing admins. This enables operations like key rotation for operators, or creating a backup admin which is stored on a cold key.</p> <p>Note: by default, an account is its own admin. However, once an admin is added, this is no longer the case; only the admins listed in <code>_permissions.admins</code> are admins. If an account wants to both add admins AND continue acting as its own admin, it must be added to the admins list.</p>"},{"location":"docs/permissions/PermissionController/#adding-an-admin","title":"Adding an Admin","text":"<p>The relevant functions for admin addition are:</p> <ul> <li><code>addPendingAdmin</code></li> <li><code>removePendingAdmin</code></li> <li><code>acceptAdmin</code></li> </ul>"},{"location":"docs/permissions/PermissionController/#addpendingadmin","title":"<code>addPendingAdmin</code>","text":"<pre><code>/**\n * @notice Sets a pending admin of an account\n * @param account to set pending admin for\n * @param admin to set\n * @dev Multiple admins can be set for an account\n */\nfunction addPendingAdmin(address account, address admin) external onlyAdmin(account);\n</code></pre> <p>When adding a new admin, an account or admin must first call <code>addPendingAdmin()</code>. Then, the pending admin must call <code>acceptAdmin()</code> to complete the process. An account cannot force an admin role upon another account.</p> <p>Pending admins do not have any particular authority, but are granted the full authority of an admin once they call <code>acceptAdmin()</code>.</p> <p>Effects: * An address is added to the <code>pendingAdmins</code> set for the account * A <code>PendingAdminAdded</code> event is emitted specifying the account for which a pending admin was added</p> <p>Requirements: * The proposed admin MUST NOT already be an admin for the <code>account</code> * The proposed admin MUST NOT be a pending admin for the <code>account</code> * Caller MUST be an admin for the <code>account</code>, or the <code>account</code> itself if no admin is set</p>"},{"location":"docs/permissions/PermissionController/#removependingadmin","title":"<code>removePendingAdmin</code>","text":"<pre><code>/**\n * @notice Removes a pending admin of an account\n * @param account to remove pending admin for\n * @param admin to remove\n * @dev Only the admin of the account can remove a pending admin\n */\nfunction removePendingAdmin(address account, address admin) external onlyAdmin(account);\n</code></pre> <p>An account or admin can call <code>removePendingAdmin()</code> to prevent a pending admin from accepting their role. However, this will only work if the pending admin has not already called <code>acceptAdmin()</code>. If this occurs, an admin can call <code>removeAdmin</code> to remove the unwanted admin.</p> <p>Effects: * An address is removed from the <code>pendingAdmins</code> set for the account * A <code>PendingAdminRemoved</code> event is emitted specifying the account for which a pending admin was removed</p> <p>Requirements: * The proposed admin MUST be a pending admin for the account * Caller MUST be an admin for the account, or the account's address itself if no admin is set</p>"},{"location":"docs/permissions/PermissionController/#acceptadmin","title":"<code>acceptAdmin</code>","text":"<pre><code>/**\n * @notice Accepts the admin role of an account\n * @param account to accept admin for\n * @dev Only a pending admin for the account can become an admin\n */\nfunction acceptAdmin(address account) external;\n</code></pre> <p>Called by a pending admin to claim the admin role for an account. The caller must have been previously added as a pending admin.</p> <p>Note that once an account has successfully added an admin (i.e. the pending admin has called <code>acceptAdmin()</code>), the account's address itself no longer has its default admin privileges. This behavior benefits accounts seeking to perform a key rotation, as adding an admin allows them to remove permissions from their original, potentially compromised, key. If an account wants to retain admin privileges for its own address, it is recommended to first add itself as an admin, then add any other admins as desired.</p> <p>Effects: * The caller is removed from the <code>pendingAdmins</code> set for the account * The caller is added to the <code>admins</code> set for the account * A <code>AdminSet</code> event is emitted specifying the account for which an admin was added</p> <p>Requirements: * Caller MUST be a pending admin for the account</p>"},{"location":"docs/permissions/PermissionController/#removing-an-admin","title":"Removing an Admin","text":""},{"location":"docs/permissions/PermissionController/#removeadmin","title":"<code>removeAdmin</code>","text":"<pre><code>/**\n * @notice Remove an admin of an account\n * @param account to remove admin for\n * @param admin to remove\n * @dev Only the admin of the account can remove an admin\n * @dev Reverts when an admin is removed such that no admins are remaining\n */\nfunction removeAdmin(address account, address admin) external onlyAdmin(account);\n</code></pre> <p>An admin of an account can call <code>removeAdmin()</code> to remove any other admins of the same account. However, one admin must always remain for any given account. In other words, once an account has added an admin, it must always have at least one admin in perpetuity.</p> <p>Effects: * The specified admin is removed from the <code>admins</code> set for the account * An <code>AdminRemoved</code> event is emitted specifying the accuont for which an admin was removed</p> <p>Requirements: * <code>admins.length()</code> MUST be greater than 1, such that removing the admin does not remove all admins for the account * The address to remove MUST be an admin for the account * Caller MUST be an admin for the account, or the account's address itself if no admin is set</p>"},{"location":"docs/permissions/PermissionController/#appointees","title":"Appointees","text":"<p>Appointees are able to act as another account for a specific function for a specific contract, granting accounts granular access control.</p> <p>Specifically, an account (or its admins) can grant an appointee access to a specific <code>selector</code> (i.e function) on a given <code>target</code> (i.e. contract). The <code>target</code> and <code>selector</code> are combined in the form of the <code>targetSelector</code> and serve to uniquely identify a permissioned function on a specific contract.</p> <p>Appointees can be granted access to multiple functions/contracts. Each new <code>targetSelector</code> permission granted requires setting the appointee from scratch, and revoking the appointee's permission requires revoking each individual <code>targetSelector</code> permission, as described below.</p>"},{"location":"docs/permissions/PermissionController/#adding-an-appointee","title":"Adding an Appointee","text":""},{"location":"docs/permissions/PermissionController/#setappointee","title":"<code>setAppointee</code>","text":"<pre><code>/**\n * @notice Set an appointee for a given account\n * @param account to set appointee for\n * @param appointee to set\n * @param target to set appointee for\n * @param selector to set appointee for\n * @dev Only the admin of the account can set an appointee\n */\nfunction setAppointee(\n    address account,\n    address appointee,\n    address target,\n    bytes4 selector\n) external onlyAdmin(account);\n</code></pre> <p>An account (or its admins) can call <code>setAppointee()</code> to give another address the ability to call a specific function on a given contract. That address is then only able to call that specific function on that specific contract on behalf of <code>account</code>.</p> <p>Note that unlike the process to become an admin, there is no requirement for the <code>appointee</code> to accept the appointment.</p> <p>Effects: * The <code>targetSelector</code> is added to the specified <code>appointee</code> set within the  <code>appointeePermissions</code> mapping * The <code>appointee</code> is added to the specified <code>targetSelector</code> set within the  <code>permissionAppointees</code> mapping * The <code>AppointeeSet</code> event is emitted, specifying the account, appointee, target contract, and function selector</p> <p>Requirements: * Caller MUST be an admin for the account, or the account's address itself if no admin is set * The proposed appointee MUST NOT already have permissions for the given <code>targetSelector</code></p>"},{"location":"docs/permissions/PermissionController/#removing-an-appointee","title":"Removing an Appointee","text":""},{"location":"docs/permissions/PermissionController/#removeappointee","title":"<code>removeAppointee</code>","text":"<pre><code>/**\n * Removes an appointee for a given account\n * @param account to remove appointee for\n * @param appointee to remove\n * @param target to remove appointee for\n * @param selector to remove appointee for\n * @dev Only the admin of the account can remove an appointee\n */\nfunction removeAppointee(\n    address account,\n    address appointee,\n    address target,\n    bytes4 selector\n) external onlyAdmin(account);\n</code></pre> <p>An account (or its admins) can call <code>removeAppointee()</code> to remove an <code>appointee's</code> permissions for a given contract/function pair. Note that there does not exist any way currently to atomically remove all permissions for a given appointee, or all appointees for a given function selector - each permission must be revoked individually.</p> <p>Also note that permissions to specific functions/contracts cannot be revoked for admins. Admins always have full access, unless another admin removes them from the admin list.</p> <p>Effects: * The <code>targetSelector</code> is removed from the specified <code>appointee</code> set within the  <code>appointeePermissions</code> mapping * The <code>appointee</code> is removed from the specified <code>targetSelector</code> set within the  <code>permissionAppointees</code> mapping * The <code>AppointeeRemoved</code> event is emitted, specifying the account, appointee, target contract, and function selector</p> <p>Requirements: * Caller MUST be an admin for the account, or the account's address itself if no admin is set * The proposed appointee MUST already have permissions for the given <code>targetSelector</code></p>"}]}